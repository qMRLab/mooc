{"version":1,"kind":"Notebook","sha256":"298c03f1e011e8fcc4de722dcef1fcdb4ede6681727ff1958e1f4fed46322f71","slug":"figure-5-1-5","location":"/5 B0 Mapping/1 B0 Inhomogeneities/Notebooks/Figure-5-1-5.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"date":"2024-10-08","open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true}},"github":"https://github.com/qmrlab/mooc","subject":"mOOC","venue":{"title":"qMRLab"},"numbering":{"heading_1":{"enabled":true},"heading_2":{"enabled":true},"heading_3":{"enabled":true},"heading_4":{"enabled":true},"heading_5":{"enabled":true},"heading_6":{"enabled":true},"title":{"offset":1}},"keywords":["quantitative MRI","education"],"copyright":"NeuroPoly 2024","abbreviations":{"MRI":"Magnetic resonance imaging","MR":"Magnetic resonance","NMR":"Nuclear Magnetic Resonance","qMRI":"quantitative magnetic resonance imaging","GPT":"Generative Pre-trained Transformer","MRM":"Magnetic Resonance in Medicine","B0":"Main magnetic field","B1":"Radiofrequency field","FID":"Free Induction Decay","Gx":"X-axis gradient","Gy":"Y-axis gradient","Gz":"Z-axis gradient","TR":"Repetition Time","TE":"Echo Time","TI":"Inversion Time","CSF":"Cerebrospinal fluid","T1":"Longitudinal magnetization relaxation time constant","_T_{sub}`1`":"Longitudinal magnetization relaxation time constant","T2":"Transverse magnetization relaxation time constant","SE":"Spin Echo","GRE":"Gradient Echo","SPGR":"Spoiled Gradient Echo (sequence)","UMAP":"Uniform manifold approximation and projection","ADC":"Analog to digital converter","RF":"Radiofrequency","FA":"Flip Angle","VFA":"Variable Flip Angle","DESPOT1":"Driven Equilibrium Single Pulse Observation of _T_{sub}`1`","SNR":"Signal-to-noise ratio","RD-NLS":"reduced-dimension non-linear least-squares","STD":"Standard deviation","MT":"Magnetization Transfer","MTR":"Magnetization Transfer Ratio","MS":"Multiple Sclerosis","qMT":"Quantitative Magnetization Transfer","MTsat":"Magnetization Transfer saturation","SAR":"Specific absorption rate","FWHM":"Full width at half maximum"},"edit_url":"https://github.com/qmrlab/mooc/blob/mb/requirements/5 B0 Mapping/1 B0 Inhomogeneities/Notebooks/Figure-5-1-5.ipynb","exports":[{"format":"ipynb","filename":"Figure-5-1-5.ipynb","url":"/Figure-5-1-5-9d187ef25792e86a7abb1bce4fc05af7.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# Prepare Python environment\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\ndef calc_dk(gx, gy, dt):\n    dkx = GYRO_BAR_RATIO_H * gx * dt\n    dky = GYRO_BAR_RATIO_H * gy * dt\n    return (dkx, dky)\n\ngy_bad = 100e-6\n\nend_time = 0.0912\nn_times = 913\nt = np.linspace(0, end_time, n_times)\ndt = end_time / n_times\nnx = 64\nk = np.zeros([n_times, 2])\nk_distorted = np.zeros([n_times, 2])\nfor it in range(1, n_times):\n    \n    if it <= 20:\n        gx = -40e-3\n        gy = -40e-3\n    else:\n        n_steps = 138\n        i = (it - 20) % n_steps\n        if i <= 0:\n            gx = 0\n            gy = 25e-3\n        elif i <= nx:\n            gx = 25e-3\n            gy = 0\n        elif i <= nx + 5:\n            gx = 0\n            gy = 25e-3\n        elif i <= (2*nx) + 5:\n            gx = -25e-3\n            gy = 0\n        elif i <= n_steps:\n            gx = 0\n            gy = 25e-3\n\n    dkx, dky = calc_dk(gx, gy, dt)\n    kx = k[it - 1, 0] + dkx\n    ky = k[it - 1, 1] + dky\n    k[it, :] = [kx, ky]\n    dkx, dky = calc_dk(gx, gy + gy_bad, dt)\n    kx = k_distorted[it - 1, 0] + dkx\n    ky = k_distorted[it - 1, 1] + dky\n    k_distorted[it, :] = [kx, ky]\n\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=k[:, 0], y=k[:, 1],\n                     mode='lines',\n                     line=dict(color='#636EFA'),\n                     name='Theoretical trajectory'))\nfig.add_trace(go.Scatter(x=k_distorted[:, 0], y=k_distorted[:, 1],\n                     mode='lines',\n                     line=dict(color='#fa6363'),\n                     name='Inhomogeneous trajectory'))\nframes = [dict(\n    data=[go.Scatter(x=k[:2*i, 0], y=k[:2*i, 1],\n                     mode='lines',\n                     line=dict(color='#636EFA'),\n                     name='Theoretical trajectory'),\n          go.Scatter(x=k_distorted[:2*i, 0], y=k_distorted[:2*i, 1],\n                     mode='lines',\n                     line=dict(color='#fa6363'),\n                     name='Inhomogeneous trajectory')],\n    name=str(i),\n    traces=[0,1]) for i in range(int(n_times/2))]\nfig.frames = frames\n\nfig.update_xaxes(range=[-3500, 3500])\nfig.update_yaxes(range=[-3700, 3700])\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.update_layout(title=\"K-space Trajectory\",\n                  title_x=0.5,\n                  height=600,\n                  width=700,\n                  updatemenus=[dict(\n                                type='buttons',\n                                buttons=[dict(label='Play',\n                                              method='animate',\n                                              args=[None, dict(frame=dict(duration=15, redraw=False), transition=dict(duration=15), fromcurrent=True, mode='immediate')]),\n                                         dict(label='Pause',\n                                              method='animate',\n                                              args=[[None], dict(frame=dict(duration=0, redraw=False), mode='immediate')])\n                                        ])])\nfig.show()","identifier":"b0fig5jn-code","enumerator":"1","html_id":"b0fig5jn-code","key":"jSS3wLGVML"},{"type":"output","id":"VATsgXJPX7u0XNy5Cqi4u","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"1c518371609279761dde03655266bd07","path":"/1c518371609279761dde03655266bd07.json"}}}],"identifier":"b0fig5jn-output","html_id":"b0fig5jn-output","key":"kWwz8MyJwl"}],"identifier":"b0fig5jn","label":"b0Fig5jn","html_id":"b0fig5jn","key":"XxRi0vYjON"}],"key":"uUJIDQKZF3"},"references":{"cite":{"order":[],"data":{}}}}