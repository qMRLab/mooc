{"version":1,"kind":"Notebook","sha256":"7b16abcd00235c80a19003fd063cf4d4051b3f6f3620f72aaa3d6641de0ea299","slug":"figure-5-1-4","location":"/5 B0 Mapping/1 B0 Inhomogeneities/Notebooks/Figure-5-1-4.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"date":"2024-10-08","open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true}},"github":"https://github.com/qmrlab/mooc","subject":"mOOC","venue":{"title":"qMRLab"},"numbering":{"heading_1":{"enabled":true},"heading_2":{"enabled":true},"heading_3":{"enabled":true},"heading_4":{"enabled":true},"heading_5":{"enabled":true},"heading_6":{"enabled":true},"title":{"offset":1}},"keywords":["quantitative MRI","education"],"copyright":"NeuroPoly 2024","abbreviations":{"MRI":"Magnetic resonance imaging","MR":"Magnetic resonance","NMR":"Nuclear Magnetic Resonance","qMRI":"quantitative magnetic resonance imaging","GPT":"Generative Pre-trained Transformer","MRM":"Magnetic Resonance in Medicine","B0":"Main magnetic field","B1":"Radiofrequency field","FID":"Free Induction Decay","Gx":"X-axis gradient","Gy":"Y-axis gradient","Gz":"Z-axis gradient","TR":"Repetition Time","TE":"Echo Time","TI":"Inversion Time","CSF":"Cerebrospinal fluid","T1":"Longitudinal magnetization relaxation time constant","_T_{sub}`1`":"Longitudinal magnetization relaxation time constant","T2":"Transverse magnetization relaxation time constant","SE":"Spin Echo","GRE":"Gradient Echo","SPGR":"Spoiled Gradient Echo (sequence)","UMAP":"Uniform manifold approximation and projection","ADC":"Analog to digital converter","RF":"Radiofrequency","FA":"Flip Angle","VFA":"Variable Flip Angle","DESPOT1":"Driven Equilibrium Single Pulse Observation of _T_{sub}`1`","SNR":"Signal-to-noise ratio","RD-NLS":"reduced-dimension non-linear least-squares","STD":"Standard deviation","MT":"Magnetization Transfer","MTR":"Magnetization Transfer Ratio","MS":"Multiple Sclerosis","qMT":"Quantitative Magnetization Transfer","MTsat":"Magnetization Transfer saturation","SAR":"Specific absorption rate","FWHM":"Full width at half maximum"},"edit_url":"https://github.com/qmrlab/mooc/blob/mb/requirements/5 B0 Mapping/1 B0 Inhomogeneities/Notebooks/Figure-5-1-4.ipynb","exports":[{"format":"ipynb","filename":"Figure-5-1-4.ipynb","url":"/Figure-5-1-4-a7fa801f1290ab15f6b328353a9001e6.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\n\ndata_dir = Path(\"../../../../DATA/qmrlab-mooc/05-B0/data\")\n\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n# Note: Field was reduced a lot to be able to show the sinusoid\n# Note: *2 after lowpass filter is because this is a single coil (sin instead of e^(-ix)) and demodulating by multiplying a sinusoid creates a 1/2 difference. In practice, since we have both x and y components, we can recover the full signal instead of doing X2.\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\nb0 = 0.000002  # [T]\nT2 = 0.3  # s\ny_0_cst = 100\nfs = 10000\n\nf_larmor = b0 * GYRO_BAR_RATIO_H\nt = np.linspace(0, 1, fs + 1)  # 1 second\n\ndef butter_lowpass(cutoff, fs, order=5):\n    return butter(order, cutoff, fs=fs, btype='low', analog=False)\n\ndef butter_lowpass_filter(data, cutoff, fs, order=5):\n    b, a = butter_lowpass(cutoff, fs, order=order)\n    y = filtfilt(b, a, data, method='gust')\n    return y\n\n# Lab frame\ny_0 = y_0_cst * np.sin(2 * math.pi * f_larmor * t)\nexp = np.exp(-t/T2)\ny = y_0 * exp / y_0_cst\ntemp = y * (y_0 / y_0_cst)\ny_demod = butter_lowpass_filter(temp, f_larmor, fs, order=5) * 2\n\nfig = go.Figure()\nfig.add_scatter(x=t, y=y, name=\"FID\")\nfig.add_scatter(x=t, y=y_demod, name=\"Demodulated FID\")\nfig.add_scatter(x=t, y=exp, name=\"T2 decay\")\n\n# 2 isochromats\ny_1amp = y_0_cst / 10\ny_1 = y_1amp * np.sin(2 * math.pi * (f_larmor + 10) * t)\ny = (y_0 + y_1) * exp / (y_0_cst + y_1amp)\ntemp = y * (y_0 / y_0_cst)\ny_demod = butter_lowpass_filter(temp, f_larmor, fs, order=5) * 2\n\nfig.add_scatter(x=t, y=y, name=\"FID\", visible=False)\nfig.add_scatter(x=t, y=y_demod, name=\"Demodulated FID\", visible=False)\nfig.add_scatter(x=t, y=exp, name=\"T2 decay\", visible=False)\n\n# Multiple isochromats\nn_freqs = 100\nfid = y_0 * exp\ny_sum_demod = butter_lowpass_filter(fid * (y_0 / y_0_cst), f_larmor, fs, order=5) * 2\nfor i in range(n_freqs):\n    amp = 1\n    freq_offset = 10\n    scale = freq_offset/n_freqs\n    mid = n_freqs // 2\n    y_1 = amp * np.sin(2 * math.pi * (f_larmor + scale*(mid - i)) * t) * exp\n    fid += y_1\n    y_demod = butter_lowpass_filter(y_1 * (y_0 / y_0_cst), f_larmor, fs, order=5) * 2\n    y_sum_demod += y_demod\n\ny_demod_scaled = y_sum_demod / (y_0_cst + (n_freqs * amp))\nfid_scaled = fid / (y_0_cst + (n_freqs * amp))\n\nfig.add_scatter(x=t, y=fid_scaled, name=\"FID\", visible=False)\nfig.add_scatter(x=t, y=y_demod_scaled, name=\"Demodulated FID\", visible=False)\nfig.add_scatter(x=t, y=exp, name=\"T2 decay\", visible=False)\nfig.update_traces(marker=dict(size=3))\nfig.update_layout(\n    title=\"Single species\",\n    title_x=0.5,\n    updatemenus=[\n        dict(\n            buttons=list([\n                dict(\n                    args=[{\"visible\": [True, True, True, False, False, False, False, False, False]},\n                          {\"title\": \"Single species\"}],\n                    label=\"Single species\",\n                    method=\"update\"\n                ),\n                dict(\n                    args=[{\"visible\": [False, False, False, True, True, True, False, False, False]},\n                          {\"title\": \"Two species\"}],\n                    label=\"Two species\",\n                    method=\"update\"\n                ),\n                dict(\n                    args=[{\"visible\": [False, False, False, False, False, False, True, True, True]},\n                          {\"title\": \"Multiple Species\"}],\n                    label=\"Multiple Species\",\n                    method=\"update\"\n                )\n            ]),\n            direction=\"down\",\n            showactive=True,\n\n        ),\n    ])\nfig.show()","identifier":"b0fig4jn-code","enumerator":"1","html_id":"b0fig4jn-code","key":"ZbbQHo6z6g"},{"type":"output","id":"EZ5M1AnRokJA5Pqm2NOzN","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"ddf4b70eda854ab5da45e5c71d326cf1","path":"/ddf4b70eda854ab5da45e5c71d326cf1.json"}}}],"identifier":"b0fig4jn-output","html_id":"b0fig4jn-output","key":"zcmyuIW9Xn"}],"identifier":"b0fig4jn","label":"b0Fig4jn","html_id":"b0fig4jn","key":"IbLjcEzYx4"}],"key":"KWX4MGMSU9"},"references":{"cite":{"order":[],"data":{}}}}