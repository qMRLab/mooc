{"version":1,"kind":"Notebook","sha256":"2e693e5ef716148500209a28b8387956c29838a78347c1a8eb8a667cbc790821","slug":"figure-5-4-4","location":"/5 B0 Mapping/4 Advanced B0 Mapping Methods/Notebooks/Figure-5-4-4.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"date":"2024-10-08","open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true}},"github":"https://github.com/qmrlab/mooc","subject":"mOOC","venue":{"title":"qMRLab"},"numbering":{"heading_1":{"enabled":true},"heading_2":{"enabled":true},"heading_3":{"enabled":true},"heading_4":{"enabled":true},"heading_5":{"enabled":true},"heading_6":{"enabled":true},"title":{"offset":1}},"keywords":["quantitative MRI","education"],"copyright":"NeuroPoly 2024","abbreviations":{"MRI":"Magnetic resonance imaging","MR":"Magnetic resonance","NMR":"Nuclear Magnetic Resonance","qMRI":"quantitative magnetic resonance imaging","GPT":"Generative Pre-trained Transformer","MRM":"Magnetic Resonance in Medicine","B0":"Main magnetic field","B1":"Radiofrequency field","FID":"Free Induction Decay","Gx":"X-axis gradient","Gy":"Y-axis gradient","Gz":"Z-axis gradient","TR":"Repetition Time","TE":"Echo Time","TI":"Inversion Time","CSF":"Cerebrospinal fluid","T1":"Longitudinal magnetization relaxation time constant","_T_{sub}`1`":"Longitudinal magnetization relaxation time constant","T2":"Transverse magnetization relaxation time constant","SE":"Spin Echo","GRE":"Gradient Echo","SPGR":"Spoiled Gradient Echo (sequence)","UMAP":"Uniform manifold approximation and projection","ADC":"Analog to digital converter","RF":"Radiofrequency","FA":"Flip Angle","VFA":"Variable Flip Angle","DESPOT1":"Driven Equilibrium Single Pulse Observation of _T_{sub}`1`","SNR":"Signal-to-noise ratio","RD-NLS":"reduced-dimension non-linear least-squares","STD":"Standard deviation","MT":"Magnetization Transfer","MTR":"Magnetization Transfer Ratio","MS":"Multiple Sclerosis","qMT":"Quantitative Magnetization Transfer","MTsat":"Magnetization Transfer saturation","SAR":"Specific absorption rate","FWHM":"Full width at half maximum"},"edit_url":"https://github.com/qmrlab/mooc/blob/mb/requirements/5 B0 Mapping/4 Advanced B0 Mapping Methods/Notebooks/Figure-5-4-4.ipynb","exports":[{"format":"ipynb","filename":"Figure-5-4-4.ipynb","url":"/Figure-5-4-4-e92b0c5a085995a9c474f588763e465c.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# Prepare Python environment\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nimport copy\nPI_UNICODE = \"\\U0001D70B\"\nDELTA_UNICODE = \"\\u0394\"\nGYRO_UNICODE = \"\\U0001D6FE\"\nGREEK_DELTA_UNICODE = \"\\u03B4\"\nphase1, phase2, phase3 = (-1, 2, 14)\nphase_wrapped1 = 14-4*math.pi\nphase_unwrapped1 = 14-2*math.pi\nbeg = 0\nend = 0.016\ndef complex_difference(phase1, phase2):\n    \"\"\" Calculates the complex difference between 2 phase arrays (phase2 - phase1)\n\n    Args:\n        phase1 (numpy.ndarray): Array containing phase data in radians\n        phase2 (numpy.ndarray): Array containing phase data in radians. Must be the same shape as phase1.\n\n    Returns:\n        numpy.ndarray: The difference in phase between each voxels of phase2 and phase1 (phase2 - phase1)\n    \"\"\"\n\n    # Calculate phasediff using complex difference\n    comp_0 = np.exp(-1j * phase1)\n    comp_1 = np.exp(1j * phase2)\n    return np.angle(comp_0 * comp_1)\n\ndef umpire_3echoes(phases, times):\n    \"\"\"\n    This function performs unwrapping using the UMPIRE algorithm with 3 echoes. UMPIRE requires echo times that are unevenly spaced.\n    \"\"\"\n    \n    # Complex difference\n    dpTE2 = complex_difference(phases[1], phases[2])\n    dpTE1 = complex_difference(phases[0], phases[1])\n    dpd = complex_difference(dpTE1, dpTE2)\n    # print(\"Diff in phase diff:\" , dpd)\n    dTEs = np.array([times[1]-times[0], times[2]-times[1]])\n    dt_dpd = dTEs[1] - dTEs[0]\n    \n    # Slope\n    slope = dpd / dt_dpd\n    \n    # n wraps in differences\n    n_wraps_dp = np.round((dTEs - dTEs*slope) / (2*math.pi))\n    \n    # Remove wraps in differences\n    dpTE1_prime = dpTE1 - (2*n_wraps_dp[0]*math.pi)\n    dpTE2_prime = dpTE2 - (2*n_wraps_dp[1]*math.pi)\n    \n    # Calculate better slope\n    slope_prime1 = dpTE1_prime / dTEs[0]\n    slope_prime2 = dpTE2_prime / dTEs[1]\n    slope_avg = (slope_prime1 + slope_prime2) / 2\n    \n    # Calculate wraps in original phase\n    n_wraps = np.round((phases - t*slope_avg) / (2*math.pi))\n    \n    # Remove wraps\n    unwrapped_with_phase_offset = phases - 2*math.pi*n_wraps\n    \n    # # Calculate receiver offset\n    # r = (t[0] * unwrapped_with_phase_offset[1] - t[1] * unwrapped_with_phase_offset[0]) / dTEs[0]\n\n    # # Remove receiver phase offset\n    # phase_no_offset = complex_difference(r, unwrapped_with_phase_offset)\n    # # Unwrap one last time\n    # ns = np.round((phase_no_offset - t*slope_avg) / (2*math.pi))\n    # unwrapped_umpire = phase_no_offset - 2*math.pi*ns\n    \n    return unwrapped_with_phase_offset\n\nt = np.array([0.003, 0.011, 0.020])\ny_unwrapped = np.array([1.0, 9.05, 17.75])\nwrapped = copy.deepcopy(y_unwrapped)\nwrapped[0] = np.angle(np.exp(1j*wrapped[0]))\nwrapped[1] = np.angle(np.exp(1j*wrapped[1]))\nwrapped[2] = np.angle(np.exp(1j*wrapped[2]))\nbeg = 0.0\nend = 0.021\n\n# Fit original data\nreg1 = LinearRegression().fit(t.reshape(-1, 1), y_unwrapped.reshape(-1,1))\nfieldmap_rad1 = reg1.coef_[0]  # [rad / s]\nfieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\nt_predict1 = np.array([beg, end])\ny_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n\n# Unwrap with UMPIRE\nunwrapped_umpire = umpire_3echoes(wrapped, t)\n\n# Fit unwrapped data of UMPIRE\nreg2 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_umpire.reshape(-1,1))\n# Slope of linear regression reshaped into the shape of original 3D phase.\nfieldmap_rad2 = reg2.coef_[0]  # [rad / s]\nfieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\nt_predict2 = np.array([beg, end])\ny_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n\nt = np.array([0.003, 0.011, 0.020])\ny_unwrapped = np.array([1.0, 9.05, 17.75])\nwrapped = copy.deepcopy(y_unwrapped)\nwrapped[0] = np.angle(np.exp(1j*wrapped[0]))\nwrapped[1] = np.angle(np.exp(1j*wrapped[1]))\nwrapped[2] = np.angle(np.exp(1j*wrapped[2]))\nbeg = 0.0\nend = 0.021\n\nfig = go.Figure()\nnoises = np.arange(-0.5, 0.51, 0.01)\n# Add traces, one for each slider step\nfor noise in noises:\n    # Noisy unwrapped data\n    unwrapped_noisy = copy.deepcopy(y_unwrapped)\n    unwrapped_noisy[1] += noise\n    fig.add_trace(\n        go.Scatter(\n            visible=False,\n            mode='markers',\n            marker=dict(color='red'),\n            name=\"True Phase\",\n            x=t,\n            y=unwrapped_noisy))\n\n    # Fit of noisy unwrapped data\n    reg1 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_noisy.reshape(-1,1))\n    fieldmap_rad1 = reg1.coef_[0]  # [rad / s]\n    fieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\n    t_predict1 = np.array([beg, end])\n    y_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n    fig.add_trace(go.Scatter(visible=False, x=t_predict1, y=y_predict1, mode='lines', marker=dict(color='red'), name='True linear fit'))\n\n    # Noisy wrapped data\n    wrapped_noisy = copy.deepcopy(unwrapped_noisy)\n    wrapped_noisy[0] = np.angle(np.exp(1j*wrapped_noisy[0]))\n    wrapped_noisy[1] = np.angle(np.exp(1j*wrapped_noisy[1]))\n    wrapped_noisy[2] = np.angle(np.exp(1j*wrapped_noisy[2]))\n    fig.add_trace(\n        go.Scatter(\n            visible=False,\n            mode='markers',\n            marker=dict(color='blue'),\n            name=\"Wrapped Phase\",\n            x=t,\n            y=wrapped_noisy))\n\n    # UMPIRE\n    unwrapped_umpire = umpire_3echoes(wrapped_noisy, t)\n    fig.add_trace(\n        go.Scatter(\n            visible=False,\n            x=t, y=unwrapped_umpire, mode='markers', marker=dict(color='green'), name='Umpire'))\n\n    # Fit unwrapped data of UMPIRE\n    reg2 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_umpire.reshape(-1,1))\n    # Slope of linear regression reshaped into the shape of original 3D phase.\n    fieldmap_rad2 = reg2.coef_[0]  # [rad / s]\n    fieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\n    t_predict2 = np.array([beg, end])\n    y_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n    \n    fig.add_trace(go.Scatter(visible=False, x=t_predict2, y=y_predict2, mode='lines', marker=dict(color='green'), name='Umpire fit'))\n    \nactive = len(noises)//2\nfig.data[active].visible = True\nfig.data[active+1].visible = True\nfig.data[active+2].visible = True\nfig.data[active+3].visible = True\nfig.data[active+4].visible = True\n\n# Static plot\nfig.add_trace(go.Scatter(x=[beg, end], y=[math.pi, math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.add_trace(go.Scatter(x=[beg, end], y=[-math.pi, -math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.update_xaxes(title_text=\"Time (ms)\", range=[beg, end])\nfig.update_yaxes(title_text=\"Phase (rad)\", tickmode = 'array', range=[-4,25],\n                 tickvals = [-2*math.pi, 0, 2*math.pi, 4*math.pi, 6*math.pi],\n                 ticktext = [f'-2{PI_UNICODE}', '0', f'2{PI_UNICODE}', f'4{PI_UNICODE}', f'6{PI_UNICODE}'])\n\n# Create and add slider\nphase_offsets = [f\"{i:.2}\" for i in noises]\nsteps = []\nfor i in range(len(noises)):\n    step = dict(\n        method=\"update\",\n        label=phase_offsets[i],\n        args=[{\"visible\": [False] * 5*len(noises) + [True] * (len(fig.data) - 5*len(noises))}],  # layout attribute\n    )\n    step[\"args\"][0][\"visible\"][5*i] = True\n    step[\"args\"][0][\"visible\"][5*i + 1] = True\n    step[\"args\"][0][\"visible\"][5*i + 2] = True\n    step[\"args\"][0][\"visible\"][5*i + 3] = True\n    step[\"args\"][0][\"visible\"][5*i + 4] = True\n    steps.append(step)\n\nsliders = [dict(\n    active=active,\n    currentvalue={\"prefix\": \"2nd echo phase offset (rad): \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nfig.update_layout({\"width\": 800},\n                 sliders=sliders,\n                 title_text=\"Effect of noise using UMPIRE phase unwrapping\", title_x=0.5)\n\nfig.show()","identifier":"b0fig18jn-code","enumerator":"1","html_id":"b0fig18jn-code","key":"wpPwVNOXB3"},{"type":"output","id":"98joDVSOwvxI5r9pOQZzR","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"4abddd5b7e1c886249c38966f24d5d75","path":"/4abddd5b7e1c886249c38966f24d5d75.json"}}}],"identifier":"b0fig18jn-output","html_id":"b0fig18jn-output","key":"lvooHLGVBX"}],"identifier":"b0fig18jn","label":"b0Fig18jn","html_id":"b0fig18jn","key":"H80zTYWaKI"}],"key":"xewy4Bl0vG"},"references":{"cite":{"order":[],"data":{}}}}