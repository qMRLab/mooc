{"version":1,"kind":"Notebook","sha256":"3a256d844b702c269b47953cfe2020961362f6d5b4f9ee93ada99b5dc4d763c6","slug":"figure-5-2-3","location":"/5 B0 Mapping/2 Dual echo B0 mapping/Notebooks/Figure-5-2-3.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"date":"2024-10-08","open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true}},"github":"https://github.com/qmrlab/mooc","subject":"mOOC","venue":{"title":"qMRLab"},"numbering":{"heading_1":{"enabled":true},"heading_2":{"enabled":true},"heading_3":{"enabled":true},"heading_4":{"enabled":true},"heading_5":{"enabled":true},"heading_6":{"enabled":true},"title":{"offset":1}},"keywords":["quantitative MRI","education"],"copyright":"NeuroPoly 2024","abbreviations":{"MRI":"Magnetic resonance imaging","MR":"Magnetic resonance","NMR":"Nuclear Magnetic Resonance","qMRI":"quantitative magnetic resonance imaging","GPT":"Generative Pre-trained Transformer","MRM":"Magnetic Resonance in Medicine","B0":"Main magnetic field","B1":"Radiofrequency field","FID":"Free Induction Decay","Gx":"X-axis gradient","Gy":"Y-axis gradient","Gz":"Z-axis gradient","TR":"Repetition Time","TE":"Echo Time","TI":"Inversion Time","CSF":"Cerebrospinal fluid","T1":"Longitudinal magnetization relaxation time constant","_T_{sub}`1`":"Longitudinal magnetization relaxation time constant","T2":"Transverse magnetization relaxation time constant","SE":"Spin Echo","GRE":"Gradient Echo","SPGR":"Spoiled Gradient Echo (sequence)","UMAP":"Uniform manifold approximation and projection","ADC":"Analog to digital converter","RF":"Radiofrequency","FA":"Flip Angle","VFA":"Variable Flip Angle","DESPOT1":"Driven Equilibrium Single Pulse Observation of _T_{sub}`1`","SNR":"Signal-to-noise ratio","RD-NLS":"reduced-dimension non-linear least-squares","STD":"Standard deviation","MT":"Magnetization Transfer","MTR":"Magnetization Transfer Ratio","MS":"Multiple Sclerosis","qMT":"Quantitative Magnetization Transfer","MTsat":"Magnetization Transfer saturation","SAR":"Specific absorption rate","FWHM":"Full width at half maximum"},"edit_url":"https://github.com/qmrlab/mooc/blob/mb/requirements/5 B0 Mapping/2 Dual echo B0 mapping/Notebooks/Figure-5-2-3.ipynb","exports":[{"format":"ipynb","filename":"Figure-5-2-3.ipynb","url":"/Figure-5-2-3-35750aabe042f8ae72a3697d95839b6c.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\n\nimport scipy.io as sio\nfrom pathlib import Path\n\ndata_dir = Path(\"../../../data/05-B0/data/fmap\")\n\nPI_UNICODE = \"\\U0001D70B\"\nfname_mag_e1 = data_dir / \"sub-fmap_magnitude1.nii.gz\"\nfname_phase_e1 = data_dir / \"sub-fmap_phase1.nii.gz\"\nfname_phase_e1_json = data_dir / \"sub-fmap_phase1.json\"\nfname_phase_e2 = data_dir / \"sub-fmap_phase2.nii.gz\"\nfname_mask = data_dir / \"mask.nii.gz\"\nfname_fmap = data_dir / \"fmap.nii.gz\"\n\nnii_mag_e1 = nib.load(fname_mag_e1)\nnii_phase_e1 = nib.load(fname_phase_e1)\nnii_phase_e2 = nib.load(fname_phase_e2)\nnii_mask = nib.load(fname_mask)\nnii_fmap = nib.load(fname_fmap)\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\nPI_UNICODE = \"\\U0001D70B\"\n\ndef complex_difference(phase1, phase2):\n    \"\"\" Calculates the complex difference between 2 phase arrays (phase2 - phase1)\n\n    Args:\n        phase1 (numpy.ndarray): Array containing phase data in radians\n        phase2 (numpy.ndarray): Array containing phase data in radians. Must be the same shape as phase1.\n\n    Returns:\n        numpy.ndarray: The difference in phase between each voxels of phase2 and phase1 (phase2 - phase1)\n    \"\"\"\n\n    # Calculate phasediff using complex difference\n    comp_0 = np.exp(-1j * phase1)\n    comp_1 = np.exp(1j * phase2)\n    return np.angle(comp_0 * comp_1)\nn=2\ndef plot_2_echo_fmap(phase1, phase2, echotime1, echotime2):\n    phase_diff = complex_difference(phase1, phase2)\n    fmap = phase_diff / (echotime2 - echotime1) / 2 / math.pi\n\n    # Attempt at subplots\n    fig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Phase 1\", \"Phase 2\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]], )\n    \n    fig.add_trace(go.Heatmap(z=np.rot90(phase1, k=-1), colorscale='gray', colorbar_x=1/n - 0.05, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 1)\n    fig.add_trace(go.Heatmap(z=np.rot90(phase2, k=-1), colorscale='gray', colorbar_x=2/n - 0.02, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 2)\n    \n    fig.update_xaxes(showticklabels=False)\n    fig.update_yaxes(showticklabels=False)\n    fig.update_layout({\"height\": 450, \"width\": 750})\n    \n    fig.show()\n\n\ndef plot_2_echo_fmap_bottom(phase1, phase2, echotime1, echotime2):\n    phase_diff = complex_difference(phase1, phase2)\n    fmap = phase_diff / (echotime2 - echotime1) / 2 / math.pi\n\n    # Attempt at subplots\n    fig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Phase difference\", \"B0 field map\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]], )\n    \n    fig.add_trace(go.Heatmap(z=np.rot90(phase_diff, k=-1), colorscale='gray', colorbar_x=1/n - 0.05, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 1)\n    fig.add_trace(go.Heatmap(z=np.rot90(fmap, k=-1), colorscale='gray',colorbar_x=2/n - 0.02,\n                             colorbar=dict(title=\"Hz\",\n                                           titleside=\"top\")), 1, 2)\n    \n    fig.update_xaxes(showticklabels=False)\n    fig.update_yaxes(showticklabels=False)\n    fig.update_layout({\"height\": 450, \"width\": 750})\n    \n    fig.show()\n\ndef get_circle(x, y, r):\n    if x < 1 or y < 1 or r < 1:\n        raise ValueError(\"Input parameters are too small\")\n        \n    my_array = np.zeros([x,y])\n    for i in range(x):\n        for j in range(y):\n            squared = (i-(x/2))**2 + (j-(y/2))**2\n            h = np.sqrt(squared)\n            if h < r:\n                my_array[i,j] = 1\n    return my_array\n\necho1 = get_circle(100, 100, 30) * -1\necho2 = get_circle(100, 100, 30) * 2\necho_time1 = 0.005\necho_time2 = 0.01\n\nplot_2_echo_fmap(echo1, echo2, echo_time1, echo_time2)\n\n","identifier":"b0fig8jna-code","enumerator":"1","html_id":"b0fig8jna-code","key":"sIAUbyccC1"},{"type":"output","id":"fDV3YlsAtuvv2JIJQXFHK","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"1db13973695b0c114ef41e8a952e8c6b","path":"/1db13973695b0c114ef41e8a952e8c6b.json"}}}],"identifier":"b0fig8jna-output","html_id":"b0fig8jna-output","key":"lApy99Fp12"}],"identifier":"b0fig8jna","label":"b0Fig8jna","html_id":"b0fig8jna","key":"O63o5hBiNq"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"plot_2_echo_fmap_bottom(echo1, echo2, echo_time1, echo_time2)\n","identifier":"b0fig8jn-code","enumerator":"2","html_id":"b0fig8jn-code","key":"VcJaEYR2FN"},{"type":"output","id":"AXU308s7i9aGZzHPf-KmO","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"f2c9a568154a85b5f9b94298dcf2348b","path":"/f2c9a568154a85b5f9b94298dcf2348b.json"}}}],"identifier":"b0fig8jn-output","html_id":"b0fig8jn-output","key":"mkXa2DCEw9"}],"identifier":"b0fig8jn","label":"b0Fig8jn","html_id":"b0fig8jn","key":"DkXfRKdGJQ"}],"key":"KbdJMbuGts"},"references":{"cite":{"order":[],"data":{}}}}