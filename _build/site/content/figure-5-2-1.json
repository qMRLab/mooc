{"version":1,"kind":"Notebook","sha256":"1f0f499da36fcf4e270ee84bdf118047b2d2862dc665ac1221c5beb0e3fc2aa5","slug":"figure-5-2-1","location":"/5 B0 Mapping/2 Dual echo B0 mapping/Notebooks/Figure-5-2-1.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"date":"2024-10-08","open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true}},"github":"https://github.com/qmrlab/mooc","subject":"mOOC","venue":{"title":"qMRLab"},"numbering":{"heading_1":{"enabled":true},"heading_2":{"enabled":true},"heading_3":{"enabled":true},"heading_4":{"enabled":true},"heading_5":{"enabled":true},"heading_6":{"enabled":true},"title":{"offset":1}},"keywords":["quantitative MRI","education"],"copyright":"NeuroPoly 2024","abbreviations":{"MRI":"Magnetic resonance imaging","MR":"Magnetic resonance","NMR":"Nuclear Magnetic Resonance","qMRI":"quantitative magnetic resonance imaging","GPT":"Generative Pre-trained Transformer","MRM":"Magnetic Resonance in Medicine","B0":"Main magnetic field","B1":"Radiofrequency field","FID":"Free Induction Decay","Gx":"X-axis gradient","Gy":"Y-axis gradient","Gz":"Z-axis gradient","TR":"Repetition Time","TE":"Echo Time","TI":"Inversion Time","CSF":"Cerebrospinal fluid","T1":"Longitudinal magnetization relaxation time constant","_T_{sub}`1`":"Longitudinal magnetization relaxation time constant","T2":"Transverse magnetization relaxation time constant","SE":"Spin Echo","GRE":"Gradient Echo","SPGR":"Spoiled Gradient Echo (sequence)","UMAP":"Uniform manifold approximation and projection","ADC":"Analog to digital converter","RF":"Radiofrequency","FA":"Flip Angle","VFA":"Variable Flip Angle","DESPOT1":"Driven Equilibrium Single Pulse Observation of _T_{sub}`1`","SNR":"Signal-to-noise ratio","RD-NLS":"reduced-dimension non-linear least-squares","STD":"Standard deviation","MT":"Magnetization Transfer","MTR":"Magnetization Transfer Ratio","MS":"Multiple Sclerosis","qMT":"Quantitative Magnetization Transfer","MTsat":"Magnetization Transfer saturation","SAR":"Specific absorption rate","FWHM":"Full width at half maximum"},"edit_url":"https://github.com/qmrlab/mooc/blob/mb/requirements/5 B0 Mapping/2 Dual echo B0 mapping/Notebooks/Figure-5-2-1.ipynb","exports":[{"format":"ipynb","filename":"Figure-5-2-1.ipynb","url":"/Figure-5-2-1-8dc984c65a0ae70b2cc98a3af57292d8.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\nPI_UNICODE = \"\\U0001D70B\"\n\n# Parameters\nnum_frames = 200\nomega_0 = 1  # Larmor frequency\nomega_1 = 0.9  # Inhomogeneous spin\ntime_max = 5  # [s]\n\n# Initial phase of the spin\ninitial_phase = 0.5\n\n# Time array\ntime = np.linspace(0, time_max, num_frames)\n\n# Generate data for spins\nx = np.cos(omega_0 * (2*math.pi) * time + initial_phase)\ny = np.sin(omega_0 * (2*math.pi) * time + initial_phase)\nx1 = np.cos(omega_1 * (2*math.pi) * time + initial_phase)\ny1 = np.sin(omega_1 * (2*math.pi) * time + initial_phase)\n\n# Generate data for spins in rotating frame of reference\nx_rot = np.cos((omega_0-omega_0) * (2*math.pi) * time + initial_phase)\ny_rot = np.sin((omega_0-omega_0) * (2*math.pi) * time + initial_phase)\nx1_rot = np.cos((omega_1-omega_0) * (2*math.pi) * time + initial_phase)\ny1_rot = np.sin((omega_1-omega_0) * (2*math.pi) * time + initial_phase)\n\n# Calculate angles\nangles = (np.arctan2(y,x))\nangles1 = (np.arctan2(y1,x1))\nangles_rot = (np.arctan2(y_rot,x_rot))\nangles1_rot = (np.arctan2(y1_rot,x1_rot))\n\n# Create figure\nfig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Rotating Spin\", \"Signal Phase (rad)\"))\n\n# Add spin as an arrow\nfig.add_trace(go.Scatter(\n    x=[0, x[0]],\n    y=[0, y[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='blue', width=3),\n    name='Spin at f0'),\n    row=1, col=1)\nfig.add_trace(go.Scatter(\n    x=[0, x1[0]],\n    y=[0, y1[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='red', width=3),\n    name='Inhomogeneous Spin'),\n    row=1, col=1)\n\n# Add phase of the signal\nfig.add_trace(go.Scatter(\n    x=[time[0]],\n    y=[angles[0]],\n    mode='markers',\n    marker=dict(color='blue', size=5),\n    name='Phase'),\n    row=1, col=2\n)\nfig.add_trace(go.Scatter(\n    x=[time],\n    y=[angles1],\n    mode='markers',\n    marker=dict(color='red', size=5),\n    name='Inhomogeneous Phase'),\n    row=1, col=2\n)\n# Rotating frame\nfig.add_trace(go.Scatter(\n    x=[0, x_rot[0]],\n    y=[0, y_rot[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='blue', width=3),\n    name='Spin at f0', visible=False),\n    row=1, col=1)\nfig.add_trace(go.Scatter(\n    x=[0, x1_rot[0]],\n    y=[0, y1_rot[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='red', width=3),\n    name='Inhomogeneous Spin', visible=False),\n    row=1, col=1)\n\n# Add phase of the signal\nfig.add_trace(go.Scatter(\n    x=[time[0]],\n    y=[angles_rot[0]],\n    mode='markers',\n    marker=dict(color='blue', size=5),\n    name='Phase', visible=False),\n    row=1, col=2\n)\nfig.add_trace(go.Scatter(\n    x=[time],\n    y=[angles1_rot],\n    mode='markers',\n    marker=dict(color='red', size=5),\n    name='Inhomogeneous Phase', visible=False),\n    row=1, col=2\n)\n\nfig.update_xaxes(range=[-1.1, 1.1], row=1, col=1)\nfig.update_yaxes(range=[-1.1, 1.1], row=1, col=1)\nfig.update_xaxes(range=[np.min(time), np.max(time)], row=1, col=2)\nfig.update_yaxes(range=[np.min(angles) + 0.1*np.min(angles), np.max(angles) + 0.1*np.max(angles)], row=1, col=2)\n\n# Add frames\nframes = [dict(\n    data=[go.Scatter(x=[0, x[i]],\n                     y=[0, y[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#636EFA', width=3),\n                     name='Spin at f0'),\n          go.Scatter(x=[0, x1[i]],\n                     y=[0, y1[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#fa6363', width=3),\n                     name='Inhomogeneous Spin'),\n          go.Scatter(x=time[:i],\n                     y=angles[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='blue', width=3),\n                     name='Phase'),\n          go.Scatter(x=time[:i],\n                     y=angles1[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='red', width=3),\n                     name='Inhomogeneous Phase'),\n          go.Scatter(x=[0, x_rot[i]],\n                     y=[0, y_rot[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#636EFA', width=3),\n                     name='Spin at f0'),\n          go.Scatter(x=[0, x1_rot[i]],\n                     y=[0, y1_rot[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#fa6363', width=3),\n                     name='Inhomogeneous Spin'),\n          go.Scatter(x=time[:i],\n                     y=angles_rot[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='blue', width=3),\n                     name='Phase'),\n          go.Scatter(x=time[:i],\n                     y=angles1_rot[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='red', width=3),\n                     name='Inhomogeneous Phase')\n         \n         \n         ],\n    name=str(i),\n    traces=[0,1,2,3,4,5,6,7]) for i in range(num_frames)]\n\nfig.frames = frames\n\n# Determine the maximum absolute value of coordinates\nmax_coord = max(abs(x.max()), abs(y.max()))\n\nfig.update_xaxes(title_text=\"x\", row=1, col=1)\nfig.update_xaxes(title_text=\"time\", row=1, col=2)\nfig.update_yaxes(title_text=\"y\", row=1, col=1)\nfig.update_yaxes(title_text=\"rad\", tickmode = 'array',\n        tickvals = [-math.pi, 0, math.pi],\n        ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'], row=1, col=2)\n\n\n# Update layout\nfig.update_layout(\n    height=450,\n    width=750,\n    title=\"Spins rotating\",\n    xaxis=dict(autorange=False),\n    yaxis=dict(autorange=False),\n    updatemenus=\n    [dict(\n        type='buttons',\n        buttons=[dict(label='Play',\n                      method='animate',\n                      args=[None, dict(frame=dict(duration=50, redraw=False), fromcurrent=True, mode='immediate')]),\n                 dict(label='Pause',\n                      method='animate',\n                      args=[[None], dict(frame=dict(duration=0, redraw=False), mode='immediate')])\n                ],\n         ),\n     dict(\n        buttons=[dict(\n                    args=[{\"visible\": [True, True, True, True, False, False, False, False]}],\n                    label=\"Laboratory Frame\",\n                    method=\"update\"),\n                dict(\n                    args=[{\"visible\": [False, False, False, False, True, True, True, True]}],\n                    label=\"Rotating Frame\",\n                    method=\"update\"\n                )],\n            direction=\"down\",\n            pad={\"b\": 70},\n            showactive=True,\n            x=-0.13,\n            xanchor=\"left\",\n            y=-0.15,\n            yanchor=\"top\"\n     )\n    ]\n)\n\n# Show figure\nfig.show()","identifier":"b0fig6jn-code","enumerator":"1","html_id":"b0fig6jn-code","key":"lUqIbrdqrY"},{"type":"output","id":"NZOJyWVnOYrzjsCG_bBss","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"5af5a9c90c11ef4b95b3dc8b7937afd8","path":"/5af5a9c90c11ef4b95b3dc8b7937afd8.json"}}}],"identifier":"b0fig6jn-output","html_id":"b0fig6jn-output","key":"Tzi7YmJM6D"}],"identifier":"b0fig6jn","label":"b0Fig6jn","html_id":"b0fig6jn","key":"uJ7va4ITh8"}],"key":"cxH4Pzf0ld"},"references":{"cite":{"order":[],"data":{}}}}