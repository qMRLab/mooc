{"version":"1","records":[{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"This section starts by explaining the distinction between MRI and quantitative MRI (qMRI), which is of essence to the central premise of this mOOC.\n\nNext, it aims at delivering an intuitive understanding of how MRI works by using cartoons, simulations and example applications, all introduced in the context of overarching concepts from physics and everyday life.\n\nSee also\n\nFor a more theoretical introductory explanation, the reader is referred to \n\nNishimura, 1996.\n\nAfter covering the basics of MRI, the relationship between data acquisition and parameter estimation will be explained based on two basic qMRI applications: T1 and T2 mapping.\n\nFinally, we will look at three aspects of qMRI that need to be improved for clinical translation.","type":"content","url":"/introduction","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"type":"lvl2","url":"/introduction#why-mri-isnt-quantitative-yet","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"content":"","type":"content","url":"/introduction#why-mri-isnt-quantitative-yet","position":3},{"hierarchy":{"lvl1":"Introduction","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"type":"lvl3","url":"/introduction#pixels-have-values-then-why-is-mri-not-quantitative","position":4},{"hierarchy":{"lvl1":"Introduction","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"content":"","type":"content","url":"/introduction#pixels-have-values-then-why-is-mri-not-quantitative","position":5},{"hierarchy":{"lvl1":"Introduction","lvl4":"A sweet jellybean analogy","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"type":"lvl4","url":"/introduction#a-sweet-jellybean-analogy","position":6},{"hierarchy":{"lvl1":"Introduction","lvl4":"A sweet jellybean analogy","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"content":"üëÄ ü™ºü´ò\n\nWe will start answering this question by looking at the most prominent use cases of MRI from two distinctive fields: \n\ndiagnostic radiology and \n\nfood engineering.\n\nIn the clinics, MRI stands out as one of the most preferred imaging methods, because it can generate detailed images with superb soft tissue contrast, without using ionizing radiation or cutting open the human body. Surprisingly, MRI scanners have also been extensively used in food science to study soft tissue. For example, several studies used MRI to observe how moisture migrates towards the center of jellybeans over time \n\nTroutman et al., 2001\n\nZiegler et al., 2003\n\nBe it in diagnostic radiology, or in food science, it is the superior soft tissue contrast that makes MRI appealing. In routine diagnostic readings, the radiologists browse through MR images to capture abnormalities that may be resolved by conventional MRI contrasts, i.e. T1- or T2-weighted images. As a result, the detection of pathological patterns depends on a radiologists‚Äô visual assessment, which is then transferred to a written report ‚Äì a narration of observations ‚Äì such as:\n\nT2 hyperintense appearance in the left parieto-occipital lobe suggests hemorrhagic infarction \n\nFig. 1f.\n\nHere, the word hyperintense implies a relative comparison. \n\nFig. 1e illustrates that cropping the tumorous region away from the image removes the basis of comparison and makes the hyperintense appearance irrelevant. This is because the pixel brightness of conventional MR images is assigned using an arbitrary scale consisting of shades of gray. Due to the lack of a calibrated measurement scale, conventional MRI is considered to be qualitative.\n\n\n\nFigure¬†1:An illustrative comparison between the conventional and quantitative MRI (qMRI). The pixel brightness of conventional MR images is defined in an arbitrary grayscale (e,f). As a result, only a qualitative pattern recognition is possible when the suspected region (i.e., the tumor) is assessed against the background of the target anayomy (i.e., the brain). On the other hand, quantitative maps spatially resolve a meaningful metric (a,b) to detect changes over time (c) and between different samples (d). On a standardized measurement scale of percent moisture, the texture characteristics of a jellybean (e.g., crispy or chewy) can be objectively determined even from a randomly selected part of the image.\n\nUsing the same MRI scanner, it is possible to assign meaningful numbers to the images and this approach turns out to be the most common MRI method in food engineering \n\nMariette et al., 2012\n\nZiegler et al., 2003. \n\nFigure 1 illustrates the added value of quantitative MRI (qMRI) when applied to a sample familiar to everyone: a jellybean. The moisturization map indicates that the jellybean has formed a crispy shell while remaining chewy at the center, which is the desired texture \n\nFig. 1b. Given that the level of chewiness is determined by a threshold on a standardized measurement scale, a randomly selected part of the image can be still characterized by comparing selected pixel values against the established threshold \n\nFigure 1. This feature of qMRI offers an objective insight into how the texture of this soft confection changes over time, which would help determine its best before date (\n\nFigure 1, prognosis).\n\nThe ability to reveal what underpins the appearance of visually similar samples is yet another powerful feature of qMRI. In a \n\nBean-Boozled challenge, which is a Russian roulette of jellybean flavors, tasty flavors are mixed with nauseous look-alikes \n\nGambon, 2015. For example, a green jellybean may taste like lime (tasty) or lawn clippings (nauseous) in the Bean-Boozled game \n\nFigure 2. Therefore, no matter how experienced the player is, the chances of picking up a lime-flavored bean is as good as tossing a coin. Conventional MR images of a handful of green jellybeans do not offer a distinguishing feature, but only reveal their structure. As a result, the chances of making an unfortunate choice remain the same \n\nFigure 2.\n\n\n\nFigure¬†2:The comparison of conventional and quantitative MRI in a Bean-Boozled game, where the task is picking up and eating a green jellybean. Out of 6 green beans, half of them taste like lime (tasty) and the remaining are lawn clipping flavored (nauseous). Conventional MRI is not sensitive to either aroma, as a result the beans show similar contrasts. On the other hand, a quantitative mapping method sensitive to citric acid (C6H8O7) can help reveal lime-flavored beans.\n\nOn the other hand, spatially resolving a quantitative property that is sensitive to either flavor would step up our game in making the right decision. For example, a qMRI method capable of mapping the distribution of citric acid (C6H8O7) ‚Äì the chemical compound that gives citrus fruits a sour taste ‚Äì would help distinguish lime-flavored green beans. Even though the grass-flavored beans may contain a slight amount of C6H8O7 (used as lawn fertilizer), establishing a threshold can help make an informed decision (\n\nFigure 2), giving the players a competitive edge in the bean-boozled game (diagnosis).\nNote that the pixel brightness of the conventional (weighted) image has contributions from the C6H8O7 concentration. However, it is also affected by several other factors, such as water density and glucose content. Therefore, understanding the relationship between the pixel brightness and the flavour depends on the experience and subjective interpretation of the observer.\n\nüí∞üí∞üí∞ Money, money, money, must be funny, in MRI‚Äôs world\n\nAlthough the distinction between the values and pixel brightness has become clearer in the 50 years since the invention of MRI, their definitions were conflated at the time when nuclear magnetic resonance (NMR) was evolving into MRI. For General Electric (GE), one of the largest MRI manufacturers in the world, the cost of this blurry line between the numbers and pixel brightness was $129,000,000 (detailed below).\n\nNMR is a spectroscopy method that gives information about the chemical makeup of the analyzed substance. In analogy with the jellybean example, an NMR measurement is similar to quantifying the amount of C6H8O7 from the fragments of a green jellybean (\n\nFigure 2). If we used NMR for the bean-boozled challenge, we would be looking at a list of values to pick up a lime-flavoured bean instead of looking at a map.","type":"content","url":"/introduction#a-sweet-jellybean-analogy","position":7},{"hierarchy":{"lvl1":"Introduction","lvl4":"A spicy history of NMR and MRI","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"type":"lvl4","url":"/introduction#a-spicy-history-of-nmr-and-mri","position":8},{"hierarchy":{"lvl1":"Introduction","lvl4":"A spicy history of NMR and MRI","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"content":"üå∂Ô∏èüï∞Ô∏è\n\nBeginning in the late 1930s, researchers have been using NMR to characterize chemical compounds. The history of MRI begins with the idea of using NMR to tell a cancerous tissue sample from a healthy one.\n\nThe evolution of NMR into MRI is a turbulent story \n\nDreizen, 2004 that starts with the development of the first MRI scanner (1980) and leads to a Nobel Prize (2003). In 1971, Damadian published a study on the use of NMR-based T1 and T2 values for detecting malignant tumors \n\nDamadian, 1971. Based on this work, he issued a patent application titled ‚Äúan apparatus and method for detecting cancer in tissue‚Äù in 1972, which was accepted in 1974 \n\nDamadian, 1974.\n\nHowever, an actual image was out of the picture until Lauterbur was finally able to publish his work in 1973, showing a crude weighted-image of two liquid filled tubes \n\nLauterbur, 1989. Lauterbur‚Äôs publication was delayed because the initial submission was desk-rejected by the editors of Nature, and his university did not find his work valuable enough to submit a patent \n\nDawson, 2013. Around the same time but an ocean apart, Mansfield was applying NMR to image crystals by borrowing a concept dubbed k-space from 2D crystal structures \n\nTurner, 2017. This approach led Mansfield to develop a fast image generation method, bringing MRI closer to practical reality \n\nMansfield & Maudsley, 1977.\n\nWith undeniable insight from the studies of Lauterbur and Mansfield, Damadian‚Äôs team built the first human MRI scanner in 1978 and made it commercially available in two years. Around the same time, GE started manufacturing scanners without paying royalty to Damadian as consideration for the patent. In the decade that follows, GE sold nearly 600 scanners, for which Damadian‚Äôs company Fonar filed a patent infringement lawsuit in the late 1990s and awarded $128,705,766 as a compensation for pecuniary damages (Cir., 1996).","type":"content","url":"/introduction#a-spicy-history-of-nmr-and-mri","position":9},{"hierarchy":{"lvl1":"Introduction","lvl4":"A bitter U.S. Supreme Court verdict","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"type":"lvl4","url":"/introduction#a-bitter-u-s-supreme-court-verdict","position":10},{"hierarchy":{"lvl1":"Introduction","lvl4":"A bitter U.S. Supreme Court verdict","lvl3":"Pixels have values, then why is MRI not quantitative?","lvl2":"Why MRI Isn‚Äôt Quantitative (Yet)"},"content":"Returning to the jellybean analogy, Damadian‚Äôs patent was mainly describing a device to scan whole jellybeans for a complete C6H8O7 measurement. The key invention of the patent was to collect multiple measurements at different locations of the jellybean without fragmenting them. Later on, Lauterbur and Mansfield developed the methodology to create weighted images of the jellybeans. This was followed by Damadian marketing the first device that can generate weighted images of whole jellybeans (\n\nFigure 2) and the U.S. Supreme Court reached the verdict that GE infringed Damadian‚Äôs patent. The original judgement on the verdict reads:\n\nOn May 27, 1997 the Honorable Wm. H. Rehnquist, Chief Justice, the United States Supreme Court, enforced the Order of the Federal Circuit Court of Appeals and ordered GE to pay Fonar. GE paid Fonar $128,705,766 for patent infringement. GE was further restrained from any use of Fonar technology.‚Äù\n‚ÄúThe Court found that GE had infringed U.S. Patent 3,789,832, MRI‚Äôs first patent, which was filed with the U.S. Patent Office in 1972 by Dr. Damadian. The Court concluded that MRI machines rely on the tissue NMR relaxations that were claimed in the patent as a method for detecting cancer, and that MRI machines use these tissue relaxations to control pixel brightness and supply the image contrasts that detect cancer in patients.\n\nTo paraphrase the reasoning behind this decision using the jellybean analogy:\n\nGE manufactured and sold 600 scanners capable of generating weighted images of the jellybeans,\n\nthe weighted images are influenced by the C6H8O7 concentration,\n\nlime-flavored jellybeans have higher concentrations of C6H8O7,\n\nthus, GE scanners are designed to identify lime-flavored jellybeans, which infringes on Damadian‚Äôs patent.\n\nAlthough the U.S. Supreme Court decision implied that Damadian owns the intellectual property rights for MRI scanners at that time, the 2003 Nobel Prize in Medicine was shared between Lauterbur and Mansfied only. Damadian spent nearly $300,000 for full page ads in popular print media outlets to claim his rights to the 2003 prize, yet the situation has remained unchanged up to this date. The notes on why Damadian was not included in the prize will be available in 2053 \n\nHarris, 2003.\n\nThe court‚Äôs interpretation of the difference between the Fonar‚Äôs patent and GE MRI scanners perfectly captures the essence of qMRI, which is to enable objective and consistent comparisons by tagging each pixel with a precisely defined score that ranks a physical characteristic. Although the physical property estimated by qMRI contributes to the pixel brightness of conventional images, the conventional images are presented in an arbitrary grayscale. This is the reason why individual pixels of a weighted image have numbers, but no (physical) value.\n\nTo conclude, there is a critical difference between detecting abnormalities based on pixel brightness (conventional MRI) and tissue characterization using quantitative metrics (qMRI), and the court‚Äôs interpretation of this difference cost GE $129 million. With this central distinction in mind, the following sections will introduce how we can use the same MRI scanner for both qualitative and quantitative imaging.\n\nü™¶ RIP Damadian\n\nDr. Raymond Damadian passed away on August 3, 2022, at the age of 86 from cardiac arrest. It is uncertain whether his passing will affect the scheduled release date (2053) of the notes explaining why he was not included in the Nobel Prize. Despite this controversy, most articles about his death referred to him as ‚Äúthe father of MRI‚Äù (\n\nread more).","type":"content","url":"/introduction#a-bitter-u-s-supreme-court-verdict","position":11},{"hierarchy":{"lvl1":"Introduction","lvl2":"Origins of MRI - A Visual History"},"type":"lvl2","url":"/introduction#origins-of-mri-a-visual-history","position":12},{"hierarchy":{"lvl1":"Introduction","lvl2":"Origins of MRI - A Visual History"},"content":"","type":"content","url":"/introduction#origins-of-mri-a-visual-history","position":13},{"hierarchy":{"lvl1":"Introduction","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"type":"lvl3","url":"/introduction#a-pictorial-and-historic-journey-into-how-mri-works","position":14},{"hierarchy":{"lvl1":"Introduction","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"content":"The human body can be seen as a complex compartmentalization of water, fat, protein and minerals at every level of its organization from atoms to organs (Siri, 1956). At the atomic scale, nearly 63% of the atoms in the human body are hydrogen atoms (Osmera and Vanicek, 1940), which consists of only one proton and one electron. It is this simplicity that makes hydrogen the most studied atomic structure in quantum mechanics, which eventually lead to the development of MRI.\n\nOnce the mass and charge of the hydrogen particles were known, nobody suspected that there was another hydrogen property to be discovered. The study of hydrogen was revolutionized when two scientists in their mid 20s, Uhlenbeck and Goudsmit, wrote together the first article about the nuclear spin in 1925 (Uhlenbeck and Goudsmit, 1925). They were afraid to submit their work, because the celebrity physicist Lorentz deemed their idea ‚Äúunphysical‚Äù. At that time, Uhlenbeck and Goudsmit were working under the supervision of Zeeman and Ehrenfest, yet Zeeman and Ehrenfest omitted their names from the article, deciding to use the youth of their protegees as a shield against any backlash (Halpern, 2017). What was feared to be a foolish mistake was then accepted as a built-in feature of any fundamental particle in the universe, just like the mass and charge. This quantum property ‚Äì spin ‚Äì is the key to understanding how MRI works.","type":"content","url":"/introduction#a-pictorial-and-historic-journey-into-how-mri-works","position":15},{"hierarchy":{"lvl1":"Introduction","lvl4":"Getting on the same wavelength with a single hydrogen in the quantum realm","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"type":"lvl4","url":"/introduction#getting-on-the-same-wavelength-with-a-single-hydrogen-in-the-quantum-realm","position":16},{"hierarchy":{"lvl1":"Introduction","lvl4":"Getting on the same wavelength with a single hydrogen in the quantum realm","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"content":"28 years before his student would give an underlying explanation, Zeeman showed that the energy levels in an atom change under the influence of a magnetic field, an effect known as Zeeman‚Äôs splitting (Zeeman, 1897). This is particularly important for hydrogen, because unlike a magnetic field, an electric field does not lead to an energy difference between its spin configurations (i.e., does not split) (Feynman et al., 2015). Hydrogen is assumed to have four (ground) spin states, created by the combinations of two up and two down spins from its proton and electron. Each combination constitutes a different energy level. The difference between these energy levels is so small that their separation is defined by the term ‚Äúhyperfine splitting‚Äù. What encourages the hydrogen to exhibit more than one energy level is the presence of a uniform magnetic field (B0). This effect opens a communication line to interact with hydrogen, yet it takes some special effort to start a conversation.\n\nüî•üêù Swiping right frequency\n\n‚ù§Ô∏è To explain these requirements, we will use an online dating metaphor. Is not that lovely?","type":"content","url":"/introduction#getting-on-the-same-wavelength-with-a-single-hydrogen-in-the-quantum-realm","position":17},{"hierarchy":{"lvl1":"Introduction","lvl5":"Picking up a hydrogen atom in the quantum realm: The perfect match","lvl4":"Getting on the same wavelength with a single hydrogen in the quantum realm","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"type":"lvl5","url":"/introduction#picking-up-a-hydrogen-atom-in-the-quantum-realm-the-perfect-match","position":18},{"hierarchy":{"lvl1":"Introduction","lvl5":"Picking up a hydrogen atom in the quantum realm: The perfect match","lvl4":"Getting on the same wavelength with a single hydrogen in the quantum realm","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"content":"The hydrogen atom comes online only when standing up under the influence of a magnetic field (\n\nFigure 3a,b). The chances of getting a response from the hydrogen firstly depends on whether our message kindles just the right amount of excitement for it to switch between those hyper-finely separated energy levels (\n\nFigure 3). Although it almost seems like the hydrogen is sidestepping a conversation, all it takes is finding the right wavelength to meet this first requirement. Six years after the introduction of the spin concept, Rabi and Breit finally discovered that to resonate with hydrogen‚Äôs energy levels, we need to send our messages in the radiofrequency (RF) range of the electromagnetic spectrum (Breit and Rabi, 1931).\n\nHowever, not all hydrogen atoms behave the same. We need to be familiar with the peculiarities of the hydrogen we are in touch with. There are two key attributes: where is the hydrogen from, and in which energy state it is when our resonating message is delivered (\n\nFigure 3c). The last nuance to get on the same wavelength is finding the right angle to approach it. If we meet all the requirements, we will see the hydrogen getting excited and responding to us within a certain RF bandwidth.\n\nFor the imaging of the human body using MRI, we will be mostly communicating with the hydrogen from the water (\n\nFigure 4). In general, water hydrogens are more easy-going because their electron spin states are balanced, so we are only concerned with the energy levels emerging from their nuclei. This is why we call this pick-up line the nuclear magnetic resonance (NMR).\n\n\n\nFigure¬†3:a) A hydrogen atom has one proton and one electron, with each particle is assumed to have two possible spin states for simplicity (up or down). In the absence of a magnetic field, the atom is at a random orientation (offline) and shows a single energy level (the red line). b) Under a uniform magnetic field (B0), the atom is aligned with the field (online) and shows multiple energy levels (the colored lines). These energy levels are in quantum superposition: all the levels simultaneously exist and we can only determine one state upon observation. This behaviour of the energy levels is represented by the Schr√∂dinger‚Äôs cat2. c) Once it is online, the hydrogen atom can be contacted through a communication line that operates within the radiofrequency (RF) range.\n\nFigure 4 shows that the hydrogen from water has two energy levels under a uniform magnetic field: low energy and high energy. If the resonating message flips the hydrogen‚Äôs energy state from higher (red) to lower (cyan) state, the result is a ‚Äúradio silence‚Äù (\n\nFigure 4a), i.e. the hydrogen gives up a small amount of excess energy instead of a response. But if the resonating message elevates the hydrogen‚Äôs mood from lower (red) to the higher (cyan) state, the hydrogen gets excited (\n\nFigure 4b). After the message is delivered, we will finally get a response as the excitement quickly fades away. This final process is termed ‚Äúrelaxation‚Äù, which is of essence to the MRI contrast, because the message carries information about where that hydrogen is from.\n\n\n\nFigure¬†4:a) After receiving the call, the hydrogen atom from water switches from the higher (red) to the lower (cyan) energy level and refuses to answer. b) When the RF input switches its energy from the lower (red) to the higher level (cyan), the atom gets excited. While returning to its initial state, the atom responds.\n\nThe tone in the response shifts slightly if the hydrogen is from non-water molecules, e.g., fat or protein. This slight difference is caused by the amount of negative energy a hydrogen is surrounded by, which interferes with the contribution of hydrogen‚Äôs electron to its energy state, namely shielding. The more negative energy around the hydrogen, the shorter the response. It appears that the positive effects of being near water on the energy levels tran- scends scales, from humans themselves (Cracknell et al., 2016) to the hydrogen atoms that make up them (Lawrence and McDonald, 1966).\n\nSo far we looked at the quantum-level interactions between the hydrogen atom and RF energy, and tied it with the NMR phenomenon. However, in reality, we don‚Äôt have access to observed NMR effects at such a fine-grained level; because no appropriate instrumentation exists, and \n\nquantum-jitters make such instrumentation nearly impossible (Erkintalo, 2021). For example, we cannot detect the uncertainty of a single hydrogen atom‚Äôs energy levels. The best we can do is to visualize the concept using metaphorical illustrations, such as using \n\nSchr√∂dinger‚Äôs cat to imply the quantum state of the hydrogen‚Äôs energy levels in \n\nFigure 3b. Until we observe the consequences (whether the hydrogen will respond to our resonant message or not), all the energy levels are assumed to be in quantum superposition, even for only two energy states of proton spins as shown in \n\nFigure 4. To achieve observational accuracy, we need to move from the uncertainties of the energy levels to a probability of getting a response to our resonant message, which is what we will look at in the following section.","type":"content","url":"/introduction#picking-up-a-hydrogen-atom-in-the-quantum-realm-the-perfect-match","position":19},{"hierarchy":{"lvl1":"Introduction","lvl5":"Finding the perfect quantum match is not practical, but there are plenty of fish in the sea","lvl4":"Getting on the same wavelength with a single hydrogen in the quantum realm","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"type":"lvl5","url":"/introduction#finding-the-perfect-quantum-match-is-not-practical-but-there-are-plenty-of-fish-in-the-sea","position":20},{"hierarchy":{"lvl1":"Introduction","lvl5":"Finding the perfect quantum match is not practical, but there are plenty of fish in the sea","lvl4":"Getting on the same wavelength with a single hydrogen in the quantum realm","lvl3":"A pictorial and historic journey into how MRI works","lvl2":"Origins of MRI - A Visual History"},"content":"We can harness the benefits of NMR without having a complete theoretical understanding of the underlying quantum interactions (see proton spin crisis (Siegel, 2017)), because these effects simply smooth over at the macroscale. At this point we will leave the online dating analogy behind, because even at the smallest macroscopic scale, ‚Äúthere are plenty of fish in the sea‚Äù (\n\nFigure 4a). At the level where an NMR measurement is technically feasible, we will be concerned with a large pool of hydrogen atoms. Here, the individual behaviour of particles becomes useless for characterizing the system in aggregate. This concept of integrating over microscopic details to achieve a compact and useful system description is coarse-graining (\n\nFigure 5).\n\n\n\nFigure¬†5:At the macro-scale, the quantum mechanical behaviour of individual hydrogen atoms is averaged over, i.e., coarse-grained. \n\nFigure 2 illustrates a fine-grained description of the behaviour of a single hydrogen atom in absence and presence of a magnetic field. After coarse graining, the representation simplifies to an arrow passing through the center of the proton, which is aligned parallel (i.e., spin-up, low energy) or antiparallel (i.e., spin-down, high energy) with the magnetic field (blue), or at random if the field is absent (pink). Follow- ing coarse-graining, the terms spin, proton, nuclei or hydrogen can be used interchangeably.\n\nFigure 5 shows how the representation of a hydrogen atom is changed after coarse-graining microscopic details of spin interactions. From this point onward in this document, hydrogen will be illustrated as shown in \n\nFigure 5, and used interchangeably with the terms spin, proton and nuclei. To refer to the energy level associated with a single hydrogen atom, we will describe the magnetic moment (\n\nFigure 6a): If the proton was merely a rigid body, its rotation about an imaginary axis that passes through its center would create a small angular momentum aligned with that axis. Given that the proton is a charged particle, it also creates a microscopic magnetic moment (Œº) as a result of this rotation, which is a vector in the same direction (\n\nFigure 6a). The ratio between the angular momentum and the magnetic moment yields the gyromagnetic ratio (Œ≥), which is 42.59 MHz for the hydrogen at 1 Tesla (T) magnetic field. This frequency at which the spins rotate is commensurate with the magnetic field strength. The product of the gyromagnetic ratio and the field strength (Œ≥B0) yields the Larmor frequency, at which the RF energy must be delivered to achieve nuclear resonance.\n\n\n\nFigure¬†6:a) There are millions of protons (i.e., spin or nuclei) even at the smallest macro- scopic unit volume relevant to the MR imaging of the human body. Each individual proton exhibits an infinitesimally small magnetic moment (Œº). b) Without B0, the protons in a spin pool exhibit random alignment. c) In presence of B0, the spins are aligned with the magnetic field (parallel or antiparallel), giving rise to a net magnetization (M).\n\nAt the macroscale, we will be concerned with millions of protons at once (\n\nFigure 6a), even for a unit volume of 1mm3. Absent an external magnetic field, magnetic moment vectors are oriented at random (\n\nFigure 6b). When a magnetic field is applied, they are aligned either parallel (spin-up, low energy) or antiparallel (spin-down, high energy) with the applied field (\n\nFigure 6c). Given the vast abundance of these spins, the relevant question becomes: which spin configuration is dominant? According to the second law of thermodynamics, if the spin system is at thermal equilibrium, i.e., no energy enters or leaves the system, the entropy of that spin system increases (Carnot et al., 1899). This omnipresent tendency toward disorder favors low energy (Ferris, 2019). Therefore, the spin system tends to have slightly more low-energy hydrogen atoms (spin-up, parallel). Although the difference is as small as 40 per million protons (Webb, 2016), a net magnetic magnetization (\n\nFigure 6c) can be observed by a real-world NMR experiment.\n\n\n\nFigure¬†7:The measurement instrumentation is concerned with the relevant degrees of free- dom and an effective theory that explains how these coarse-grained variables respond to the perturbations of the measurement system. Some fundamental components of an MRI mea- surement include a uniform magnetic field generator (i.e., a magnet), an RF transmitter (Tx, yellow), an RF receiver (Rx, purple) and an analog-to-digital converter (ADC).\n\nTo perform a real-world measurement, an effective theory is needed to describe how the coarse-grained features of the targeted system (\n\nFigure 6) changes upon interaction with the measurement instrumentation (\n\nFigure 7). The effective theory of relaxation for the bulk magnetization M was described by Felix Bloch in 1957, laying one of the cornerstones to bring MRI to reality (Bloch, 1957). A basic instrumentation to study the relaxation of a spin system is depicted in \n\nFigure 6c, including a uniform magnetic field (B0) generator, an RF transmission system tuned to the Larmor frequency and an RF receiver coil followed by an analog-to-digital converter (ADC). The following section describes how Bloch equations explain the macroscopic behaviour of the net magnetization and how MRI scanners make use of this effective theory to create images.","type":"content","url":"/introduction#finding-the-perfect-quantum-match-is-not-practical-but-there-are-plenty-of-fish-in-the-sea","position":21},{"hierarchy":{"lvl1":"Introduction","lvl2":"From spin dynamics to images"},"type":"lvl2","url":"/introduction#from-spin-dynamics-to-images","position":22},{"hierarchy":{"lvl1":"Introduction","lvl2":"From spin dynamics to images"},"content":"","type":"content","url":"/introduction#from-spin-dynamics-to-images","position":23},{"hierarchy":{"lvl1":"Introduction","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"type":"lvl3","url":"/introduction#measuring-and-encoding-the-mri-signal","position":24},{"hierarchy":{"lvl1":"Introduction","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"content":"","type":"content","url":"/introduction#measuring-and-encoding-the-mri-signal","position":25},{"hierarchy":{"lvl1":"Introduction","lvl4":"Mathematical Description of Spin System Evolution","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"type":"lvl4","url":"/introduction#mathematical-description-of-spin-system-evolution","position":26},{"hierarchy":{"lvl1":"Introduction","lvl4":"Mathematical Description of Spin System Evolution","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"content":"Following an excitation of the spin system by an RF energy at the Larmor frequency (Œ≥B0), the macroscopic Bloch equation describes how net magnetization evolves over time in a fixed cartesian reference (xi, yj, zk), under B0 is given by:\\frac{\\mathrm{d}M }{\\mathrm{d} t}=\\gamma{M\\times B_{0}}-\\frac{M_{x}\\hat{\\textbf{i}} + M_{y}\\hat{\\textbf{j}}}{T2} -\\frac{(M_{z} - M_{0})\\hat{\\textnormal{\\textbf{k}}}}{T1}\n\nwhere M0 is the initial magnetization of the spin system and T1 and T2 are the time constants for the longitudinal and relaxational components of relaxation. The first term of the \n\nEq. 1 is precessional, and the last two terms are the relaxational components of the Bloch equation. Recall that in thermal equilibrium, the net magnetization is aligned with the applied magnetic field (\n\nFigure 6c), where the longitudinal component is the net magnetization (M = Mz = M0) and the transverse component equals zero (Mx = My = 0). In this case, the last two terms of the equation vanish, leaving the precessional component of the equation. When the phenomenological \n\nEq. 1 is solved for the longitudinal (Mz) and the transverse (Mxy) components of the macroscopic magnetization, the explicit solutions are given by:M_{z}(t) = M_{z}(0)e^{\\frac{-t}{T1}} + M_0(1-e^{\\frac{-t}{T1}})M_{xy}(t) = M_{xy}(0)e^{\\frac{-t}{T2}}\n\nNote that \n\nEq. 2 describes an exponential recovery for Mz to return the equilibrium after excitation. On the other hand, \n\nEq. 3 states that the transverse magnetization follows an exponential decay, quickly converging to zero.","type":"content","url":"/introduction#mathematical-description-of-spin-system-evolution","position":27},{"hierarchy":{"lvl1":"Introduction","lvl4":"Analogical explanation using a defibrillator","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"type":"lvl4","url":"/introduction#analogical-explanation-using-a-defibrillator","position":28},{"hierarchy":{"lvl1":"Introduction","lvl4":"Analogical explanation using a defibrillator","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"content":"The relationship between the longitudinal and transverse components of magnetization in an NMR experiment can be understood through the analogy of how a defibrillator‚Äôs capacitor charges and discharges. As soon as the paramedic hits the shock ‚ö°Ô∏è button, the capacitor abruptly empties to deliver an immediate and strong jolt to the patient (\n\nFigure 8). At this moment, the paramedic‚Äôs focus is on how the energy dissipates across the patient‚Äôs body, which lies in the transverse plane (Mxy). The time it takes from the start of the shock until 37% of the energy remains (1/e = 0.37) corresponds to the T2 time constant of Mxy. This process is very brief, similar to the sound of a click.\n\nAfter delivering the shock, the capacitor must recharge to the desired level to be ready for the next shock (\n\nFigure 8b). The time required for the capacitor to reach 63% of its total charge capacity (1-1/e) corresponds to T1 time constant of the Mz. This recharging process is slower and is often accompanied by a rising whine or whirring sound, indicating the gradual buildup of energy.\n\n\n\nFigure¬†8:Time-dependent behavior of the transverse and longitudinal magnetization can be compared with how the capacitor of a defibrillator empties and recharges. a) When the paramedic activates the shock paddles, the capacitor quickly discharges its energy to the transverse plane (patient‚Äôs body). b) To deliver the shock again, the capacitor must be recharged, which happens quickly, yet relatively much slower than it discharges.\n\nüöΩ What happened to the good old toilet analogy?\n\nThe toilet analogy \n\nTamir et al. (2020) is a popular way to visualize signal relaxation by relating it to the familiar process of flushing a toilet. One could argue that the toilet analogy is pedagogically superior to the defibrillator analogy on the grounds of familiarity and utilization frequency ‚Äî after all, we all use toilets more often than defibrillators!\n\nEven though there is no easy way to connect a toilet bowl to the measurement instrumentation of MRI scanners, (and frankly, who would want to?), we can make it work with the defibrillator analogy!\n\nWith that said, I wish all our readers to be unfamiliar with the practical application of defibrillator throughout their lifespan.","type":"content","url":"/introduction#analogical-explanation-using-a-defibrillator","position":29},{"hierarchy":{"lvl1":"Introduction","lvl4":"Extending the defibrillator analogy to measurement instrumentation","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"type":"lvl4","url":"/introduction#extending-the-defibrillator-analogy-to-measurement-instrumentation","position":30},{"hierarchy":{"lvl1":"Introduction","lvl4":"Extending the defibrillator analogy to measurement instrumentation","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"content":"The use of the defibrillator by a paramedic highlights the distinct nature of T1 and T2 relaxation times in the context of energy dissipation and recovery in a repetitive process. However, it lacks the measurement aspect of an NMR experiment.\n\nTo complete the analogy, we will design a calibration setup to measure the energy delivered to the patient‚Äôs torso. To measure this indirectly, a loop will be placed under the stretcher and the current induced in the loop as a result of the delivered shock to the patient‚Äôs body will be recorded (\n\nFigure 9). The signal observed at the end of each shock corresponds to the free induction decay (FID) in an NMR experiment.\n\n\n\nFigure¬†9:A hypothetical calibration setup: To have a measure of the energy delivered to the patient, a conductive loop is placed under the stretcher. After the shock is delivered, the current induced in the loop is captured by a oscilloscope.\n\nI have no issues with induction being free, but why does it decay?\n\nRemember that in a spin system, a hydrogen atom precesses at its Larmor frequency (Œ≥B0). Following an excitation pulse, Mxy can be observed, because the on-resonance RF energy nudges all the spins toward rotating synchronously (i.e., in-phase). As they fall out of phase (i.e., dephased), the measured signal fades out.\n\nIf the biochemical composition of the excited volume varies spatially, the measured FID will be a summation of slightly varying frequency components. For example, a hydrogen atom from the water has a longer response than a hydrogen from the fat (T2fat<T2water). When the frequency components of the FID are observed by applying a Fourier transform, the respective peaks will be separated by a certain extent in the NMR spectrum, depending on the field strength (\n\nFigure 10).\n\n\n\nFigure¬†10:The free induction decay (FID) signal (left), and its frequency spectrum (right). As the electron of the hydrogen atom is more shielded in fat, its peak appears on the lower end (right, by convention) of the chemical shift spectrum. The chemical shift of water and fat is separated by 3.5 part-per-million (ppm), which corresponds to 146 Hz frequency difference at 1T (3.5^{‚àí6}Œ≥).\n\nWith the ability to precisely reveal molecular signatures, NMR is one of the most popular methods of chemical spectrum analysis, which is still in active use for a broad range of applications. A familiar example would be the benchtop NMR spectrometers at the airports that are used for tracing explosives and narcotics. However, spectral analyses take place in one dimension, in which the application of magnetic resonance was restricted for 25 years.","type":"content","url":"/introduction#extending-the-defibrillator-analogy-to-measurement-instrumentation","position":31},{"hierarchy":{"lvl1":"Introduction","lvl4":"From the peaks of frequencies to a bright spot in an image: Spatial localization","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"type":"lvl4","url":"/introduction#from-the-peaks-of-frequencies-to-a-bright-spot-in-an-image-spatial-localization","position":32},{"hierarchy":{"lvl1":"Introduction","lvl4":"From the peaks of frequencies to a bright spot in an image: Spatial localization","lvl3":"Measuring and encoding the MRI signal","lvl2":"From spin dynamics to images"},"content":"About brightness\n\nAs you have guessed, the word ‚Äúbright spot‚Äù in this section title corresponds to a voxel. As we introduced \n\npreviously, the brightness of a voxel alone does not convey any information unless it is part of a cluster of many other voxels.\n\nAlso note that the brightness of a voxel depends on the contrast weighting of a qualitative image. The exact same CSF voxel will shine bright like a \n\ndiamond in a T2w, but will be \n\ndancing in the dark in a T1w image. Yes, Rihanna helped us a lot bringing quantitative MRI under one \n\numbrella.\n\nRemember, qMRI aims to replace this ‚Äúbrightness‚Äù with a meaningful ‚Äúmeasurement‚Äù so that even a single pixel‚Äôs value would convey information about a physical property.\n\nA magnetic field gradient refers to a gradual change in B0 in any desired direction. This is achieved by flowing high-amplitude electric currents through coils installed in three orthogonal directions. For example, Z gradients (head-foot direction) are a pair of circular Helmholtz coils (green rings in \n\nFigure 11) that can generate a gradually increasing or decreasing magnetic field by running currents in opposite directions. The higher the current, the steeper the magnetic field difference between the opposite ends of the scanner‚Äôs bore. The magnitude of this gradient field can be adjusted such that the spins precess at the Larmor frequency of B0 only at a certain region (selected volume). This way, only the spins from the selected volume will absorb the RF energy deposited at the resonance frequency. To achieve this ‚Äúspatial localization‚Äù, the RF transmitter is turned on concurrently with the gradient coils, sustained briefly (typically in a micro- to milliseconds scale), then turned off. Operating hardware components in this fashion is termed playing (RF or gradient) pulses. Timing of such events is described by pulse sequence diagrams.\n\n\n\nFigure¬†11:Hardware components of a modern MRI scanner using a superconductive magnet. Z-axis gradients (green rings) spatially vary the magnetic field, such that only the spins at a limited region (light green area in the patient‚Äôs head) precess at the Larmor frequency (Œ≥B0).\n\nFigure 12 shows the sequence diagram describing the spatial localization illustrated in \n\nFigure 11.\n\n\n\nFigure¬†12:A pulse sequence diagram (left) showing an RF pulse to excite the spins only in a plane selected along the z-axis (Gz) and the respective slice profile (right).\n\nHowever, the slice selection procedure does not encode the measured signal with positional information. If an ADC event (i.e. signal measurement) was followed soon after the RF pulse was turned off, the receiver coil (Rx, purple, \n\nFigure 11) would collect information from the whole excited region at once. To form an image, the received signal must be encoded in-plane, which is along the x (row) and y (column) axes (axial plane) for the selected region.\n\nFigure 13b explains how spatial encoding in the row direction is performed by playing a gradient along the x-axis (Gx, teal) while the signal is being measured (ADC, purple). As a result of this, spin locations across a single row (the red box outlined in \n\nFigure 13c) are uniquely sorted out as a function of their frequency, namely the frequency encoding. The process of acquiring data using frequency encoding is termed a readout (purple box) and the acquired data is referred to as an observation (\n\nFigure 13d). During a readout, the receiver coil picks up a sinusoidal electromagnetic signal as an observation (purple sinusoid in \n\nFigure 13d), composed of the frequency components encoded per voxel (blue sine waves in \n\nFigure 13d). Therefore, the ADC must ensure that the observation is sampled at a high enough rate to resolve all 10 frequency components. In this example, the observation must be sampled at least at 20 locations to satisfy the Nyquist condition (purple squares in \n\nFigure 13d). The ADC hardware of modern MRI scanners is fast enough to achieve high sampling rates up to 500kHz (Graessner, 2013) and smart enough to perform an \n\nIQ sampling, separating the magnitude and phase components of each data point (Kirkhorn, 1999). This offers the convenience to place an observation to its location in a special data plane: the k-space (\n\nFigure 13e).\n\n\n\nFigure¬†13:The correspondance between the scanner coordinates (a) and the selected imaging plane (c) is illustrated along with the pulse sequence diagram for frequency-encoding (b). The observation obtained by the readout (d) is shown in the k-space (e).\n\nBy convention, the location in the horizontal axis of the k-space is determined by the spatial frequency and the value of each cell is proportional with the magnitude of the respective signal component. The k-space is arranged such that the higher frequency components are located around the skirts, whereas the lower frequency components are closer to the center. In a sense, placing an observation in its k-space location corresponds to adding in the contribution of that acquired portion to the whole image, but in the frequency domain. Hence, there is not a pointwise correspondence between the k-space and the MR image it represents. Instead, every single cell in the k-space (each hexagon in \n\nFigure 13e) carries information about the whole image. The concept of k-space involves several layers of abstraction that are beyond the scope of this introduction; therefore, the reader is referred to (Mezrich, 1995) for an intuitive understanding of k-space. For the next step of our MR image generation example, we will be concerned with how to fill out multiple rows of the k-space (along the red axis).\n\nRecall that an excitation RF pulse nudges all the spins toward rotating synchronously, so that Mxy across all the pixels share the same phase. Whenever a gradient is played, an opposite effect comes into play: phase of the spins along the gradient direction experiences a location-dependent shift. Each phase shift moves the location of the observation in k-space along the ky axis (\n\nFigure 14c), upwards or downwards depending on the polarity of the applied gradient. The amount of dephasing (i.e., the number of ‚àÜky steps) is proportional with the gradient area, and its effect can be rewinded to restore the transverse magnetization by playing a gradient of the same area with opposite polarity. \n\nFigure 14b shows a phase-encoding gradient (red) played with negative polarity before the readout in order to shift the observation to the next lower row in the kspace (\n\nFigure 14e). To rewind this dephasing effect, the readout is followed by another Gy gradient with positive polarity.\n\n\n\nFigure¬†14:The correspondence between the scanner coordinates (a) and the selected imaging plane (c) is illustrated along with the pulse sequence diagram for phase encoding (b). Once the whole k-space is sampled by incrementing the phase-encoding gradient (red) (b) multiple times, a 2D inverse Fourier transform is applied to reconstruct the MR image (f).\n\nBy altering the gradient amplitude stepwise, the whole k-space can be sampled (\n\nFigure 14f). Therefore, the time that it takes to scan the plane shown in \n\nFigure 14c is a product of the number of rows and the duration of each repetition, namely the repetition time (TR). Finally, the MR image is reconstructed by applying a 2D inverse Fourier transform to the fully sampled k-space, where each sample corresponds to a grid location.\n\nFor the sake of simplicity, the examples in \n\nFigure 13 and \n\nFigure 14 assumed that the signal observations followed by an excitation pulse can be used to form an image. However in practice, an FID signal is short-lived; therefore, it cannot directly contribute to reconstructing an MR image. This brings us to two milestone discoveries in NMR by Erwin Hahn, which echoed into the beginning of MRI from a quarter-century behind and have become an indispensable part of its everyday use since then: spin- and gradient-echo. For further reading on the history of these methods, the reader is referred to an MRM Highlights interview with Erwin Hahn (Feinberg, 2018).","type":"content","url":"/introduction#from-the-peaks-of-frequencies-to-a-bright-spot-in-an-image-spatial-localization","position":33},{"hierarchy":{"lvl1":"Introduction","lvl2":"Two MRI sequences and two qMRI measurements"},"type":"lvl2","url":"/introduction#two-mri-sequences-and-two-qmri-measurements","position":34},{"hierarchy":{"lvl1":"Introduction","lvl2":"Two MRI sequences and two qMRI measurements"},"content":"","type":"content","url":"/introduction#two-mri-sequences-and-two-qmri-measurements","position":35},{"hierarchy":{"lvl1":"Introduction","lvl3":"Coming full circle back to two measurements with two pulse sequences","lvl2":"Two MRI sequences and two qMRI measurements"},"type":"lvl3","url":"/introduction#coming-full-circle-back-to-two-measurements-with-two-pulse-sequences","position":36},{"hierarchy":{"lvl1":"Introduction","lvl3":"Coming full circle back to two measurements with two pulse sequences","lvl2":"Two MRI sequences and two qMRI measurements"},"content":"‚ÄúThe Court concluded that MRI machines rely on the tissue NMR relaxations that were claimed in the patent as a method for detecting cancer, and that MRI machines use these [T1 and T2 values] to control pixel brightness...‚Äù (GE vs Fonar 1996, U.S. Fed. Cir.)\n\nAlthough going from values to brightness and back again is a üêì&ü•ö problem, GE could have stood a better chance by defending that the pixel brightness can be used to obtain T1 and T2 values, but T1 and T2 values cannot be directly utilized to obtain pixel brightness by MRI machines. Indeed, T1-weighted and T2-weighted contrasts are primarily determined based on the contribution of T1 and T2 (or neither). Nevertheless, to adjust those contributions, MRI machines use pulse sequences and parameters. This section will introduce two essential sequences, spin-echo and gradient-echo to show how contrasts are determined (conventional MRI) and the values are calculated (qMRI).","type":"content","url":"/introduction#coming-full-circle-back-to-two-measurements-with-two-pulse-sequences","position":37},{"hierarchy":{"lvl1":"Introduction","lvl5":"Spin Echo and T2 mapping","lvl3":"Coming full circle back to two measurements with two pulse sequences","lvl2":"Two MRI sequences and two qMRI measurements"},"type":"lvl5","url":"/introduction#spin-echo-and-t2-mapping","position":38},{"hierarchy":{"lvl1":"Introduction","lvl5":"Spin Echo and T2 mapping","lvl3":"Coming full circle back to two measurements with two pulse sequences","lvl2":"Two MRI sequences and two qMRI measurements"},"content":"In their seminal article titled ‚Äúatomic memory‚Äù, Brewer and Hahn introduce the spin-echo (Hahn, 1949) by tapping into an intellectual conflict between the 2nd law of thermodynamics and the time reversal symmetry (Brewer and Hahn, 1984). The discussion is illustrated in \n\nFigure 15 to portray the paradoxical nature of the discussions on the physical phenomenon giving rise to a spin-echo. This is yet another effect exploited by the MRI, without necessarily having a complete understanding of the underlying ‚Äúhidden order‚Äù effect emerging from the microscale interactions. For further reading on the conflict between the time symmetry and the entropy, the reader is referred to a recent blog post (Siegel, 2019).\n\nSee Also\n\nIn 2016, MRM Highlights published an \n\ninterview with \n\nErwin Hahn before he passed away the same year. His transformative genius offers many insights, not only about MRI.\n\n\n\nFigure¬†15:The second law of the thermodynamics (Boltzmann) vs the time reversal symmetry (Loschmidt) and the relation of this conflict to spin-echo (Hahn). The pancake analogy is followed in \n\nFigure 16 for completeness.\n\nFollowing an excitation pulse, the spin pool goes towards disorderliness and the transverse magnetization decays (the pancake batter expands, \n\nFigure 15). In their article, Brewer and Hahn discuss resurfacing of an ordered state out of this increasing entropy by reversing the phase order of the spins (the cooked pancake contracts). By retaining the pancake analogy, \n\nFigure 16 simulates a spin-echo (SE) pulse sequence and shows the spin evolution at certain time points. At the point (B), a 90¬∞excitation pulse rotates the net magnetization to transfer plane, and after some time, the spins dephase (C, arrows fanning out in the x-y spin scatter plot) as the FID disappears. The ‚Äúrefocusing pulse‚Äù rotates the net magnetization by 180¬∞in the transverse plane (D) and reverses the phase order of the spins, analogous to flipping the pancake (\n\nFigure 16). After a period equal to the duration between the 90¬∞and 180¬∞RF pulses, a spin echo is formed (F). The time elapses between the center of the excitation pulse and the peak of the echo signal is termed the echo time (TE).\n\n\n\nFigure¬†16:The spin evolution diagram of a spin-echo sequence is shown (A) before the excitation, (B) at the peak of the excitation pulse, (C) one millisecond after the 90¬∞pulse, (D) at the peak of the refocusing pulse, (E) one millisecond after the 180¬∞pulse, (F) at the echo time (TE) and (G) following the echo.S = M_{0}*(1-e^{\\frac{-TR}{T1}})*e^{\\frac{-TE}{T2}} \t\t\t\t\\frac{\\sin\\theta}{1-\\cos\\theta*e^{\\frac{-TR}{T1}}}\n\nEquation \n\nEq. 4 shows the signal representation of a standard SE acquisition. Given that the brightness of the image pixels is determined by the magnitude of the signal S, the relevant contribution of T1 and T2 to the image contrast can be adjusted by changing the TR and TE. For TE ‚Üí 0 (i.e. short TE), the last term of the equation converges to identity, reducing the T2 contribution. If this is coiled with a long TR (TR ‚Üí inf), the exponential in the second term of the equation converges to zero, reducing the T1 contribution. Therefore when the TE is short and the TR is long, the contribution to image contrast comes from the density of the spins, i.e. proton density. On the other hand, to increase the T2-weighting by keeping TR the same (long), the TE must be increased (the importance of the last term increases). \n\nFigure 17 exemplifies this by showing the same image across 6 echoes, where substances with longer T2 (e.g., eyes and the cerebrospinal fluid (CSF)) appear gradually brighter compared to the other structures in the image as the TE increases.\n\n\n\nFigure¬†17:An example T2 map, estimated by fitting voxel-wise brightness values (red plus signs) across 32 echo times to the exponential decay (blue line) defined by Equation \n\nEq. 4. The top row shows how conventional image contrast changes from proton-density to T2-weighted as the TE increases from 12ms to 380ms.\n\nSince the signal representation is known for the basic SE acquisition, the signal (the voxel brightness) can be sampled at several TE‚Äôs and fitted to the exponential decay defined by the last term of the equation to calculate T2, namely T2 mapping. The second term of the equation will not be taken into account, as the TR will be kept constant across the samples. \n\nFigure 17 shows a T2 mapping example, where an axial image of the human brain was collected across 32 TE‚Äôs ranging from 12 to 380ms.\n\nSo far we looked at how an echo forms out of a 90-180¬∞ pulse pair, and created a T2 map based on its signal representation. Although the images created using SE convey good soft-tissue contrast and are robust against motion artifacts, they often come at the cost of long acquisition time (TR ranges from half to a few seconds) and high RF energy deposition.","type":"content","url":"/introduction#spin-echo-and-t2-mapping","position":39},{"hierarchy":{"lvl1":"Introduction","lvl5":"Gradient Echo and T1 mapping","lvl3":"Coming full circle back to two measurements with two pulse sequences","lvl2":"Two MRI sequences and two qMRI measurements"},"type":"lvl5","url":"/introduction#gradient-echo-and-t1-mapping","position":40},{"hierarchy":{"lvl1":"Introduction","lvl5":"Gradient Echo and T1 mapping","lvl3":"Coming full circle back to two measurements with two pulse sequences","lvl2":"Two MRI sequences and two qMRI measurements"},"content":"Fortunately, MRI offers yet another way to generate echoes by taking advantage of the FID following a single RF pulse. The reversal effect needed for echoing the signal is achieved by dephasing and rephasing the spins with the use of a bipolar gradient (\n\nFigure 18). Therefore, this method is named the gradient echo (GRE).\n\n\n\nFigure¬†18:The formation of gradient echo by playing a bipolar gradient followed by a 20¬∞RF pulse.\n\nUnlike SE-based sequences, GRE sequences allow for shorter TE (a few milliseconds) and TR (10-50 milliseconds), resulting in faster acquisitions. In conventional imaging, one of the most popular GRE sequences is the spoiled gradient-echo (SPGR) sequence (Haase et al., 1986), as it allows large volumetric coverage within clinically feasible scan durations. SPGR is also widely used as a basis for various qMRI methods, because it provides a simple signal representation:S = M_{0}\\frac{\\sin\\theta *(1-e^{\\frac{-TR}{T1}})}{1-\\cos\\theta*e^{\\frac{-TR}{T1}}}e^{\\frac{-TE}{T2^*}}\n\nUnlike the SE signal representation (Equation \n\nEq. 4), Equation \n\nEq. 5 does not include a term explaining the decay of the transverse magnetization by T2. Instead, the last term of the SPGR signal representation indicates that the TE governs the signal contribution of T_{2}^{*} ‚Äì the effective T2. As the GRE is restored from the FID (\n\nFigure 18), the resulting echo is susceptible to slight variations in the main magnetic field. These variations may originate from the hardware-related imperfections of the B0, or from the field disruptions induced by adjacent substances with distinct magnetization levels, such as the air-tissue interfaces around the nasal cavity. As a result, T2 weighting cannot be achieved with SPGR. Instead, the second term of the Equation 2.5 indicates that the SPGR sequence is primarily T1- weighted, which can be controlled by changing the flip angle (FA) of the excitation pulse (Œ∏) or the TR.\n\nAfter a number of GRE excitation pulses, the longitudinal magnetization reaches a dynamic equilibrium, i.e. steady-state. When the steady state is reached, the spin system looks static to the observations at a macro-scale, whereas the underlying spin interactions carry on by balancing out each other. This is similar to a person walking up (T1 recovery) an escalator that is going down (the excitation pulse). When this equilibrium is accounted for by the Equation \n\nEq. 5, the FA that maximizes the signal for a fixed TR is given by:\\theta_E = \\arccos(e^{\\frac{-TR}{T1}})\n\nwhere \\theta_E is known as the Ernst Angle (Ernst and Anderson, 1966). \n\nFigure 19 shows this relationship by simulating an SPGR signal across multiple FA at a fixed TR of 30ms for a substance with T1=800ms. It can be seen that the signal is maximized around an FA of 15¬∞, as given by the Equation \n\nEq. 6 for these settings (\n\nFigure 19).\n\n\n\nFigure¬†19:Spoiled gradient-echo (SPGR) signal is simulated for excitation flip angle (FA) ranging from 0 to 90¬∞. With the repetition time set to 30ms, the Ernst Angle (\\theta_E) is calculated at 16¬∞for a spin system with T1 of 800ms (Equation \n\nEq. 6). The simulated signal agrees with the calculation, indicating that the signal is the highest when the FA is around 16¬∞(green line).\n\nHowever, this relationship is valid under the assumption that the transverse magnetization is zero. Therefore, any residual transverse magnetization during the readout violates the steady-state conditions of the signal representation given by Equation \n\nEq. 6. To avoid this, the entire spin system is dephased at the end of each TR by using a spoiler gradient, hence the name the ‚Äúspoiled‚Äù GRE. In real-world pulse sequence implementations, the gradient spoiling is coupled with RF spoiling by phase cycling the excitation from TR to TR at predetermined increments (Zur et al., 1991). \n\nFigure 20 displays Bloch simulation results, indicating the critical role of selecting the spoiler gradient area (a), enabling RF spoiling (b) and the selection of a proper phase increment value in disrupting the residual transverse magnetization. The effect of spoiling efficiency becomes particularly important when multiple SPGR acquisitions are performed at different flip angles to calculate a T1 map, namely variable flip angle (VFA) method (Fram et al., 1987). This is simply because when the observed data deviates from the expected signal representation (\n\nFigure 20), the fitted parameters become inaccurate. A more theoretical explanation of the VFA T1 mapping method, its accuracy aspects and limitations are explained in the \n\nT1 mapping chapter of this MOOC.\n\n\n\nFigure¬†20:The influence of spoiling on SPGR signal is simulated for (a) the spoiling gradient area ranging from 0 to 10 (cyc/voxel), (b) enabling/disabling RF spoiling at 117¬∞ quadratic phase increment and (c) different phase increment values ranging from 0 to 180¬∞.\n\nFigure 21 shows an example T1 mapping application using the SPGR sequence in a phantom with known values. The acquisitions were performed at two flip angles of 20¬∞ (a) and 6¬∞ (b), and TR=32ms. Both images show the center of a plate accommodating 14 spheres with T1 values ranging from 0.1 to 1.99 seconds in clockwise ascending order (R1 to R10). In agreement with the Equation 2.4, the image acquired at the higher FA shows superior T1 contrast (a), as the pixel brightness varies inversely with the reference T1 values (d). On the other hand, spheres in the lower FA image show similar brightness (b), in proportion with the spin density of the spheres. From this image pair, a T1 map (c) was estimated using a linear fit as described in \n\nthe VFA section of this book, exhibiting good accuracy across the reference values.\n\n\n\nFigure¬†21:Variable flip angle (VFA) using SPGR sequence. a) T1-weighted and b) PD- weighted images of ISMRM/NIST system phantom acquired at 18 and 32ms, respectively. c) T1 map estimated by fitting images (a) and (b) to the relaxational component of the Equation 2.5. d) The comparison of the estimated and reference T1 values.\n\nIn this section, we covered two fundamental pulse sequences: SE and SPGR. Starting from spin-level interactions, we looked at the signal representations of each sequence and how acquisition parameters are associated with the contrast characteristics of the resulting conventional images. By doing so, we analyzed how pixel brightness emerges from two values, T2 and T1. Then using the same signal representations, we came full circle back (in case you were wondering what it meant) to these values from the pixel brightness by applying two fundamental qMRI methods, multi-echo SE for T2 and VFA for T1 mapping. A more entertaining summary of the SE and GRE sequences is unintentionally delivered by two indie rock albums (\n\nFigure 22).\n\n\n\nFigure¬†22:Two (slightly modified) album covers by the \n\nArtic Monkeys and \n\nthe Districts summarizing spin-echo (SE) and spoiled gradient-echo (SPGR) sequences.","type":"content","url":"/introduction#gradient-echo-and-t1-mapping","position":41},{"hierarchy":{"lvl1":"Introduction","lvl2":"Will qMRI take over the world?"},"type":"lvl2","url":"/introduction#will-qmri-take-over-the-world","position":42},{"hierarchy":{"lvl1":"Introduction","lvl2":"Will qMRI take over the world?"},"content":"","type":"content","url":"/introduction#will-qmri-take-over-the-world","position":43},{"hierarchy":{"lvl1":"Introduction","lvl3":"If qMRI is possible and powerful, why is clinical imaging still conventional?","lvl2":"Will qMRI take over the world?"},"type":"lvl3","url":"/introduction#if-qmri-is-possible-and-powerful-why-is-clinical-imaging-still-conventional","position":44},{"hierarchy":{"lvl1":"Introduction","lvl3":"If qMRI is possible and powerful, why is clinical imaging still conventional?","lvl2":"Will qMRI take over the world?"},"content":"‚ÄúThe court found that Fonar failed to establish the existence of standard T1 and T2 values, which are limitations of the asserted claims...‚Äù (GE vs Fonar 1996, U.S. Fed. Cir.)\n\nReally?\n\nAfter decades of research and development since this court decision, which saved GE from spending an additional few million dollars, the standard values for T1 and T2 are still not well known (Bojorquez et al., 2017) and qMRI has yet to find one clinical application (still holds in 2024).\n\nThis is partly because of the inherently complex make-up of the human body, where sensitivity alone is not enough to tease out biological variability. Quantifications should also be specific to the targeted microstructure, such as the myelin in the living human brain. For this purpose alone, the literature offers more than 30 methods for quantifying myelin at varying methodological complexity, yet they all appear to be statistically indistinguishable in specifying myelin (Mancini et al., 2020). This indicates that a lack of methodological extensity is not the culprit preventing qMRI from clinical use. Quite the contrary, there is an abundance of solutions, yet we cannot make an informed decision about which method to use. This problem has multiple roots and \n\nFigure 23 outlines the components of a qMRI study for identifying them.\n\n\n\nFigure¬†23:An illustration of the components that make up a qMRI study.","type":"content","url":"/introduction#if-qmri-is-possible-and-powerful-why-is-clinical-imaging-still-conventional","position":45},{"hierarchy":{"lvl1":"Introduction","lvl4":"Vendor-native differences challenge the reliability of qMRI","lvl3":"If qMRI is possible and powerful, why is clinical imaging still conventional?","lvl2":"Will qMRI take over the world?"},"type":"lvl4","url":"/introduction#vendor-native-differences-challenge-the-reliability-of-qmri","position":46},{"hierarchy":{"lvl1":"Introduction","lvl4":"Vendor-native differences challenge the reliability of qMRI","lvl3":"If qMRI is possible and powerful, why is clinical imaging still conventional?","lvl2":"Will qMRI take over the world?"},"content":"Every qMRI study starts with the acquisition of a set of conventional images. This is often achieved by altering protocol parameters according to the signal representation of the respective pulse sequence, i.e. successive runs. As previously shown in the SPGR example for T1 mapping (\n\nFigure 20), there are various parameters that are vital to the measurement accuracy and precision. In general, strict metrological standards are established for the manufacturing process of any medical device expected to fulfill some accuracy requirements. For example, all the ventilator vendors are obliged to disclose their measurement uncertainty for inspiratory oxygen concentration (ISO 80601-2-12:2011). However, MRI is exempt from such a class of essential performance assessments on the accuracy and precision, given that the medical diagnoses using conventional MRI depend on qualitative feature recognition (\n\nFigure 1). In turn, design considerations that matter to the reliability of qMRI measurements fall through the cracks of the device manufacturing and programming processes. Although this is understandable from a vendor‚Äôs cost-effectiveness standpoint, it bears dire consequences on the quantitative applications.\n\n\n\nFigure¬†24:Choices involved in the implementation of a magnetization-transfer weighted spoiled gradient echo (SPGR) sequence are shown for all the gradient and RF waveforms involved.\n\nEven for the simplest sequence implementations, there may be several parameters that matter to quantification, but are hidden from the end user. \n\nFigure 24 shows the implementation- level parameters that are available after the type/shape selections were made for an SPGR sequence with a magnetization-transfer saturation pulse. In addition to the sequence itself, pre-scan calibrations such as shimming, center frequency tuning and transmit gain adjustments are other factors that affect the measurement accuracy. For example, neither of the major vendor implementations enable the selection of spoiling gradient area (F\n\nFigure 20a), RF spoiling regime (\n\nFigure 20b,c), magnetization transfer (MT) pulse specifications, ex- citation pulse type or the ordering of the observations (\n\nFigure 24). The more advanced the sequence, the more implementation choices come to the surface. These restrictions and unknowns brought by vendor-specific sequence implementations trap tens of qMRI measurements into a maze of variability and prevent them from reaching the clinics (\n\nFigure 25).\n\nAfter the raw data is acquired, it has to be reconstructed to generate images, which is yet another process with a wide range of options to choose from. Therefore, properly formatting and making the raw data accessible is a non-trivial interim step for the provenance of the following steps. In addition, the relationship between the reconstructed images and the grouping logic entailed by the qMRI model should be retained along with sufficient metadata. Even though there is an emerging data standard for organizing the raw data (Inati et al., 2017), there is not a community consensus on how to organize qMRI datasets (\n\nFigure 23). This creates idiosyncrasies, challenging interoperability and decreasing efficiency of processing qMRI data.\n\n\n\nFigure¬†25:The current landscape of quantitative MRI is a maze of variability for amazing methods. A complete recipe is needed to chart out the path towards clinics.\n\nThere are dozens of publications introducing new qMRI methods, yet a majority of these implementations are kept within their labs of origin, making it challenging to reproduce qMRI studies. This is partly caused by the vendor restrictions. Nonetheless, it is generally possible to share the workflow components of the developed methods. \n\nFigure 23 shows that all qMRI methods share a common methodology at their core: a signal representation (qRecipe) that relates a set of parametrically linked MR images (qData) to some microstructural and physical features (qMap) by computation (qProcessing). Although these ingrained attributes exist at a conceptual level in the source code developed by independent developers, there is not a consensus on how to represent them in a programming paradigm. Even though 80% of the source code made available by the MRI developers share the same programming language (MATLAB) (Boudreau, 2019), there is still a need for a common framework for the development of qMRI methods in MATLAB to make implementations easier.\n\nTo summarize the problems mentioned above, there are three outstanding issues that hinder the standardization of qMRI:\n\nMost methods are developed using in-house code that is difficult to distribute, challenging the accessibility and reproducibility of qMRI studies.\n\nThe lack of a qMRI data standard poses an interoperability challenge for open-source solutions aiming at making qMRI methods publicly accessible.\n\nThe unknowns involved in the implementation of commercial pulse sequences constitute a substantial source of (vendor-specific) variability in fitting quantitative parameters using voxel brightness data.","type":"content","url":"/introduction#vendor-native-differences-challenge-the-reliability-of-qmri","position":47},{"hierarchy":{"lvl1":"Introduction","lvl4":"Vendor-neutral qMRI and its importance","lvl3":"If qMRI is possible and powerful, why is clinical imaging still conventional?","lvl2":"Will qMRI take over the world?"},"type":"lvl4","url":"/introduction#vendor-neutral-qmri-and-its-importance","position":48},{"hierarchy":{"lvl1":"Introduction","lvl4":"Vendor-neutral qMRI and its importance","lvl3":"If qMRI is possible and powerful, why is clinical imaging still conventional?","lvl2":"Will qMRI take over the world?"},"content":"--MISSING--","type":"content","url":"/introduction#vendor-neutral-qmri-and-its-importance","position":49},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-1-1","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"01\",'figure_2.pkl')\n\nwith open(filename, 'rb') as f:\n    params, signal_WM, signal_GM, signal_CSF = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\nwm = go.Scatter(\n    x = params[\"TI\"],\n    y = signal_WM,\n    name = 'T<sub>1</sub> = 0.9 s (White Matter)',\n    text = 'T<sub>1</sub> = 0.9 s (White Matter)',\n    hoverinfo = 'x+y+text'\n)\n\ngm = go.Scatter(\n    x = params[\"TI\"],\n    y = signal_GM,\n    name = 'T<sub>1</sub> = 1.5 s (Grey Matter)',\n    text = 'T<sub>1</sub> = 1.5 s (Grey Matter)',\n    hoverinfo = 'x+y+text'\n)\n\ncsf = go.Scatter(\n    x = params[\"TI\"],\n    y = signal_CSF,\n    name = 'T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n    text = 'T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n    hoverinfo = 'x+y+text'\n)\n\ndata = [wm, gm, csf]\n\nlayout = go.Layout(\n    width=600,\n    height=350,\n    margin=go.layout.Margin(\n        l=100,\n        r=50,\n        b=60,\n        t=0,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.175,\n            showarrow=False,\n            text='Inversion Time ‚Äì¬†TI (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Long. Magnetization (M<sub>z</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.55,\n        y=0.15,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_2.html', config = config)\n\n#display(HTML('ir_fig_2.html'))","type":"content","url":"/figure-2-1-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-1-2","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"\nfilename = os.path.join(DATA_ROOT,\"01\",'figure_2.pkl')\n\nwith open(filename, 'rb') as f:\n    params, signal_WM, signal_GM, signal_CSF = pickle.load(f)\n\nfilename = os.path.join(DATA_ROOT,\"01\",'figure_3.pkl')\nwith open(filename, 'rb') as f:\n    T1_range, signal_T1_Eq1, signal_T1_Eq3 = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        x = params[\"TI\"],\n        y = abs(signal_T1_Eq3[ii]),\n        name = '[Eq. 2.3] ‚Äì Long TR approximation',\n        text = '[Eq. 2.3] ‚Äì Long TR approximation',\n        hoverinfo = 'x+y+text') for ii in range(len(T1_range))]\n\ndata1[3]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        x = params[\"TI\"],\n        y = abs(signal_T1_Eq1[ii]),\n        line = dict(\n            color = ('rgb(22, 96, 167)'),\n            dash = 'dash'),\n        name = '[Eq. 2.1] ‚Äì General Equation',\n        text = '[Eq. 2.1] ‚Äì General Equation',\n        hoverinfo = 'x+y+text') for ii in range(len(T1_range))]\n\ndata2[3]['visible'] = True\n\ndata = data1 + data2\n\nsteps = []\nfor i in range(len(T1_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(T1_range[i])\n    )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.0,\n    active = 3,\n    currentvalue = {\"prefix\": \"T<sub>1</sub> value (s): <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=580,\n    height=400,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.2,\n            showarrow=False,\n            text='Inversion Time ‚Äì¬†TI (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.14,\n            y=0.5,\n            showarrow=False,\n            text='Signal (magnitude)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, 5],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=False,\n        range=[0, 1],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.5,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders,\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_3.html', config = config)\n","type":"content","url":"/figure-2-1-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-1-3","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"01\",'figure_4.pkl')\n\n\n\nwith open(filename, 'rb') as f:\n    params, Mz_analytical, fitOutput_lm, fitOutput_barral, TR_range = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'markers',\n        x = params[\"TI\"],\n        y = abs(np.squeeze(np.asarray(Mz_analytical[ii]))),\n        name = 'Simulated data',\n        text = 'Simulated data',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata1[10]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"TI\"],\n        y = abs(fitOutput_lm[ii]['c'] * (1 - 2*np.exp(-params['TI']/fitOutput_lm[ii]['T1']))),\n        name = '[C(1-2e<sup>-TI/T<sub>1</sub></sup>)] Fitted T<sub>1</sub>: <b>' + str(round(fitOutput_lm[ii]['T1'])) + ' ms',\n        text = '[C(1-2e<sup>-TI/T<sub>1</sub></sup>)]',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata2[10]['visible'] = True\n\ndata3 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"TI\"],\n        y = abs((fitOutput_barral[ii]['ra']+fitOutput_barral[ii]['rb']*np.exp(-params['TI']/fitOutput_barral[ii]['T1']))),\n        name = '[<i>a</i>+<i>b</i>e<sup>-TI/T<sub>1</sub></sup>] Fitted T<sub>1</sub>: <b>' + str(round(fitOutput_barral[ii]['T1'])) + ' ms',\n        text = '[<i>a</i>+<i>b</i>e<sup>-TI/T<sub>1</sub></sup>]',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata3[10]['visible'] = True\n\n\n\ndata = data1 + data2 + data3\n\nsteps = []\nfor i in range(len(TR_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(TR_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 10,\n    currentvalue = {\"prefix\": \"TR value (ms): <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Inversion Time ‚Äì¬†TI (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.14,\n            y=0.5,\n            showarrow=False,\n            text='Signal (magnitude)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['TI'][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=False,\n        range=[0, 1],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.2,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders,\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_4.html', config = config)\n","type":"content","url":"/figure-2-1-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-1-4","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"01\",'figure_5.pkl')\n\nwith open(filename, 'rb') as f:\n    T1_map, TI_0030, TI_0530, TI_1030, TI_1530, xAxis, yAxis = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=TI_0030,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=TI_0530,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace3 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=TI_1030,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=True,\n                   name = 'Signal')\ntrace4 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=TI_1530,\n                   colorscale='gray',\n                   visible=False,\n                   showscale = False,\n                   name = 'Signal')\ntrace5 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=T1_map,\n                   colorscale='Portland',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'T1 values (ms)')\n\ndata=[trace1, trace2, trace3, trace4, trace5]\n\n\nupdatemenus = list([\n    dict(active=2,\n         x = 0.12,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = '30 ms',\n                 method = 'update',\n                 args = [{'visible': [True, False, False, False, True]},\n                         ]),\n            dict(label = '530 ms',\n                 method = 'update',\n                 args = [{'visible': [False, True, False, False, True]},\n                         ]),\n            dict(label = '1030 ms',\n                 method = 'update',\n                 args = [{'visible': [False, False, True, False, True]},\n                         ]),\n            dict(label = '1530 ms',\n                 method = 'update',\n                 args = [{'visible': [False,False, False, True, True]},\n                         ])\n        ]),\n    )\n])\n\nlayout = dict(\n    width=560,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.06,\n            y=1.15,\n            showarrow=False,\n            text='MR Image',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.6,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.22,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.02,\n            y=-0.15,\n            showarrow=False,\n            text='TI:',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.6]),\n    yaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    xaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0.4, 1]),\n    yaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1], anchor='x2'),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus,\n    plot_bgcolor='white'\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_5.html', config = config)\n","type":"content","url":"/figure-2-1-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-1-5","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"01\",'figure_6.pkl')\n\nwith open(filename, 'rb') as f:\n    TR_range, TI_lowres, TI_highres, T1_mean, T1_std, data_mean, data_std, data_noiseless = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        x = np.squeeze(np.asarray(TI_lowres[ii,:])),\n        y = np.squeeze(np.asarray(data_mean[ii,:])),\n        error_y=dict(\n            type='data',\n            color = ('rgb(22, 96, 167)'),\n            array=np.squeeze(np.asarray(data_std[ii,:])),\n            visible=True\n        ),\n        line = dict(\n            color = ('rgb(22, 96, 167)'),\n            dash = 'dot'),\n        mode = 'markers',\n        name = 'Monte Carlo simulated signal',\n        text = 'Monte Carlo simulated signal',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata1[28]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        x = np.squeeze(np.asarray(TI_highres[ii,:])),\n        y = np.squeeze(np.asarray(data_noiseless[ii,:])),\n        line = dict(\n            color = ('rgb(247, 152, 19)'),\n            ),\n        name = 'Noiseless signal',\n        text = 'Noiseless signal',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata2[28]['visible'] = True\n\ndata_meanT1 = [dict(\n    visible = False,\n    x = TR_range,\n    y = T1_mean,\n    name = 'Mean T<sub>1</sub> (s)',\n    text = 'Mean T<sub>1</sub> (s)',\n    hoverinfo = 'x+y+text',\n    xaxis='x2',\n    yaxis='y2') for ii in range(len(TR_range))]\n\ndata_meanT1[15]['visible'] = True\n\ndata_stdT1 = [dict(\n    visible = False,\n    x = TR_range,\n    y = T1_std,\n    line = dict(\n        color = ('rgb(222, 22, 22)'),\n        ),\n    name = 'STD T<sub>1</sub> (s)',\n    text = 'STD T<sub>1</sub> (s)',\n    hoverinfo = 'x+y+text',\n    xaxis='x2',\n    yaxis='y3') for ii in range(len(TR_range))]\n\ndata_stdT1[28]['visible'] = True\n\ndata = data2 + data1 + data_meanT1 + data_stdT1\n\nsteps = []\nfor i in range(len(TR_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(TR_range[i])\n    )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 28,\n    currentvalue = {\"prefix\": \"TR value (ms): <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=540,\n    height=540,\n    margin = dict(\n                t=0,\n                r=25,\n                b=100,\n                l=75),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.17,\n            showarrow=False,\n            text='Inversion Time ‚Äì¬†TI (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Signal (magnitude)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.76,\n            y=0.77,\n            showarrow=False,\n            text='<b>TR (ms)<b>',\n            font=dict(\n                family='Times New Roman',\n                size=14\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.40,\n            y=0.35,\n            showarrow=False,\n            text='<b>Mean T<sub>1</sub> (ms)<b>',\n            font=dict(\n                family='Times New Roman',\n                size=14\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.00,\n            y=0.35,\n            showarrow=False,\n            text='<b>STD T<sub>1</sub> (ms)<b>',\n            font=dict(\n                family='Times New Roman',\n                size=14\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        )\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, 5000],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=False,\n        range=[0, 1],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    xaxis2=dict(\n        domain=[0.5, 0.90],\n        anchor='y2',\n        mirror = True,\n        side='top',\n        ticks='inside',\n        showline=True,\n    ),\n    yaxis2=dict(\n        autorange=False,\n        range=[500, 1300],\n        domain=[0.05, 0.65],\n        anchor='x2',\n        mirror = True,\n        ticks='inside',\n        showline=True,\n    ),\n    yaxis3=dict(\n        autorange=False,\n        range=[0, 190],\n        domain=[0.05, 0.65],\n        anchor='x2',\n        overlaying='y2',\n        side='right',\n        ticks='inside',\n    ),\n    legend=dict(\n        x=0.3,\n        y=1.35,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders,\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_6.html', config = config)\n","type":"content","url":"/figure-2-1-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-2-1","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"02\",'figure_2.pkl')\n\nwith open(filename, 'rb') as f:\n    params, TR_range, signal_WM, signal_GM, signal_CSF = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_WM[ii]))),\n        name = 'T<sub>1</sub> = 0.9 s (White Matter)',\n        text = 'T<sub>1</sub> = 0.9 s (White Matter)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata1[4]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_GM[ii]))),\n        name = 'T<sub>1</sub> = 1.5 s (Grey Matter)',\n        text = 'T<sub>1</sub> = 1.5 s (Grey Matter)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata2[4]['visible'] = True\n\ndata3 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_CSF[ii]))),\n        name = 'T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n        text = 'T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR_range))]\n\ndata3[4]['visible'] = True\n\ndata = data1 + data2 + data3\n\nsteps = []\nfor i in range(len(TR_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(TR_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 2,\n    currentvalue = {\"prefix\": \"TR value (ms): <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Long. Magnetization (M<sub>z</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders,\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'vfa_fig_2.html', config = config)\n","type":"content","url":"/figure-2-2-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-2-2","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"02\",'figure_3.pkl')\n\nwith open(filename, 'rb') as f:\n    params, Nex_range, signal_analytical, signal_blochsim = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_analytical[ii]))),\n        name = 'Analytical Solution',\n        text = 'Analytical Solution',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata1[9]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_blochsim[ii]))),\n        name = 'Bloch Simulation',\n        text = 'Bloch Simulation',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata2[9]['visible'] = True\n\ndata = data1 + data2\n\nsteps = []\nfor i in range(len(Nex_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(Nex_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 9,\n    currentvalue = {\"prefix\": \"n<sup>th</sup> TR: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders,\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'vfa_fig_3.html', config = config)\n","type":"content","url":"/figure-2-2-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-2-3","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"02\",'figure_4.pkl')\n\nwith open(filename, 'rb') as f:\n    params, Nex_range, signal_ideal_spoil, signal_optimal_crush_and_rf_spoil, signal_no_gradient_and_rf_spoil = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_ideal_spoil[ii]))),\n        name = 'Ideal Spoiling',\n        text = 'Ideal Spoiling',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata1[10]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_optimal_crush_and_rf_spoil[ii]))),\n        name = 'Gradient & RF Spoiling',\n        text = 'Gradient & RF Spoiling',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata2[10]['visible'] = True\n\ndata3 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"],\n        y = abs(np.squeeze(np.asarray(signal_no_gradient_and_rf_spoil[ii]))),\n        name = 'No Spoiling',\n        text = 'No Spoiling',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata3[10]['visible'] = True\n\ndata = data1 + data2+ data3\n\nsteps = []\nfor i in range(len(Nex_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(Nex_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 10,\n    currentvalue = {\"prefix\": \"n<sup>th</sup> TR: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders,\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'vfa_fig_4.html', config = config)\n\n\n","type":"content","url":"/figure-2-2-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-2-4","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"02\",'figure_5.pkl')\n\nwith open(filename, 'rb') as f:\n    params, data_mean, data_mean_div_sin, data_mean_div_tan, data_std, data_std_div_sin, data_std_div_tan, params_highres, signal_WM, signal_WM_div_sin, signal_WM_div_tan = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = dict(\n        visible = True,\n        x = params_highres[\"EXC_FA\"],\n        y = signal_WM,\n        name = 'Analytical Solutions',\n        text = params[\"EXC_FA\"],\n        mode = 'lines', \n        line = dict(\n            color = ('rgb(0, 0, 0)'),\n            dash = 'dot'),\n        hoverinfo='none')\n\ndata2 = dict(\n        visible = True,\n        x = signal_WM_div_tan,\n        y = signal_WM_div_sin,\n        name = 'Analytical Solutions',\n        text = params_highres[\"EXC_FA\"],\n        mode = 'lines',\n        xaxis='x2',\n        yaxis='y2',\n        line = dict(\n            color = ('rgb(0, 0, 0)'),\n            dash = 'dot'\n            ),\n        hoverinfo='none',\n        showlegend=False)\n\ndata3 = dict(\n        visible = True,\n        x = params[\"EXC_FA\"],\n        y = data_mean,\n        name = 'Nonlinear Form - Noisy',\n        text = [\"Flip angle: \" + str(x) + \"¬∞\" for x in params[\"EXC_FA\"]],\n        mode = 'markers',\n        hoverinfo = 'y+text',\n        line = dict(\n            color = ('rgb(22, 96, 167)'),\n            ),\n        error_y=dict(\n            type='data',\n            array=data_std,\n            visible=True,\n            color = ('rgb(142, 192, 240)')\n        ))\n\ndata4 = dict(\n        visible = True,\n        x = data_mean_div_tan,\n        y = data_mean_div_sin,\n        name = 'Linear Form - Noisy',\n        text = [\"Flip angle: \" + str(x) + \"¬∞\" for x in params[\"EXC_FA\"]],\n        mode = 'markers',\n        xaxis='x2',\n        yaxis='y2',\n        hoverinfo = 'x+y+text',\n        line = dict(\n            color = ('rgb(205, 12, 24)'),\n            ),\n        error_x=dict(\n            type='data',\n            array=data_std_div_tan,\n            visible=True,\n            color = ('rgb(248, 135, 142)')\n        ),\n        error_y=dict(\n            type='data',\n            array=data_std_div_sin,\n            visible=True,\n            color = ('rgb(248, 135, 142)')\n        ))\n\ndata = [data1, data2, data3, data4]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=80,\n        b=60,\n        t=60,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.14,\n            showarrow=False,\n            text='Excitation Flip Angle (<i>Œ∏<sub>n</sub></i>)',\n            font=dict(\n                family='Times New Roman',\n                size=22,\n                color=('rgb(21, 91, 158)')\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.17,\n            y=0.5,\n            showarrow=False,\n            text='Signal (<i>S<sub>n</sub></i>)',\n            font=dict(\n                family='Times New Roman',\n                size=22,\n                color=('rgb(21, 91, 158)')\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5004254919715793,\n            y=1.15,\n            showarrow=False,\n            text='<i>S<sub>n</sub></i> / tan(<i>Œ∏<sub>n</sub></i>)',\n            font=dict(\n                family='Times New Roman',\n                size=22,\n                color=('rgb(169, 10, 20)') \n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.16,\n            y=0.5,\n            showarrow=False,\n            text='<i>S<sub>n</sub></i> / sin(<i>Œ∏<sub>n</sub></i>)',\n            font=dict(\n                family='Times New Roman',\n                size=22,\n                color=('rgb(169, 10, 20)') \n            ),\n            xref='paper',\n            yref='paper',\n            textangle=-90,\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[params['EXC_FA'][0], params['EXC_FA'][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    xaxis2=dict(\n        autorange=False,\n        range=[0, 1],\n        showgrid=False,\n        mirror=True,\n        overlaying= 'x',\n        anchor= 'y2',\n        side= 'top',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis2=dict(\n        autorange=False,\n        range=[0, 1],\n        showgrid=False,\n        overlaying= 'y',\n        anchor= 'x',\n        side= 'right',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.32,\n        y=0.98,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'vfa_fig_5.html', config = config)\n","type":"content","url":"/figure-2-2-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-2-5","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"    \nfilename = os.path.join(DATA_ROOT,\"02\",'figure_6.pkl')\n\nwith open(filename, 'rb') as f:\n    B1Range, mean_T1_noB1Correction, mean_T1_withB1Correction, std_T1_noB1Correction, std_T1_withB1Correction = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ndata1 = dict(\n        visible = True,\n        x = B1Range,\n        y = mean_T1_noB1Correction,\n        name = 'Nominal flip angles',\n        text = 'Nominal flip angles',\n        mode = 'lines+markers',\n        hoverinfo = 'x+y+text',\n        line = dict(\n            color = ('rgb(22, 96, 167)'),\n            ),\n        error_y=dict(\n            type='data',\n            array=std_T1_noB1Correction,\n            visible=True,\n            color = ('rgb(142, 192, 240)')\n        ))\n\ndata2 = dict(\n        visible = True,\n        x = B1Range,\n        y = mean_T1_withB1Correction,\n        name = 'B<sub>1</sub>-corrected flip angles',\n        text = 'B<sub>1</sub>-corrected flip angles',\n        mode = 'lines+markers',\n        hoverinfo = 'x+y+text',\n        line = dict(\n            color = ('rgb(205, 12, 24)'),\n            ),\n        error_y=dict(\n            type='data',\n            array=std_T1_withB1Correction,\n            visible=True,\n            color = ('rgb(248, 135, 142)')\n        ))\n\ndata = [data1, data2]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=80,\n        b=60,\n        t=60,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.14,\n            showarrow=False,\n            text='B<sub>1</sub> (n.u.)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.17,\n            y=0.5,\n            showarrow=False,\n            text='T<sub>1</sub> (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[B1Range[0], B1Range[-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=False,\n        range=[0, max(mean_T1_noB1Correction)],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.32,\n        y=0.98,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    plot_bgcolor='white'\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'vfa_fig_6.html', config = config)\n","type":"content","url":"/figure-2-2-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-2-6","position":0},{"hierarchy":{"lvl1":""},"content":"from repo2data.repo2data import Repo2Data\nimport os \nimport pickle\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom pathlib import Path\n\nfrom contextlib import contextmanager\nimport sys, os\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \nDATA_ROOT = dataset_path / \"t1-book-neurolibre\"   \nfilename = os.path.join(DATA_ROOT,\"02\",'figure_7.pkl')\n\nwith open(filename, 'rb') as f:\n    T1_map, FA_03, FA_20, B1map, xAxis, yAxis  = pickle.load(f)\n\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=FA_03,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=FA_20,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=True,\n                   name = 'Signal')\ntrace3 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=B1map,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='balance',\n                   showscale = False,\n                   visible=False,\n                   name = 'B1 values')\ntrace5 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=T1_map,\n                   zmin=0.0,\n                   zmax=5000,\n                   colorscale='Portland',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'T1 values (ms)')\n\ndata=[trace1, trace2, trace3, trace5]\n\n\nupdatemenus = list([\n    dict(active=1,\n         x = 0.09,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = '3 deg',\n                 method = 'update',\n                 args = [{'visible': [True, False, False, True]},\n                         ]),\n            dict(label = '20 deg',\n                 method = 'update',\n                 args = [{'visible': [False, True, False, True]},\n                           ]),\n            dict(label = 'B<sub>1</sub> map',\n                 method = 'update',\n                 args = [{'visible': [False, False, True, True]},\n                           ])\n        ])\n    )\n])\n\nlayout = dict(\n    width=560,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.055,\n            y=1.15,\n            showarrow=False,\n            text='Input Data',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.6,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.22,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.58]),\n    yaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    xaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0.40, 0.98]),\n    yaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1], anchor='x2'),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus,\n    plot_bgcolor='white'\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'vfa_fig_7.html', config = config)\n","type":"content","url":"/figure-2-2-6","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-3-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \n\ndata_dir = dataset_path / \"02-T1-03-MP2RAGE\"\ndata_file = \"fig1.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nT1matrix = mat_contents[\"T1matrix\"]\nB1_vector = mat_contents[\"B1_vector\"][0]\nMP2RAGE_vector = mat_contents[\"MP2RAGE_vector\"][0]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\ntrace5 = go.Heatmap(x = MP2RAGE_vector,\n                   y = B1_vector,\n                   z=T1matrix,\n                   zmin=0,\n                   zmax=5,\n                   colorscale='Portland',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'T1 values (ms)')\n\ndata=[trace5]\n\nlayout = dict(\n    width=560,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=50,\n                l=80),\n    annotations=[\n         dict(\n            x=-0.14,\n            y=0.5,\n            showarrow=False,\n            text='B<sub>1</sub> values',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n          dict(\n            x=0.5,\n            y=-0.2,\n            showarrow=False,\n            text='S<sub>MP2RAGE</sub> values',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5,\n            y=1.15,\n            showarrow=False,\n            text='Lookup Table',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.17,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=20\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,1], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.5]),\n    yaxis = dict(range = [0,1], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    showlegend = False,\n    autosize = False,\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-heatmap', config = config)","type":"content","url":"/figure-2-3-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-2-3-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n    \n\ndata_dir = dataset_path / \"02-T1-03-MP2RAGE\"\ndata_file = \"fig2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nT1_map = mat_contents[\"T1_map\"]\nS_INV1 = mat_contents[\"S_INV1\"]\nS_INV2 = mat_contents[\"S_INV2\"]\nB1map = mat_contents[\"B1map\"]\nxAxis = mat_contents[\"xAxis\"][0]\nyAxis = mat_contents[\"yAxis\"][0]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=S_INV1,\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=S_INV2,\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace3 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=B1map,\n                   zmin=-0.5,\n                   zmax=0.5,\n                   colorscale='RdBu',\n                   showscale = False,\n                   visible=True,\n                   name = 'S_MP2RAGE')\ntrace5 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=T1_map,\n                   zmin=0.0,\n                   zmax=5000,\n                   colorscale='Portland',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'T1 values (ms)')\n\ndata=[trace1, trace2, trace3, trace5]\n\n\nupdatemenus = list([\n    dict(active=2,\n         x = 0.09,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = 'S<sub>INV1</sub>',\n                 method = 'update',\n                 args = [{'visible': [True, False, False, True]},\n                         ]),\n            dict(label = 'S<sub>INV2</sub>',\n                 method = 'update',\n                 args = [{'visible': [False, True, False, True]},\n                           ]),\n            dict(label = 'S<sub>MP2RAGE</sub>',\n                 method = 'update',\n                 args = [{'visible': [False, False, True, True]},\n                           ])\n        ])\n    )\n])\n\nlayout = dict(\n    width=560,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.055,\n            y=1.15,\n            showarrow=False,\n            text='Input Data',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.6,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.22,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>1</sub> (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,206], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.58]),\n    yaxis = dict(range = [0,215], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    xaxis2 = dict(range = [0,206], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0.40, 0.98]),\n    yaxis2 = dict(range = [0,215], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1], anchor='x2'),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-heatmap', config = config)","type":"content","url":"/figure-2-3-2","position":1},{"hierarchy":{"lvl1":"T1 Mapping"},"type":"lvl1","url":"/t1-mapping","position":0},{"hierarchy":{"lvl1":"T1 Mapping"},"content":"","type":"content","url":"/t1-mapping","position":1},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"Inversion Recovery T1 Mapping"},"type":"lvl2","url":"/t1-mapping#irintroduction","position":2},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"Inversion Recovery T1 Mapping"},"content":"Widely considered the gold standard for \n\nT1 mapping, the \n\ninversion recovery technique estimates \n\nT1 values by fitting the signal recovery curve acquired at different delays after an inversion pulse (180¬∞). In a typical \n\ninversion recovery experiment (\n\nFigure 2.1), the \n\nmagnetization at thermal equilibrium is inverted using a 180¬∞ RF pulse. After the longitudinal \n\nmagnetization recovers through \n\nspin-lattice relaxation for predetermined delay (inversion time, TI), a 90¬∞ excitation pulse is applied, followed by a readout imaging sequence (typically a \n\nspin-echo or \n\ngradient-echo readout) to create a snapshot of the longitudinal \n\nmagnetization state at that TI.\n\nInversion recovery was first developed for \n\nNMR in the 1940s \n\nHahn, 1949\n\nDrain, 1949, and the first \n\nT1 map was acquired using a saturation-recovery technique (90¬∞ as a preparation pulse instead of 180¬∞) by \n\nPykett & Mansfield, 1978. Some distinct advantages of inversion recovery are its large dynamic range of signal change and an insensitivity to pulse sequence parameter imperfections \n\nStikov et al., 2015. Despite its proven robustness at measuring \n\nT1, inversion recovery is scarcely used in practice, because conventional implementations require repetition times (TRs) on the order of 2 to 5 \n\nT1 \n\nSteen et al., 1994, making it challenging to acquire whole-organ \n\nT1 maps in a clinically feasible time. Nonetheless, it is continuously used as a reference measurement during the development of new techniques, or when comparing different \n\nT1 mapping techniques, and several variations of the \n\ninversion recovery technique have been developed, making it practical for some applications \n\nMessroghli et al., 2004\n\nPiechnik et al., 2010.\n\n\n\nFigure¬†2.1:Pulse sequence of an inversion recovery experiment.","type":"content","url":"/t1-mapping#irintroduction","position":3},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Signal Modelling","lvl2":"Inversion Recovery T1 Mapping"},"type":"lvl3","url":"/t1-mapping#signal-modelling","position":4},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Signal Modelling","lvl2":"Inversion Recovery T1 Mapping"},"content":"The steady-state longitudinal magnetization of an \n\ninversion recovery experiment can be derived from the \n\nBloch equations for the pulse sequence {\\theta_{180} ‚Äì TI ‚Äì \\theta_{180} ‚Äì (TR-TI)}, and is given by:M_{z}(TI) = M_0 \\frac{1-\\text{cos}(\\theta_{180})e^{- \\frac{TR}{T_1}} -[1-\\text{cos}(\\theta_{180})]e^{- \\frac{TI}{T_1}}}{1 - \\text{cos}(\\theta_{180}) \\text{cos}(\\theta_{90}) e^{- \\frac{TR}{T_1}}}\n\nwhere M_{z} is the longitudinal magnetization prior to the \\theta_{90} pulse. If the in-phase \n\nreal signal is desired, it can be calculated by multiplying \n\nEq. 2.1 by k \\text{sin}\\left( \\theta_{90} \\right ) e^{-TE/T_{2}}, where k is a constant. This general equation can be simplified by grouping together the constants for each measurements regardless of their values (i.e. at each TI, same TE and \\theta_{90} are used) and assuming an ideal inversion pulse:M_z(TI) = C(1-2e^{- \\frac{TI}{T_1}} + e^{- \\frac{TR}{T_1}})\n\nwhere the first three terms and the denominator of \n\nEq. 2.1 have been grouped together into the constant C. If the experiment is designed such that TR is long enough to allow for full relaxation of the magnetization (TR > 5 T1), we can do an additional approximation by dropping the last term in \n\nEq. 2.2:M_z(TI) = C(1-2e^{- \\frac{TI}{T_1}})\n\nThe simplicity of the signal model described by \n\nEq. 2.3, both in its equation and experimental implementation, has made it the most widely used equation to describe the signal evolution in an inversion recovery T1 mapping experiment. The magnetization curves are plotted in \n\nFigure 2.2 for approximate T1 values of three different tissues in the brain. Note that in many practical implementations, magnitude-only images are acquired, so the signal measured would be proportional to the absolute value of \n\nEq. 2.3.\n\n\n\nFigure¬†2.2:Inversion recovery curves (\n\nEq. 2.2) for three different T1 values, approximating the main types of tissue in the brain.\n\nPractically, \n\nEq. 2.1 is the better choice for simulating the signal of an \n\ninversion recovery experiment, as the TRs are often chosen to be greater than 5 T1 of the tissue-of-interest, which rarely coincides with the longest T1 present (e.g. TR may be sufficiently long for white matter, but not for CSF which could also be present in the volume). \n\nEq. 2.3 also assumes ideal inversion pulses, which is rarely the case due to slice profile effects. \n\nFigure 2.3 displays the \n\ninversion recovery signal magnitude (complete relaxation normalized to 1) of an experiment with TR = 5 s and T1 values ranging between 250 ms to 5 s, calculated using both equations.\n\n\n\nFigure¬†2.3:Signal recovery curves simulated using \n\nEq. 2.3 (solid) and \n\nEq. 2.1 (dotted) with a TR = 5 s for T1 values ranging between 0.25 to 5 s.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.2.\n% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in seconds\n% All flip angles are in degrees\n\nparams.TR = 5.0;\nparams.TI = linspace(0.001, params.TR, 1000);\n            \nparams.TE = 0.004;\nparams.T2 = 0.040;\n            \nparams.EXC_FA = 90;  % Excitation flip angle\nparams.INV_FA = 180; % Inversion flip angle\n\nparams.signalConstant = 1;\n\n%% Calculate signals\n%\n% The option 'GRE-IR' selects the analytical equations for the\n% gradient echo readout inversion recovery experiment The option\n% '4' is a flag that selects the long TR approximation of the \n% analytical solution (TR>>T1), Eq. 3 of the blog post.\n%\n% To see all the options available, run:\n% `help inversion_recovery.analytical_solution`\n\n% White matter\nparams.T1 = 0.900; % in seconds\n\nsignal_WM = inversion_recovery.analytical_solution(params, 'GRE-IR', 4);\n\n% Grey matter\nparams.T1 = 1.500;  % in seconds\nsignal_GM = inversion_recovery.analytical_solution(params, 'GRE-IR', 4);\n\n% CSF\nparams.T1 = 4.000;  % in seconds\nsignal_CSF = inversion_recovery.analytical_solution(params, 'GRE-IR', 4);\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.3.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in seconds\n% All flip angles are in degrees\n\nparams.TR = 5.0;\nparams.TI = linspace(0.001, params.TR, 1000);\n            \nparams.TE = 0.004;\nparams.T2 = 0.040;\n            \nparams.EXC_FA = 90;  % Excitation flip angle\nparams.INV_FA = 180; % Inversion flip angle\n\nparams.signalConstant = 1;\n\nT1_range = 0.25:0.25:5; % in seconds\n\n%% Calculate signals\n%\n% The option 'GRE-IR' selects the analytical equations for the\n% gradient echo readout inversion recovery experiment. The option\n% '1' is a flag that selects full analytical solution equation \n% (no approximation), Eq. 1 of the blog post. The option '4' is a\n% flag that selects the long TR approximation of the analytical \n% solution (TR>>T1), Eq. 3 of the blog post.\n%\n% To see all the options available, run:\n% `help inversion_recovery.analytical_solution`\n\nfor ii = 1:length(T1_range)\n    params.T1 = T1_range(ii);\n    \n    signal_T1_Eq1{ii} = inversion_recovery.analytical_solution(params, 'GRE-IR', 1);\n\n    signal_T1_Eq3{ii} = inversion_recovery.analytical_solution(params, 'GRE-IR', 4);\nend","type":"content","url":"/t1-mapping#signal-modelling","position":5},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Data Fitting","lvl2":"Inversion Recovery T1 Mapping"},"type":"lvl3","url":"/t1-mapping#data-fitting","position":6},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Data Fitting","lvl2":"Inversion Recovery T1 Mapping"},"content":"Several factors impact the choice of the \n\ninversion recovery fitting algorithm.  If only magnitude images are available, then a polarity-inversion is often implemented to restore the non-exponential magnitude curves (\n\nFigure 2.3) into the \n\nexponential form (\n\nFigure 2.2). This process is sensitive to noise due to the \n\nRician noise creating a non-zero level at the signal null. If phase data is also available, then a phase term must be added to the fitting equation \n\nBarral et al., 2010. \n\nEquation 2.3 must only be used to fit data for the long TR regime (TR > 5 T1), which in practice is rarely satisfied for all tissues in subjects.\n\nEarly implementations of \n\ninversion recovery fitting algorithms were designed around the computational power available at the time. These included the ‚Äúnull method‚Äù \n\nPykett et al., 1983, assuming that each T1 value has unique zero-crossings (see \n\nFigure 2.2), and linear fitting of a rearranged version of \n\nEquation 2.3 on a semi-log plot \n\nFukushima, 1981. Nowadays, a \n\nnon-linear least-squares fitting algorithm (e.g. \n\nLevenberg-Marquardt) is more appropriate, and can be applied to either approximate or general forms of the signal model (\n\nEquation 2.3 or \n\nEquation 2.1). More recent work \n\nBarral et al., 2010 demonstrated that T1 maps can also be fitted much faster (up to 75 times compared to \n\nLevenberg-Marquardt) to fit  \n\nEquation 2.1 ‚Äì without a precision penalty ‚Äì by using a reduced-dimension \n\nnon-linear least-squares (RD-NLS) algorithm. It was demonstrated that the following simplified 5-parameter equation can be sufficient for accurate T1 mapping:S(TI) = a + be^{- \\frac{TI}{T_1}}\n\nwhere a and b are complex values. If magnitude-only data is available, a 3-parameter model can be sufficient by taking the absolute value of \n\nEquation 2.4.  While the RD-NLS algorithms are too complex to be presented here (the reader is referred to the paper, \n\nBarral et al., 2010),  the code for these algorithms \n\nwas released open-source along with the original publication, and is also available as a \n\nqMRLab T1 mapping model. One important thing to note about \n\nEquation 2.4 is that it is general ‚Äì no assumption is made about TR ‚Äì and is thus as robust as \n\nEquation 2.1 as long as all pulse sequence parameters other than TI are kept constant between each measurement. \n\nFigure 2.4 compares simulated data (\n\nEquation 2.1) using a range of TRs (1.5 T1 to 5 T1) fitted using either RD-NLS & \n\nEquation 2.4 or a \n\nLevenberg-Marquardt fit of \n\nEquation 2.2.\n\n\n\nFigure¬†2.4:Fitting comparison of simulated data (blue markers) with T1 = 1 s and TR = 1.5 to 5 s, using fitted using RD-NLS & \n\nEquation 2.4 (green) and \n\nLevenberg-Marquardt & \n\nEquation 2.2 (orange, long TR approximation).\n\nFigure 2.5 displays an example brain dataset from an inversion recovery experiment, along with the T1 map fitted using the RD-NLS technique.\n\n\n\nFigure¬†2.5:Example inversion recovery dataset of a healthy adult brain (left). Inversion times used to acquire this magnitude image dataset were 30 ms, 530 ms, 1030 ms, and 1530 ms, and the TR used was 1550 ms. The T1 map (right) was fitted using a RD-NLS algorithm.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.4.\n% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in milliseconds\n% All flip angles are in degrees\n\nparams.TI = 50:50:1500;\nTR_range = 1500:50:5000;\n\nparams.EXC_FA = 90;\nparams.INV_FA = 180;\n\nparams.T1 = 1000;\n\n%% Calculate signals\n%\n% The option 'GRE-IR' selects the analytical equations for the gradient echo readout inversion recovery experiment\n% The option '1' is a flag that selects full analytical solution equation (no approximation), Eq. 1 of the blog post.\n%\n% To see all the options available, run `help inversion_recovery.analytical_solution`\n\nfor ii = 1:length(TR_range)\n    params.TR = TR_range(ii);\n    Mz_analytical(ii,:) = inversion_recovery.analytical_solution(params, 'GRE-IR', 1);\nend\n\n%% Fit data using Levenberg-Marquardt with the long TR approximation equation\n%\n% The option '4' is a flag that selects the long TR approximation of the analytical solution (TR>>T1), Eq. 3 of the blog post.\n%\n% To see all the options available, run `help inversion_recovery.fit_lm`\n\n\nfor ii=1:length(TR_range)\n    fitOutput_lm{ii} = inversion_recovery.fit_lm(Mz_analytical(ii,:), params, 4);\n    T1_lm(ii) = fitOutput_lm{ii}.T1;\nend\n\n%% Fit data using the RDLS method (Barral), Eq. 4 of the blog post.\n%\n\n% Create a qMRLab inversion recovery model object and load protocol values\nirObj = inversion_recovery();\nirObj.Prot.IRData.Mat = params.TI';\n\nfor ii=1:length(TR_range)\n\n    data.IRData = Mz_analytical(ii,:);\n\n    fitOutput_barral{ii} = irObj.fit(data);\n\n    T1_barral(ii) = fitOutput_barral{ii}.T1;\n\nend\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.5.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\n\nclear all\n\n%% MATLAB/OCTAVE CODE\n\n% Load data into environment, and rotate mask to be aligned with IR data\nload('data/ir_dataset/IRData.mat');\nload('data/ir_dataset/IRMask.mat');\n\nIRData = data;\nMask = imrotate(Mask,180);\nclear data\n\n% Format qMRLab inversion_recovery model parameters, and load them into the Model object\nModel = inversion_recovery; \nTI = [30; 530; 1030; 1530];\nModel.Prot.IRData.Mat = [TI];\n\n% Format data structure so that they may be fit by the model\ndata = struct();\ndata.IRData= double(IRData);\ndata.Mask= double(Mask);\n\nFitResults = FitData(data,Model,0); % The '0' flag is so that no wait bar is shown.\n\n% Code used to re-orient the images to make pretty figures, and to assign variables with the axis lengths.\n\nT1_map = imrotate(FitResults.T1.*Mask,-90);\nxAxis = [0:size(T1_map,2)-1];\nyAxis = [0:size(T1_map,1)-1];\n\n% Raw MRI data at different TI values\nTI_0030 = imrotate(squeeze(IRData(:,:,:,1).*Mask),-90);\nTI_0530 = imrotate(squeeze(IRData(:,:,:,2).*Mask),-90);\nTI_1030 = imrotate(squeeze(IRData(:,:,:,3).*Mask),-90);\nTI_1530 = imrotate(squeeze(IRData(:,:,:,4).*Mask),-90);","type":"content","url":"/t1-mapping#data-fitting","position":7},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Inversion Recovery T1 Mapping"},"type":"lvl3","url":"/t1-mapping#benefits-and-pitfalls","position":8},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Inversion Recovery T1 Mapping"},"content":"The conventional \n\ninversion recovery experiment is considered the gold standard T1 mapping technique for several reasons:\n\nA typical protocol has a long TR value and a sufficient number of inversion times for stable fitting (typically 5 or more) covering the range [0, TR].\n\nIt offers a wide dynamic range of signals ([up to -kM_{0}, kM_{0}]), allowing a number of inversion times where high SNR is available to sample the signal recovery curve \n\nFukushima, 1981.\n\nT1 maps produced by \n\ninversion recovery are largely insensitive to inaccuracies in excitation flip angles and imperfect spoiling \n\nStikov et al., 2015, as all parameters except TI are constant for each measurement and only a single acquisition is performed (at TI) during each TR.\n\nOne important protocol design consideration is to avoid acquiring at inversion times where the signal for T1 values of the tissue-of-interest is nulled, as the magnitude images at this TI time will be dominated by \n\nRician noise which can negatively impact the fit under low SNR circumstances (\n\nFigure 2.6). Inversion recovery can also often be acquired using commonly available standard pulse sequences available on most MRI scanners by setting up a customized acquisition protocol, and does not require any additional calibration measurements. For an example, please visit the interactive preprint of the ISMRM Reproducible Research Group 2020 Challenge on inversion recovery T1 mapping \n\nBoudreau et al., 2023.\n\n\n\nFigure¬†2.6:\n\nMonte Carlo simulations (mean and standard deviation (STD), blue markers) and fitted T1 values (mean and STD, red and green respectively) generated for a T1 value of 900 ms and 5 TI values linearly spaced across the TR (ranging from 1 to 5 s). A bump in T1 STD occurs near TR = 3000 ms, which coincides with the TR where the second TI is located near a null point for this T1 value.\n\nDespite a widely acknowledged robustness for measuring accurate T1 maps, inversion recovery is not often used in studies. An important drawback of this technique is the need for long TR values, generally on the order of a few T1 for general models (e.g. Equations \n\nEq. 2.1 and \n\nEq. 2.4), and up to 5 T1 for long TR approximated models (\n\nEquation 2.3). It takes about to 10-25 minutes to acquire a single-slice T1 map using the inversion recovery technique, as only one TI is acquired per TR  (2-5 s) and conventional cartesian gradient readout imaging acquires one phase encode line per excitation (for a total of ~100-200 phase encode lines). The long acquisition time makes it challenging to acquire whole-organ T1 maps in clinically feasible protocol times. Nonetheless, it is useful as a reference measurement for comparisons against other T1 mapping methods, or to acquire a single-slice T1 map of a tissue to get T1 estimates for optimization of other pulse sequences.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.6.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in seconds\n% All flip angles are in degrees\n\nTR_range = 1000:100:5000; % in seconds\n\nx = struct;\nx.T1 = 900; % in seconds\n\nOpt.SNR = 25;\nOpt.M0 = 1;\nOpt.FAexcite = 90; % Excitation flip angle\nOpt.FAinv = 180;   % Inversion flip angle\n\n%% Monte Carlo data simulation\n% Simulate noisy signal data 1,000 time, fit the data, then calculate the means and standard deviations of the data and fitted T1\n% Data is calculated by calculating the a and b values of Eq. 4 from the full analytical equations (Eq. 1)\n\nModel = inversion_recovery; \n\nfor ii = 1:length(TR_range)\n    Opt.TR = TR_range(ii);\n    Opt.T1 = x.T1;\n    TI_lowres(ii,:) = linspace(0.05, Opt.TR, 6)';\n    Model.Prot.IRData.Mat = [TI_lowres(ii,:)];\n    [ra,rb] = Model.ComputeRaRb(x,Opt);\n    x.rb = rb;\n    x.ra = ra;\n    for jj = 1:1000\n        [FitResult{ii,jj}, noisyData{ii,jj}] = Model.Sim_Single_Voxel_Curve(x,Opt,0); \n        fittedT1(ii,jj) = FitResult{ii,jj}.T1;\n        noisyData_array(ii,jj,:) = noisyData{ii,jj}.IRData;\n    end\n        \n    for kk=1:length(TI_lowres(ii,:))\n        data_mean(ii,kk) = mean(noisyData_array(ii,:,kk));\n        data_std(ii,kk) = std(noisyData_array(ii,:,kk));\n    end\n    \n    T1_mean(ii) = mean(fittedT1(ii,:));\n    T1_std(ii) = std(fittedT1(ii,:));\nend\n\n%% Calculate the noiseless data at a higher TI resolution to plot the ideal signal curve.\n%\n\nfor ii = 1:length(TR_range)\n    TI_highres(ii,:) = linspace(0.05, TR_range(ii), 500);\n    Model.Prot.IRData.Mat = [TI_highres(ii,:)];\n    Opt.TR = TR_range(ii);\n    Opt.T1 = x.T1;\n    [ra,rb] = Model.ComputeRaRb(x,Opt);\n    x.rb = rb;\n    x.ra = ra;\n\n    data_noiseless(ii,:) = Model.equation(x);\nend","type":"content","url":"/t1-mapping#benefits-and-pitfalls","position":9},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Other Saturation-Recovery T1 Mapping techniques","lvl2":"Inversion Recovery T1 Mapping"},"type":"lvl3","url":"/t1-mapping#other-saturation-recovery-t1-mapping-techniques","position":10},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Other Saturation-Recovery T1 Mapping techniques","lvl2":"Inversion Recovery T1 Mapping"},"content":"Several variations of the \n\ninversion recovery pulse sequence were developed to overcome challenges like those specified above. Amongst them, the Look-Locker technique \n\nLook & Locker, 1970 stands out as one of the most widely used in practice. Instead of a single 90¬∞ acquisition per TR, a periodic train of small excitation pulses Œ∏ are applied after the inversion pulse, {\\theta_{180} ‚Äì ùõï ‚Äì Œ∏ ‚Äì ùõï ‚Äì Œ∏ ‚Äì ...}, where  ùõï = TR/n and n is the number of sampling acquisitions. This pulse sequence samples the inversion time relaxation curve much more efficiently than conventional \n\ninversion recovery, but at a cost of lower SNR. However, because the magnetization state of each TI measurement depends on the previous series of Œ∏ excitation, it has higher sensitivity to B1-inhomogeneities and imperfect spoiling compared to \n\ninversion recovery \n\nGai et al., 2013\n\nStikov et al., 2015. Nonetheless, Look-Locker is widely used for rapid T1 mapping applications, and variants like MOLLI (Modified Look-Locker Inversion recovery) and ShMOLLI (Shortened MOLLI) are widely used for cardiac T1 mapping \n\nMessroghli et al., 2004\n\nPiechnik et al., 2010.\n\nAnother \n\ninversion recovery variant that‚Äôs worth mentioning is saturation recovery, in which the inversion pulse is replaced with a saturation pulse: {\\theta_{90} ‚Äì TI ‚Äì \\theta_{90}}. This technique was used to acquire the very first T1 map \n\nPykett & Mansfield, 1978. Unlike \n\ninversion recovery, this pulse sequence does not need a long TR to recover to its initial condition; every \\theta_{90} pulse resets the longitudinal magnetization to the same initial state. However, to properly sample the recovery curve, TIs still need to reach the order of ~T1, the dynamic range of signal potential is cut in half ([0, M_{0}]), and the short TIs (which have the fastest acquisition times) have the lowest SNRs.","type":"content","url":"/t1-mapping#other-saturation-recovery-t1-mapping-techniques","position":11},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"Variable Flip Angle T1 Mapping"},"type":"lvl2","url":"/t1-mapping#vfaintroduction","position":12},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"Variable Flip Angle T1 Mapping"},"content":"Variable flip angle (VFA) \n\nT1 mapping \n\nChristensen et al., 1974\n\nFram et al., 1987\n\nGupta, 1977, also known as Driven Equilibrium Single Pulse Observation of \n\nT1 (DESPOT1) \n\nHomer & Beevers, 1985\n\nDeoni et al., 2003, is a rapid quantitative \n\nT1 measurement technique that is widely used to acquire 3D \n\nT1 maps (e.g. whole-brain) in a clinically feasible time. VFA estimates \n\nT1 values by acquiring multiple spoiled \n\ngradient echo acquisitions, each with different excitation flip angles (\\theta_{n} for n = 1, 2, .., N and \\theta_{i} ‚â† \\theta_{j}). The steady-state signal of this pulse sequence (\n\nFigure 2.7) uses very short TRs (on the order of magnitude of 10 ms) and is very sensitive to \n\nT1 for a wide range of flip angles.\n\nVFA is a technique that originates from the NMR field, and was adopted because of its time efficiency and the ability to acquire accurate \n\nT1 values simultaneously for a wide range of values \n\nChristensen et al., 1974\n\nGupta, 1977. For imaging applications, VFA also benefits from an increase in SNR because it can be acquired using a 3D acquisition instead of multislice, which also helps to reduce slice profile effects. One important drawback of VFA for \n\nT1 mapping is that the signal is very sensitive to inaccuracies in the flip angle value, thus impacting the \n\nT1 estimates.  In practice, the nominal flip angle (i.e. the value set at the scanner) is different than the actual flip angle experienced by the spins (e.g. at 3.0 T, variations of up to ¬±30%), an issue that increases with field strength. VFA typically requires the acquisition of another quantitative map, the transmit RF amplitude (B1+, or B1 for short), to calibrate the nominal flip angle to its actual value because of B1 inhomogeneities that occur in most loaded \n\nMRI coils \n\nSled & Pike, 1998. The need to acquire an additional B1 map reduces the time savings offered by VFA over saturation-recovery techniques, and inaccuracies/imprecisions of the B1 map are also propagated into the VFA \n\nT1 map \n\nBoudreau et al., 2017\n\nLee et al., 2017.\n\n\n\nFigure¬†2.7:Simplified pulse sequence diagram of a variable flip angle (VFA) pulse sequence with a gradient echo readout. TR: repetition time, \\theta_{n}: excitation flip angle for the nth measurement, IMG: image acquisition (k-space readout), SPOIL: spoiler gradient.","type":"content","url":"/t1-mapping#vfaintroduction","position":13},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Signal Modelling","lvl2":"Variable Flip Angle T1 Mapping"},"type":"lvl3","url":"/t1-mapping#signal-modelling-1","position":14},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Signal Modelling","lvl2":"Variable Flip Angle T1 Mapping"},"content":"The steady-state longitudinal magnetization of an ideal variable flip angle experiment can be analytically solved from the \n\nBloch equations for the spoiled \n\ngradient echo pulse sequence {\\theta_{n}‚ÄìTR}:M_{z}(\\theta_n) = M_0 \\frac{1-e^{- \\frac{TR}{T_1}}}{1-\\text{cos}(\\theta_n) e^{- \\frac{TR}{T_1}}} \\text{sin}(\\theta_n)\n\nwhere Mz is the longitudinal magnetization, M0 is the magnetization at thermal equilibrium, TR is the pulse sequence repetition time (\n\nFigure 2.7), and \\theta_{n} is the excitation flip angle. The Mz curves of different \n\nT1 values for a range of \\theta_{n} and TR values are shown in \n\nFigure 2.8.\n\n\n\nFigure¬†2.8:Variable flip angle technique signal curves (\n\nEq. 2.5) for three different \n\nT1 values, approximating the main types of tissue in the brain at 3T.\n\nFrom \n\nFigure 2.8, it is clearly seen that the flip angle at which the steady-state signal is maximized is dependent on the \n\nT1 and TR values. This flip angle is a well known quantity, called the \n\nErnst angle \n\nErnst & Anderson, 1966, which can be solved analytically from \n\nEq. 2.5 using properties of calculus:\\theta_{Ernst} = \\text{acos}(e^{- \\frac{TR}{T_1}})\n\nThe \n\nclosed-form solution (\n\nEq. 2.5) makes several assumptions which in practice may not always hold true if care is not taken. Mainly, it is assumed that the longitudinal magnetization has reached a steady state after a large number of TRs, and that the transverse magnetization is perfectly spoiled at the end of each TR. Bloch simulations ‚Äì a numerical approach at solving the \n\nBloch equations for a set of spins at each time point ‚Äì  provide a more realistic estimate of the signal if the number of repetition times is small (i.e. a steady-state is not achieved). As can be seen from \n\nFigure 2.9, the number of repetitions required to reach a steady state not only depends on \n\nT1, but also on the flip angle; flip angles near the Ernst angle need more TRs to reach a steady state. Preparation pulses or an outward-in \n\nk-space acquisition pattern are typically sufficient to reach a steady state by the time that the center of \n\nk-space is acquired, which is where most of the image contrast resides.\n\n\n\nFigure¬†2.9:Signal curves simulated using Bloch simulations (orange) for a number of repetitions ranging from 1 to 150, plotted against the ideal case (\n\nEq. 2.5 ‚Äì blue). Simulation details:  TR = 25 ms, T1 = 900 ms, 100 spins. Ideal spoiling was used for this set of Bloch simulations (transverse magnetization was set to 0 at the end of each TR).\n\nSufficient spoiling is likely the most challenging parameter to control for in a VFA experiment. A combination of both gradient spoiling and RF phase spoiling \n\nBernstein et al., 2004\n\nZur et al., 1991 are typically recommended (\n\nFigure 2.10). It has also been shown that the use of very strong  gradients, introduces diffusion effects (not considered in \n\nFigure 2.10), further improving the spoiling efficacy in the VFA pulse sequence \n\nYarnykh, 2010.\n\n\n\nFigure¬†2.10:Signal curves estimated using Bloch simulations for three categories of signal spoiling: (1) ideal spoiling (blue), gradient & RF Spoiling (orange), and no spoiling (green). Simulations details: TR = 25 ms, T1 = 900 ms, T2 = 100 ms, TE = 5 ms, 100 spins. For the ideal spoiling case, the transverse magnetization is set to zero at the end of each TR. For the gradient & RF spoiling case, each spin is rotated by different increments of phase (2ùúã / # of spins) to simulate complete decoherence from gradient spoiling, and the RF phase of the excitation pulse is  \\Phi_{n}=\\Phi_{n-1}+n\\Phi_{0}=1/2\\Phi_{0}\\left( n^{2}+n+2 \\right) \n\nBernstein et al., 2004 with \\Phi_{0} = 117¬∞ \n\nZur et al., 1991 after each TR.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.8.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in milliseconds\n% All flip angles are in degrees\n\nTR_range = 5:5:200;\n\nparams.EXC_FA = 1:90;\n\n%% Calculate signals\n%\n% To see all the options available, run `help vfa_t1.analytical_solution`\n\nfor ii = 1:length(TR_range)\n    params.TR = TR_range(ii);\n    \n    % White matter\n    params.T1 = 900; % in milliseconds\n\n    signal_WM(ii,:) = vfa_t1.analytical_solution(params);\n\n    % Grey matter\n    params.T1 = 1500;  % in milliseconds\n    signal_GM(ii,:) = vfa_t1.analytical_solution(params);\n\n    % CSF\n    params.T1 = 4000;  % in milliseconds\n    signal_CSF(ii,:) = vfa_t1.analytical_solution(params);\nend\n\n\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.9.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in milliseconds\n% All flip angles are in degrees\n\n% White matter\nparams.T1 = 900; % in milliseconds\nparams.T2 = 10000;\nparams.TR = 25;\nparams.TE = 5;\nparams.EXC_FA = 1:90;\nNex_range = 1:1:150;\n\n%% Calculate signals\n%\n% To see all the options available, run `help vfa_t1.analytical_solution`\n\nfor ii = 1:length(Nex_range)\n    params.Nex = Nex_range(ii);\n    \n    signal_analytical(ii,:) = vfa_t1.analytical_solution(params);\n\n    [~, complex_signal] = vfa_t1.bloch_sim(params);\n    signal_blochsim(ii,:) = abs(complex(complex_signal));\nend\n\n\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.10.\n% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in milliseconds\n% All flip angles are in degrees\n\n% White matter\nparams.T1 = 900; % in milliseconds\nparams.T2 = 100;\nparams.TR = 25;\nparams.TE = 5;\nparams.EXC_FA = 1:90;\nNex_range = [1:9, 10:10:100];\n\n%% Calculate signals\n%\n% To see all the options available, run `help vfa_t1.analytical_solution`\n\nfor ii = 1:length(Nex_range)\n    params.Nex = Nex_range(ii);\n    \n    params.crushFlag = 1;\n    \n    [~, complex_signal] = vfa_t1.bloch_sim(params);\n    signal_ideal_spoil(ii,:) = abs(complex_signal);\n    \n    \n    params.inc = 117;\n    params.partialDephasing = 1;\n    params.partialDephasingFlag = 1;\n    params.crushFlag = 0;\n    \n    [~, complex_signal] = vfa_t1.bloch_sim(params);\n    signal_optimal_crush_and_rf_spoil(ii,:) = abs(complex_signal);\n    \n    params.inc = 0;\n    params.partialDephasing = 0;\n\n    [~, complex_signal] = vfa_t1.bloch_sim(params);\n    signal_no_gradient_and_rf_spoil(ii,:) = abs(complex_signal);\nend","type":"content","url":"/t1-mapping#signal-modelling-1","position":15},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Data Fitting","lvl2":"Variable Flip Angle T1 Mapping"},"type":"lvl3","url":"/t1-mapping#vfadatafitting","position":16},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Data Fitting","lvl2":"Variable Flip Angle T1 Mapping"},"content":"At first glance, one could be tempted to fit VFA data using a \n\nnon-linear least squares fitting algorithm such as Levenberg-Marquardt with \n\nEq. 2.5, which typically only has two free fitting variables (\n\nT1 and M0). Although this is a valid way of estimating \n\nT1 from VFA data, it is rarely done in practice because a simple refactoring of \n\nEq. 2.5 allows \n\nT1 values to be estimated with a \n\nlinear least square fitting algorithm, which substantially reduces the processing time. Without any approximations, \n\nEq. 2.5 can be rearranged into the form \\textbf{y}=m\\textbf{x}+b  \n\nGupta, 1977:\\frac{S_n}{ \\text{sin}(\\theta_n)} = e^{- \\frac{TR}{T_1}} \\frac{S_n}{ \\text{tan}(\\theta_n)} + C (1-e^{- \\frac{TR}{T_1}})\n\nAs the third term does not change between measurements (it is constant for each \\theta_{n}), it can be grouped into the constant for a simpler representation:\\frac{S_n}{ \\text{sin}(\\theta_n)} = e^{- \\frac{TR}{T_1}} \\frac{S_n}{ \\text{tan}(\\theta_n)} + C\n\nWith this rearranged form of \n\nEq. 2.5, \n\nT1 can be simply estimated from the slope of a linear regression calculated from  S_{n}/\\text{sin}\\left( \\theta_{n}\\right) and S_{n}/\\text{tan}\\left( \\theta_{n}\\right) values:T_1 = - \\frac{TR}{ \\text{ln}(slope)}\n\nIf data were acquired using only two flip angles ‚Äì a very common VFA acquisition protocol ‚Äì then the slope can be calculated using the elementary slope equation. \n\nFigure 2.11 displays both Equations \n\nEq. 2.5 and \n\nEq. 2.8 plotted for a noisy dataset.\n\n\n\nFigure¬†2.11:Mean and standard deviation of the VFA signal plotted using the nonlinear form (\n\nEq. 2.5 ‚Äì blue) and linear form (\n\nEq. 2.8 ‚Äì red). Monte Carlo simulation details: SNR = 25, N = 1000. VFA simulation details: TR = 25 ms, T1 = 900 ms.\n\nThere are two important imaging protocol design considerations that should be taken into account when planning to use VFA: (1) how many and which flip angles to use to acquire VFA data, and (2) correcting inaccurate flip angles due to transmit RF field inhomogeneity. Most VFA experiments use the minimum number of required flip angles (two) to minimize acquisition time. For this case, it has been shown that the flip angle choice resulting in the best precision for VFA \n\nT1 estimates for a sample with a single \n\nT1 value (i.e. single tissue) are the two flip angles that result in 71% of the maximum possible steady-state signal (i.e. at the \n\nErnst angle) \n\nDeoni et al., 2003\n\nSchabel & Morrell, 2008.\n\nTime allowing, additional flip angles are often acquired at higher values and in between the two above, because greater signal differences between tissue \n\nT1 values are present there (e.g. \n\nFigure 2.8). Also, for more than two flip angles, Equations \n\nEq. 2.5 and \n\nEq. 2.8 do not have the same noise weighting for each fitting point, which may bias \n\nlinear least-square \n\nT1 estimates at lower SNRs. Thus, it has been recommended that low SNR data should be fitted with either \n\nEq. 2.5 using \n\nnon-linear least-squares (slower fitting) or with a weighted \n\nlinear least-square form of \n\nEq. 2.8 \n\nChang et al., 2008.\n\nAccurate knowledge of the flip angle values is very important to produce accurate \n\nT1 maps. Because of how the RF field interacts with matter \n\nSled & Pike, 1998, the excitation RF field (B1+, or B1 for short) of a loaded RF coil results in spatial variations in intensity/amplitude, unless RF shimming is available to counteract this effect (not common at clinical field strengths). For quantitative measurements like VFA which are sensitive to this parameter, the flip angle can be corrected (voxelwise) relative to the nominal value by multiplying it with a scaling factor (B1) from a B1 map that is acquired during the same session:\\theta_{corrected} = B_1 \\theta_{nominal}\n\nB1 in this context is normalized, meaning that it is unitless and has a value of 1 in voxels where the RF field has the expected amplitude (i.e. where the nominal flip angle is the actual flip angle). \n\nFigure 2.11 displays fitted VFA \n\nT1 values from a \n\nMonte Carlo dataset simulated using biased flip angle values, and fitted without/with B1 correction.\n\n\n\nFigure¬†2.11:Mean and standard deviations of fitted VFA \n\nT1 values for a set of \n\nMonte Carlo simulations (SNR = 100, N = 1000), simulated using a wide range of biased flip angles and fitted without (blue) or with (red) B1 correction. Simulation parameters: TR = 25 ms, T1 = 900 ms, \\theta_{nominal} = 6¬∞ and 32¬∞ (optimized values for this TR/T1 combination). Notice how even after B1 correction, fitted \n\nT1 values at B1 values far from the nominal case (B1 = 1) exhibit larger variance, as the actual flip angles of the simulated signal deviate from the optimal values for this TR/T1 (Deoni et al. 2003).\n\nFigure 2.12 displays an example VFA dataset and a B1 map in a healthy brain, along with the T1 map estimated using a linear fit (Equations \n\nEq. 2.8 and \n\nEq. 2.9).\n\n\n\nFigure¬†2.12:Example variable flip angle dataset and B1 map of a healthy adult brain (left). The relevant VFA protocol parameters used were: TR = 15 ms,  \\theta_{nominal} = 3¬∞ and 20¬∞. The T1 map (right) was fitted using a linear regression (Equations \n\nEq. 2.8 and \n\nEq. 2.9).\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.11.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in milliseconds\n% All flip angles are in degrees\n\nparams.EXC_FA = [1:4,5:5:90];\n\n%% Calculate signals\n%\n% To see all the options available, run `help vfa_t1.analytical_solution`\n\nparams.TR = 0.025;\nparams.EXC_FA = [2:9,10:5:90];\n\n% White matter\nx.M0 = 1;\nx.T1 = 0.900; % in milliseconds\n\nModel = vfa_t1; \n\nOpt.SNR = 25;\nOpt.TR = params.TR;\nOpt.T1 = x.T1;\n\nclear Model.Prot.VFAData.Mat(:,1) \nModel.Prot.VFAData.Mat = zeros(length(params.EXC_FA),2);\nModel.Prot.VFAData.Mat(:,1) = params.EXC_FA';\nModel.Prot.VFAData.Mat(:,2) = Opt.TR;\n\nfor jj = 1:1000\n    [FitResult{jj}, noisyData{jj}] = Model.Sim_Single_Voxel_Curve(x,Opt,0); \n    fittedT1(jj) = FitResult{jj}.T1;\n    noisyData_array(jj,:) = noisyData{jj}.VFAData;\n    noisyData_array_div_sin(jj,:) = noisyData_array(jj,:) ./ sind(Model.Prot.VFAData.Mat(:,1))';\n    noisyData_array_div_tan(jj,:) = noisyData_array(jj,:) ./ tand(Model.Prot.VFAData.Mat(:,1))';\nend\n        \nfor kk=1:length(params.EXC_FA)\n    data_mean(kk) = mean(noisyData_array(:,kk));\n    data_std(kk) = std(noisyData_array(:,kk));\n    \n    data_mean_div_sin(kk) = mean(noisyData_array_div_sin(:,kk));\n    data_std_div_sin(kk) = std(noisyData_array_div_sin(:,kk));\n    \n    data_mean_div_tan(kk) = mean(noisyData_array_div_tan(:,kk));\n    data_std_div_tan(kk) = std(noisyData_array_div_tan(:,kk));\nend\n\n\n%% Setup parameters\n% All times are in milliseconds\n% All flip angles are in degrees\n\nparams_highres.EXC_FA = [2:1:90];\n\n%% Calculate signals\n%\n% To see all the options available, run `help vfa_t1.analytical_solution`\n\nparams_highres.TR = params.TR * 1000; % in milliseconds\n    \n% White matter\nparams_highres.T1 = x.T1*1000; % in milliseconds\n\nsignal_WM = vfa_t1.analytical_solution(params_highres);\nsignal_WM_div_sin = signal_WM ./ sind(params_highres.EXC_FA);\nsignal_WM_div_tan = signal_WM ./ tand(params_highres.EXC_FA);\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.11.% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% Setup parameters\n% All times are in seconds\n% All flip angles are in degrees\n\nparams.TR = 0.025; % in seconds\n\n% White matter\nparams.T1 = 0.900; % in seconds\n\n% Calculate optimal flip angles for a two flip angle VFA experiment (for this T1 and TR)\n% The will be the nominal flip angles (the flip angles assumed by the \"user\", before a \n% \"realistic\"B1 bias is applied)\n\nnominal_EXC_FA = vfa_t1.find_two_optimal_flip_angles(params); % in degrees\ndisp('Nominal flip angles:')\ndisp(nominal_EXC_FA)\n\n% Range of B1 values biasing the excitation flip angle away from their nominal values\nB1Range = 0.1:0.1:2;\n\nx.M0 = 1;\nx.T1 = params.T1; % in seconds\n\nModel = vfa_t1; \n\nOpt.SNR = 100;\nOpt.TR = params.TR;\nOpt.T1 = x.T1;\n\n% Monte Carlo signal simulations\nfor ii = 1:1000\n    for jj = 1:length(B1Range)\n        B1 = B1Range(jj);\n        actual_EXC_FA = B1 * nominal_EXC_FA;\n \n        params.EXC_FA = actual_EXC_FA;\n\n        clear Model.Prot.VFAData.Mat(:,1)\n        Model.Prot.VFAData.Mat = zeros(length(params.EXC_FA),2);\n        Model.Prot.VFAData.Mat(:,1) = params.EXC_FA';\n        Model.Prot.VFAData.Mat(:,2) = Opt.TR;\n\n        [FitResult{ii,jj}, noisyData{ii,jj}] = Model.Sim_Single_Voxel_Curve(x,Opt,0); \n        noisyData_array(ii,jj,:) = noisyData{ii,jj}.VFAData;\n    end\nend\n%\nModel = vfa_t1; \n    \nFlipAngle = nominal_EXC_FA';\nTR = params.TR .* ones(size(FlipAngle));\n\nModel.Prot.VFAData.Mat = [FlipAngle TR];\n\ndata.VFAData(:,:,1,1) = noisyData_array(:,:,1);\ndata.VFAData(:,:,1,2) = noisyData_array(:,:,2);\ndata.Mask = repmat(ones(size(B1Range)),[size(noisyData_array,1),1]);\n\ndata.B1map = repmat(ones(size(B1Range)),[size(noisyData_array,1),1]);\nFitResults_noB1Correction = FitData(data,Model,0);\n\ndata.B1map = repmat(B1Range,[size(noisyData_array,1),1]);\nFitResults_withB1Correction = FitData(data,Model,0);\n\n%%\n%\n\nmean_T1_noB1Correction = mean(FitResults_noB1Correction.T1);\nmean_T1_withB1Correction = mean(FitResults_withB1Correction.T1);\nstd_T1_noB1Correction = std(FitResults_noB1Correction.T1);\nstd_T1_withB1Correction = std(FitResults_withB1Correction.T1);\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 2.12.\n% Verbosity level 0 overrides the disp function and supresses warnings.\n% Once executed, they cannot be restored in this session\n% (kernel needs to be restarted or a new notebook opened.)\nVERBOSITY_LEVEL = 0;\n\nif VERBOSITY_LEVEL==0\n    % This hack was used to supress outputs from external tools\n    % in the Jupyter Book.\n    function disp(x)\n    end\n    warning('off','all')\nend\n\ntry\n    cd qMRLab\ncatch\n    try\n        cd ../../../qMRLab\n    catch\n        cd ../qMRLab\n    end\nend\n\nstartup\nclear all\n\n%% MATLAB/OCTAVE CODE\n\n% Load data into environment, and rotate mask to be aligned with IR data\nload('data/vfa_dataset/VFAData.mat');\nload('data/vfa_dataset/B1map.mat');\nload('data/vfa_dataset/Mask.mat');\n\n% Format qMRLab vfa_t1 model parameters, and load them into the Model object\nModel = vfa_t1; \nFlipAngle = [    3;     20];\nTR        = [0.015; 0.0150];\n\nModel.Prot.VFAData.Mat = [FlipAngle, TR];\n\n% Format data structure so that they may be fit by the model\ndata = struct();\ndata.VFAData= double(VFAData);\ndata.B1map= double(B1map);\ndata.Mask= double(Mask);\n\nFitResults = FitData(data,Model,0); % The '0' flag is so that no wait bar is shown.\n\nT1_map = imrotate(FitResults.T1.*Mask,-90);\nT1_map(T1_map>5)=0;\nT1_map = T1_map*1000; % Convert to ms\n\nxAxis = [0:size(T1_map,2)-1];\nyAxis = [0:size(T1_map,1)-1];\n\n% Raw MRI data at different TI values\nFA_03 = imrotate(squeeze(VFAData(:,:,:,1).*Mask),-90);\nFA_20 = imrotate(squeeze(VFAData(:,:,:,2).*Mask),-90);\nB1map = imrotate(squeeze(B1map.*Mask),-90);","type":"content","url":"/t1-mapping#vfadatafitting","position":17},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Variable Flip Angle T1 Mapping"},"type":"lvl3","url":"/t1-mapping#benefits-and-pitfalls-1","position":18},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Variable Flip Angle T1 Mapping"},"content":"It has been well reported in recent years that the accuracy of VFA \n\nT1 estimates is very sensitive to pulse sequence implementations \n\nBaudrexel et al., 2017\n\nLutti & Weiskopf, 2013\n\nStikov et al., 2015, and as such is less robust than the gold standard inversion recovery technique. In particular, the signal bias resulting from insufficient spoiling can result in inaccurate \n\nT1 estimates of up to 30% relative to inversion recovery estimated values \n\nStikov et al., 2015. VFA \n\nT1 map accuracy and precision is also strongly dependent on the quality of the measured B1 map \n\nLee et al., 2017, which can vary substantially between implementations \n\nBoudreau et al., 2017. Modern rapid B1 mapping pulse sequences are not as widely available as VFA, resulting in some groups attempting alternative ways of removing the bias from the \n\nT1 maps like generating an artificial B1 map through the use of image processing techniques \n\nLiberman et al., 2013 or omitting B1 correction altogether \n\nYuan et al., 2012. The latter is not recommended, because most MRI scanners have default pulse sequences that, with careful protocol settings, can provide B1 maps of sufficient quality very rapidly \n\nBoudreau et al., 2017\n\nSamson et al., 2006\n\nWang et al., 2005.\n\nDespite some drawbacks, VFA is still one of the most widely used \n\nT1 mapping methods in research. Its rapid acquisition time, rapid image processing time, and widespread availability makes it a great candidate for use in other quantitative imaging acquisition protocols like quantitative magnetization transfer imaging \n\nCercignani et al., 2005\n\nYarnykh, 2002 and dynamic contrast enhanced imaging \n\nLi et al., 2018\n\nSung et al., 2013.","type":"content","url":"/t1-mapping#benefits-and-pitfalls-1","position":19},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"MP2RAGE"},"type":"lvl2","url":"/t1-mapping#mp2rageintroduction","position":20},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"MP2RAGE"},"content":"Dictionary-based MRI techniques capable of generating T1 maps are increasing in popularity, due to their growing availability on clinical scanners, rapid scan times, and fast post-processing computation time, thus making quantitative T1 mapping accessible for clinical applications. Generally speaking, dictionary-based quantitative MRI techniques use numerical dictionaries‚Äîdatabases of pre-calculated signal values simulated for a wide range of tissue and protocol combinations‚Äîduring the image reconstruction or post-processing stages. Popular examples of dictionary-based techniques that have been applied to T1 mapping are MR Fingerprinting (MRF) \n\nMa et al., 2013, certain flavours of compressed sensing (CS) \n\nDoneva et al., 2010\n\nLi et al., 2012, and Magnetization Prepared 2 Rapid Acquisition Gradient Echoes (MP2RAGE) \n\nMarques et al., 2010. Dictionary-based techniques can usually be classified into one of two categories: techniques that use information redundancy from parametric data to assist in accelerated imaging (e.g. CS, MRF), or those that use dictionaries to estimate quantitative maps using the MR images after reconstruction. Because MP2RAGE is a technique implemented primarily for T1 mapping, and it is becoming increasingly available as a standard pulse sequence on many MRI systems, the remainder of this section will focus solely on this technique. However, many concepts discussed are shared by other dictionary-based techniques.\n\nMP2RAGE is an extension of the conventional MPRAGE pulse sequence widely used in clinical studies \n\nHaase et al., 1989\n\nMugler & Brookeman, 1990. A simplified version of the MP2RAGE pulse sequence is shown in \n\nFigure 2.13. MP2RAGE can be seen as a hybrid between the inversion recovery and VFA pulse sequences: a 180¬∞ inversion pulse is used to prepare the magnetization for T1 sensitivity at the beginning of each TRMP2RAGE, and then two images are acquired at different inversion times using gradient recalled echo (GRE) imaging blocks with low flip angles and short repetition times (TR). During a given GRE imaging block, each excitation pulse is followed by a constant in-plane (‚Äúy‚Äù) phase encode weighting (varied for each TRMP2RAGE), but with different 3D (‚Äúz‚Äù) phase encoding gradients (varied at each TR). The center of k-space for the 3D phase encoding direction is acquired at the TI for each GRE imaging block. The main motivation for developing the MP2RAGE pulse sequence was to provide a metric similar to MPRAGE, but with self-bias correction of the static (B0) and receive (B1-) magnetic fields, and a first order correction of the transmit magnetic field (B1+). However, because two images at different TIs are acquired (unlike MPRAGE, which only acquires data at a single TI), information about the T1 values can also be inferred, thus making it possible to generate quantitative T1 maps using this data.\n\n\n\nFigure¬†2.13:Simplified diagram of an MP2RAGE pulse sequence. TR: repetition time between successive gradient echo readouts, TRMP2RAGE: repetition time between successive adiabatic 180¬∞ inversion pulses, TI1 and TI2: inversion times, \\theta_{1} and \\theta_{2}: excitation flip angles. The imaging readout events occur within each TR using a constant in-plane phase encode (‚Äúy‚Äù) gradient set for each TRMP2RAGE, but varying 3D phase encode (‚Äúz‚Äù) gradients between each successive TR.","type":"content","url":"/t1-mapping#mp2rageintroduction","position":21},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Signal Modelling","lvl2":"MP2RAGE"},"type":"lvl3","url":"/t1-mapping#signal-modelling-2","position":22},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Signal Modelling","lvl2":"MP2RAGE"},"content":"Prior to considering the full signal equations, we will first introduce the equation for the MP2RAGE parameter (SMP2RAGE) that is calculated in addition to the T1 map. For complex data (magnitude and phase, or real and imaginary), the MP2RAGE signal (SMP2RAGE) is calculated from the images acquired at two TIs (SGRE,TI1 and SGRE,TI2) using the following expression \n\nMarques et al., 2010:S_{\\text{MP2RAGE}}=\\text{real}\\left( \\frac{S_{\\text{GRE}_{\\text{TI}_{1}}}^{\\ast}S_{\\text{GRE}_{\\text{TI}_{2}}}^{\\ast}}{\\left| S_{\\text{GRE}_{\\text{TI}_{1}}} \\right|^{2}+ \\left| S_{\\text{GRE}_{\\text{TI}_{2}}} \\right|^{2}} \\right)\n\nThis value is bounded between [-0.5, 0.5], and helps reduce some B0 inhomogeneity effects using the phase data. For real data, or magnitude data with polarity restoration, this metric is instead calculated as:S_{\\text{MP2RAGE}}=\\text{real}\\left( \\frac{S_{\\text{GRE}_{\\text{TI}_{1}}}^{\\ast}S_{\\text{GRE}_{\\text{TI}_{2}}}^{\\ast}}{S_{\\text{GRE}_{\\text{TI}_{1}}}^{2}+ S_{\\text{GRE}_{\\text{TI}_{2}}}^{2}} \\right)\n\nBecause MP2RAGE is a hybrid of pulse sequences used for inversion recovery and VFA, the resulting signal equations are more complex. Typically, a steady state is not achieved during the short train of GRE imaging blocks, so the signal at the center of k-space for each readout (which defines the contrast weighting) will depend on the number of phase-encoding steps. For simplicity, the equations presented here assume that the 3D phase-encoding dimension is fully sampled (no partial Fourier or parallel imaging acceleration). For this case (see appendix of \n\nMarques et al., 2010 for derivation details), the signal equations are:\\begin{split}\nS_{\\text{GRE}_{\\text{TI}_{1}}}=&B_{1}^{-}e^{-\\text{TE}/T_{2}^{\\ast }}M_{0}\\text{sin}\\left( \\theta_{1} \\right) \\\\\n&\\times \\Bigg[ \\left( \\frac{-\\text{eff}m_{z,ss}}{M_{0}}\\text{EA}+\\left( 1-\\text{EA} \\right) \\right)\\left( \\text{cos}\\left( \\theta_{1} \\right) \\text{ER} \\right)^{n/2-1}\\\\\n&\\quad\\quad+\\left( 1-\\text{ER} \\right) \\frac{1-\\left( \\text{cos}\\left( \\theta_{1} \\right)\\text{ER} \\right)^{n/2-1}}{1-\\text{cos}\\left( \\theta_{1} \\right)\\text{ER}} \\Bigg] \n\\end{split}\\begin{split}\nS_{\\text{GRE}_{\\text{TI}_{2}}}=&B_{1}^{-}e^{-\\text{TE}/T_{2}^{\\ast }}M_{0}\\text{sin}\\left( \\theta_{2} \\right) \\\\\n&\\times \\Bigg[\\frac{ \\frac{m_{z,ss}}{M_{0}}\\text{EA}+\\left( 1-\\text{EC} \\right)}{\\text{EC}\\left( \\text{cos}\\left( \\theta_{2} \\right)\\text{ER} \\right)^{n/2}}-\\left( 1-\\text{ER} \\right)\\frac{\\left( \\text{cos}\\left( \\theta_{2} \\right)\\text{ER} \\right)^{-n/2}-1 }{1-\\text{cos}\\left( \\theta_{2} \\right)\\text{ER} } \\Bigg] \n\\end{split}\n\nwhere B1- is the receive field sensitivity, ‚Äúeff‚Äù is the adiabatic inversion pulse efficiency, ER=exp(-TR/T1), EA=exp(-TA/T1), EB=exp(-TB/T1), EC=exp(-TC/T1). The variables TA, TB, and TC are the three different delay times (TA: time between inversion pulse and beginning of the GRE1 block, TB: time between the end of GRE1 and beginning of GRE2, TC: time between the end of GRE2 and the end of the TR). If no k-space acceleration is used (e.g. no partial Fourier or parallel imaging acceleration), then these values are TA = TI1 - (n/2)TR, TB = TI2 - (TI1 + nTR), and TC = TRMP2RAGE - (TI1 + (n/2)TR), where n is the number of voxels acquired in the 3D phase encode direction varied within each GRE block. The value mz,ss is the steady-state longitudinal magnetization prior to the inversion pulse, and is given by:m_{z,ss}\\frac{M_{0}\\left[ \\beta\\left( \\text{cos}\\left( \\theta_{2} \\right)\\text{ER} \\right)^{n}+\\left( 1-\\text{ER} \\right)\\frac{1-\\left( \\text{cos}\\left( \\theta_{2} \\right)\\text{ER} \\right)^{n}}{1-\\text{cos}\\left( \\theta_{2} \\right)\\text{ER} } \\right]\\text{EC+}\\left( 1- \\text{EC}\\right)}{1+\\text{eff}\\left( \\text{cos}\\left( \\theta_{1} \\right) \\text{cos}\\left( \\theta_{2} \\right) \\right)^{n}e^{-TR_{\\text{MP2RAGE}}/T_{1}}}\\beta=\\bigg( \\left( 1-\\text{EA} \\right) \\left( \\text{cos}\\left( \\theta_{1}\\right)\\text{ER}  \\right)^{n}+\\left( 1-\\text{ER} \\right)\\frac{1-\\left( \\text{cos}\\left( \\theta_{1}\\right)\\text{ER}  \\right)^{n}}{1-\\text{cos}\\left( \\theta_{1}\\right)\\text{ER}  }\\bigg)\\text{EB}+\\left( 1-\\text{EB} \\right)\n\nFrom Equations \n\n2.13, \n\n2.14, \n\n2.15, and \n\n2.16, it is evident that the MP2RAGE parameter SMP2RAGE (Equations \n\n2.11, \n\n2.12) cancels out the effects of receive field sensitivity, T2*, and M0. The signal sensitivity related to the transmit field (B1+), hidden in Equations \n\n2.13, \n\n2.14, \n\n2.15, and \n\n2.16 within the flip angle values \\theta_{1} and \\theta_{2}, can also be reduced by careful pulse sequence protocol design \n\nMarques et al., 2010, but not entirely eliminated \n\nMarques & Gruetter, 2013.","type":"content","url":"/t1-mapping#signal-modelling-2","position":23},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Data Fitting","lvl2":"MP2RAGE"},"type":"lvl3","url":"/t1-mapping#data-fitting-1","position":24},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Data Fitting","lvl2":"MP2RAGE"},"content":"Dictionary-based techniques such as MP2RAGE do not typically use conventional minimization algorithms (e.g. \n\nLevenberg-Marquardt to fit signal equations to observed data. Instead, the MP2RAGE technique uses pre-calculated signal values for a wide range of parameter values (e.g. T1), and then interpolation is done within this dictionary of values to estimate the T1 value that matches the observed signal. This approach results in rapid post-processing times because the dictionaries can be simulated/generated prior to scanning and interpolating between these values is much faster than most fitting algorithms. This means that the quantitative image can be produced and displayed directly on the MRI scanner console rather than needing to be fitted offline.\n\n\n\nFigure¬†2.14:T1 lookup table as a function of T1 and SMP2RAGE value. Inversion times used to acquire this magnitude image dataset were 800 ms and 2700 ms, the flip angles were 4¬∞ and 5¬∞ (respectively),  TRMP2RAGE = 6000 ms, and TR = 6.7 ms. The code that was used were shared open sourced by the authors of the original MP2RAGE paper \n\nMarques, 2017.\n\nTo produce T1 maps with good accuracy and precision using dictionary-based interpolation methods, it is important that the signal curves are unique for each parameter value. MP2RAGE can produce good T1 maps by using a dictionary with only dimensions (T1, SMP2RAGE), since SMP2RAGE is unique for each T1 value for a given protocol \n\nMarques et al., 2010. However, as was noted above, SMP2RAGE is also sensitive to B1 because of \\theta_{1} and \\theta_{2} in  Equations \n\n2.13, \n\n2.14, \n\n2.15, and \n\n2.16. The  B1-sensitivity can be reduced substantially with careful MP2RAGE protocol optimization \n\nMarques et al., 2010, and further improved by including B1 as one of the dictionary dimensions [T1, B1, SMP2RAGE] (\n\nFigure 2.14).  This requires an additional acquisition of a B1 map \n\nMarques & Gruetter, 2013, which lengthens the scan time.\n\n\n\nFigure¬†2.15:Example MP2RAGE dataset of a healthy adult brain at 7T and T1 map. Inversion times used to acquire this magnitude image dataset were 800 ms and 2700 ms, the flip angles were 4¬∞ and 5¬∞ (respectively),  TRMP2RAGE = 6000 ms, and TR = 6.7 ms. The dataset and code that was used were shared open sourced by the authors of the original MP2RAGE paper \n\nMarques, 2017.\n\nThe MP2RAGE pulse sequence is increasingly being distributed by MRI vendors, thus typically a data fitting package is also available to reconstruct the T1 maps online. Alternatively, several open source packages to create T1 maps from MP2RAGE data are available online \n\nMarques, 2017\n\nHollander, 2017, and for new users these are recommended‚Äîas opposed to programming one from scratch‚Äîas there are many potential pitfalls (e.g. adjusting the equations to handle partial Fourier or parallel imaging acceleration).","type":"content","url":"/t1-mapping#data-fitting-1","position":25},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"MP2RAGE"},"type":"lvl3","url":"/t1-mapping#benefits-and-pitfalls-2","position":26},{"hierarchy":{"lvl1":"T1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"MP2RAGE"},"content":"This widespread availability and its turnkey acquisition/fitting procedures are a main contributing factor to the growing interest for including quantitative T1 maps in clinical and neuroscience studies. T1 values measured using MP2RAGE showed  high levels of reproducibility for the brain in an inter- and intra-site study at eight sites (same MRI hardware/software and at 7 T) of two subjects \n\nVoelker et al., 2016. Not only does MP2RAGE have one of the fastest acquisition and post-processing times among quantitative T1 mapping techniques, but it can accomplish this while acquiring very high resolution T1 maps (1 mm isotropic at 3T and submillimeter at 7T, both in under 10 min \n\nFujimoto et al., 2014), opening the doors to cortical studies which greatly benefit from the smaller voxel size \n\nWaehnert et al., 2014\n\nBeck et al., 2018\n\nHaast et al., 2018.\n\nDespite these benefits, MP2RAGE and similar dictionary-based techniques have certain limitations that are important to consider before deciding to incorporate them in a study. Good reproducibility of the quantitative T1 map is dependent on using one pre-calculated dictionary. If two different dictionaries are used (e.g. cross-site with different MRI vendors), the differences in the dictionary interpolations will likely result in minor differences in T1 estimates for the same data. Also, although the B1-sensitivity of the MP2RAGE T1 maps can be reduced with proper protocol optimization, it can be substantial enough that further correction using a measured B1 map should be done \n\nMarques & Gruetter, 2013\n\nHaast et al., 2018. However B1 mapping brings an additional potential source of error, so carefully selecting a B1 mapping technique and accompanying post-processing method (e.g. filtering) should be done before integrating it in a T1 mapping protocol \n\nBoudreau et al., 2017. Lastly, the MP2RAGE equations (and thus, dictionaries) assume monoexponential longitudinal relaxation, and this has been shown to result in suboptimal estimates of the long T1 component for a biexponential relaxation model \n\nRioux et al., 2016, an effect that becomes more important at higher fields.","type":"content","url":"/t1-mapping#benefits-and-pitfalls-2","position":27},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"Exercises"},"type":"lvl2","url":"/t1-mapping#exercises","position":28},{"hierarchy":{"lvl1":"T1 Mapping","lvl2":"Exercises"},"content":"a. Using the Plotly figure in the \n\ninversion recovery section that displays the signal curves for white matter, gray matter, and CSF, determine the inversion times that null the signal from each of these tissues.\n\nb. In practice, you may not have this type of interactive figure at the scanner. Using the three values nulling inversion time values above, can you find an easy way to approximate the nulling time for any arbitrary T1 value?\n\nc. Assuming that the images acquired at the MRI scanner displays magnitude-only images, at approximately which inversion time will the white matter and grey matter have the lowest contrast?\n\nd. Which inversion time would result in the best contrast between white matter and grey matter?\n\na. Using the Plotly figure in the \n\nVFA section that displays the signal curves for white matter, gray matter, and CSF, determine the Ernst angle for the following: white matter and a TR of 15 ms, gray matter for a TR of 50 ms, and CSF for a TR of 140 ms.\n\nb. Calculate the Ernst angle for these tissues and TRs with \n\nEq. 2.6. Are they in agreement with the values you estimated with the interactive figure?\n\nc. It‚Äôs been shown (Deoni, Rutt, and Peters 2003) that the optimal flip angles for a two-measurement VFA T1 mapping imaging protocol are located at approximately 70% of the Ernst angle. Find the optimal flip angles to image each tissue above using their respective TRs.\n\nd. For a TR of 30 ms, which flip angle would result in the best contrast between white matter and grey matter in an SPGR image?\n\na. The IR signal curves for WM/GM/CSF in \n\nFigure 2.3 were simulated for 3T T1 tissue values. Using Binder and the notebook that was used to generate that blog post, regenerate that figure for T1 values at 1.5 T (WM ~ 650 ms and GM ~ 1200 ms as reported by (Wright et al. 2008)). Assume the CSF value does not change.\n\nb. An IR T1 mapping pulse sequence that a previous student developed and is available at the MRI scanner has a fixed TR of 3 seconds. Could you use a data analysis pipeline that only has the long-TR IR T1 fitting option available to map T1 in WM, at 1.5T and/or 3T? Show this visually via simulations.\n\nc. Are there any inversion times you should avoid using when designing an IR T1 mapping protocol at 1.5T when using this TR? If so, demonstrate why and which one(s) using modified code from one of these notebook figures.\n\nImagine you‚Äôre a graduate student in a lab that recently transitioned from human imaging to animal imaging (specifically, mouse models of multiple sclerosis). Because there has never been MRI data acquired in your lab in mouse, your advisor asks you to acquire T1 maps of some healthy mice to get the an estimate of T1 values in white matter so that you can use this value to optimize other pulse sequence protocols (eg protocol parameters for T1-weighted images, optimal flip angle for spoiled gradient angle SNR, etc). You do some literature search and find a paper that measured T1 in mice (Kuo et al. 2005), but using a different pulse sequence.\n\na. Using qMRLab, determine if the IR imaging protocol (TR = 1000 ms , TI = [100, 300, 600, 900] ms) you used for your previous human study at 1.5 T (where WM has a T1 of ~600ms) would yield good results if applied to mice (at 9.4 T, (Kuo et al. 2005) reports a WM T1 of ~1700 ms). Assume an SNR of 100. Explain how you‚Äôve reached your conclusion.\n\nb. If the human T1 mapping 1.5T protocol is not appropriate to image mice at 9.4T, explain via written arguments why this might be the case. Use simulation figures to support your arguments.\n\nc. Propose a new protocol that might yield more precise and/or accurate T1 maps. Why did you make those changes? How did you determine the improvement?\n\nFind an open-source tool besides qMRLab that also has a VFA (also known as DESPOT1) fitting feature. Using simulated signal (with noise) and the qMRLab demo VFA human brain dataset, compare and contrast the T1 maps fitted using qMRLab and the other software chosen. Provide insights on the usability of both software, the reproducibility of the VFA T1 map using these data, and a comparison of both code (only API and the fitting algorithm for VFA). If you were to write your own VFA fitting software, what would do similar to either (or both) of these software packages. What would you do differently?\n\nYou receive an email from a collaborator in your city asking for help with a T1 dataset they acquired on their new 3T scanner. They tried fitting the data with qMRLab already, but are getting T1 values in the brain that are beyond the expected values (eg, WM: 2000ms, GM, 5000 ms). They send you their acquired data.\n\na. Fit a T1 map using their data and plot a few voxel signal curves.\n\nb. Luckily, you own a standardized quantitative MRI NIST phantom with known T1 values, and are able to go to your collaborators scanner to acquire a dataset using their protocol. Here is data you acquired for a region of the phantom with a known T1 value (900 ms +- 5ms) close to the expected WM values. Plot that data, and simulate the expected signal curve for this T1 value\n\nc. Comparing the human and phantom data and the simulated curves, what do you notice? What do you think may be the problem?\n\nd. Test your proposed problem with some of your simulation code.\n\ne. What would you propose to your collaborator? Is a new data acquisition protocol required, or can you provide some post-processing corrections prior to fitting the  data?\n\nYou are currently in charge of a longitudinal study that uses VFA to acquire T1 maps. After an MRI scanner software upgrade, your T1 maps suddenly changed values substantially. Here is one of your old (good) datasets (link), and one of your new (bad) datasets. Using qMRLab, find what you suspect the problem is. Do you think a post-processing correction can be applied, or would an adjustment to the imaging protocol and new data acquisitions be needed?\n\nIn this module, we presented methodology on how to fit data acquired using a SPGR pulse sequence for a fixed TR and varying the flip angle (VFA). One could also suggest to fix the flip angle and acquire data by varying TR and then fit for T1 (let‚Äôs call this VTR). Explore this idea analytically and numerically. What would be some advantages and disadvantages to VTR? Would you need as many, or more acquisition? Is VTR sensitive to B1?\n\nIn this module, we presented methodology on how to fit data acquired using an inversion recovery pulse sequence for a fixed TR and inversion time. As with the previous question, explore the idea of fixing the inversion time and varying TR to fit T1 maps.","type":"content","url":"/t1-mapping#exercises","position":29},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-3-1-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"03-T2\"\ndata_file = \"T2w_vs_T2map.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n# Get MATLAB data\nT2_map = mat_contents['T2_map']\nTE_1 = mat_contents['TE_1']\nTE_2 = mat_contents['TE_2']\nTE_3 = mat_contents['TE_3']\nTE_4 = mat_contents['TE_4']\n\n# Crop the images so that the brain is centered on the figure\nT2_map = T2_map[:-100, :]\nTE_1 = TE_1[:-100, :]\nTE_2 = TE_2[:-100, :]\nTE_3 = TE_3[:-100, :]\nTE_4 = TE_4[:-100, :]\n\n## Plot\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom chart_studio.plotly import plot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\n\nconfig={'showLink': False, 'displayModeBar': False}\n\nxAxis = np.arange(0, T2_map.shape[1])\nyAxis = np.arange(0, T2_map.shape[0])\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(TE_1),\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(TE_2),\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal')\ntrace3 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(TE_3),\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=True,\n                   name = 'Signal')\ntrace4 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(TE_4),\n                   colorscale='Gray',\n                   visible=False,\n                   showscale = False,\n                   name = 'Signal')\ntrace5 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(T2_map),\n                   colorscale='Portland',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'T1 values (ms)',\n                   zmin=100, \n                   zmax=200,)\n\n\ndata=[trace1, trace2, trace3, trace4, trace5]\n\nupdatemenus = list([\n    dict(active=2,\n         x = 0.12,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = '12.8 ms',\n                 method = 'update',\n                 args = [{'visible': [True, False, False, False, True]},\n                         ]),\n            dict(label = '128 ms',\n                 method = 'update',\n                 args = [{'visible': [False, True, False, False, True]},\n                         ]),\n            dict(label = '256 ms',\n                 method = 'update',\n                 args = [{'visible': [False, False, True, False, True]},\n                         ]),\n            dict(label = '384 ms',\n                 method = 'update',\n                 args = [{'visible': [False,False, False, True, True]},\n                         ])\n        ]),\n    )\n])\n\nlayout = dict(\n    width=728,\n    height=448.5,\n    margin = dict(\n                t=90,\n                r=140,\n                b=90,\n                l=30),\n    annotations=[\n        dict(\n            x=0.13,\n            y=1.15,\n            showarrow=False,\n            text='T2w images',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.82,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>2</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.17,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>2</sub> (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.02,\n            y=-0.15,\n            showarrow=False,\n            text='TE:',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(range=[0, xAxis[-1]], autorange=False,\n               showgrid=False, zeroline=False, showticklabels=False,\n               ticks='', domain=[0, 0.5]),  # First plot domain\n    yaxis=dict(range=[0, yAxis[-1]], autorange=False,\n               showgrid=False, zeroline=False, showticklabels=False,\n               ticks='', domain=[0, 1]),\n    xaxis2=dict(range=[0, xAxis[-1]], autorange=False,\n                showgrid=False, zeroline=False, showticklabels=False,\n                ticks='', domain=[0.5, 1]),  # Second plot domain\n    yaxis2=dict(range=[0, yAxis[-1]], autorange=False,\n                showgrid=False, zeroline=False, showticklabels=False,\n                ticks='', domain=[0, 1], anchor='x2'),\n    showlegend=False,\n    autosize=False,\n    updatemenus=updatemenus\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_2.html', config = config)","type":"content","url":"/figure-3-1-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-3-2-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"03-T2\"\ndata_file = \"t2_and_t2star_curvs.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n# Get the signals and parameters from Matlab\n\n# T2\nT2_signal_WM = mat_contents['signal_WM_T2'][0]\nT2_signal_GM = mat_contents['signal_GM_T2'][0]\n\n# T2*\nT2star_signal_WM = mat_contents['signal_WM_T2star'][0]\nT2star_signal_GM = mat_contents['signal_GM_T2star'][0]\n\n# TE \nparams = mat_contents['params']\nTE = mat_contents['params']['TE'][0][0][0]\n\n## Plot\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly.offline import iplot\n\nconfig={'showLink': False, 'displayModeBar': False}\n\n# T2 signals\n\nwm_T2 = go.Scatter(\n    x = TE,\n    y = T2_signal_WM,\n    name = 'T<sub>2</sub> = 109.77 ms (White Matter)',\n    text = 'T<sub>2</sub> = 109.77 ms (White Matter)',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#1f77b4', dash='solid'),\n    visible = True\n)\n\ngm_T2 = go.Scatter(\n    x = TE,\n    y = T2_signal_GM,\n    name = 'T<sub>2</sub> = 96.07 ms (Gray Matter)',\n    text = 'T<sub>2</sub> = 96.07 ms (Gray Matter)',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#ff7f0e', dash='solid'),\n    visible = True\n)\n\n# T2* signals\n\nwm_T2star = go.Scatter(\n    x = TE,\n    y = T2star_signal_WM,\n    name = 'T<sub>2</sub>* = 67.63 ms (White Matter)',\n    text = 'T<sub>2</sub>* = 67.63 ms (White Matter)',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#1f77b4', dash='dot'),\n    visible = False\n)\n\ngm_T2star = go.Scatter(\n    x = TE,\n    y = T2star_signal_GM,\n    name = 'T<sub>2</sub>* = 48.48 ms (Gray Matter)',\n    text = 'T<sub>2</sub>* = 48.48 ms (Gray Matter)',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#ff7f0e', dash='dot'),\n    visible = False\n)\n\ndata = [wm_T2, gm_T2, wm_T2star, gm_T2star]\n\nlayout = go.Layout(\n    width=600,\n    height=375,\n    margin=go.layout.Margin(\n        l=100,\n        r=50,\n        b=60,\n        t=20,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.175,\n            showarrow=False,\n            text='Echo Time ‚Äì TE (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Transverse Magnetization (M<sub>xy</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2,\n        range=[0, 1]\n    ),\n    legend=dict(\n        x=0.53,\n        y=0.97,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    updatemenus=[\n        dict(\n            buttons=list([\n                # Display T2\n                dict(\n                    args=[{'visible': [True, True, False, False]}],\n                    label='T2',\n                    method='update'\n                ),\n                # Display T2*\n                dict(\n                    args=[{'visible': [False, False, True, True]}],\n                    label='T2*',\n                    method='update'\n                ),\n                # Display both T2 and T2*\n                dict(\n                    args=[{'visible': [True, True, True, True]}],\n                    label='T2 and T2*',\n                    method='update'\n                ),\n            ]),\n            direction='down',\n            pad={'r': 10, 't': 10},\n            showactive=True,\n            x=0.30,\n            xanchor='left',\n            y=1.0,\n            yanchor='top',\n            font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n            )\n        ),\n    ]\n) \n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_2.html', config = config)","type":"content","url":"/figure-3-2-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-3-2-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"03-T2\"\ndata_file = \"t2_noise_simulation.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n# Get the signals and parameters from Matlab\n\n# Get matlab signals\nsignal_SNR10 =  mat_contents['signal_SNR10'][0]\nsignal_SNR50 =  mat_contents['signal_SNR50'][0]\nsignal_SNR90 =  mat_contents['signal_SNR90'][0]\nsignal_SNR130 =  mat_contents['signal_SNR130'][0]\n\n# Get T2 constants from matlab simulation\nT2_SNR10 =  mat_contents['T2_SNR10'][0]\nT2_SNR50 =  mat_contents['T2_SNR50'][0]\nT2_SNR90 =  mat_contents['T2_SNR90'][0]\nT2_SNR130 =  mat_contents['T2_SNR130'][0]\n\n# TE \nparams =  mat_contents['params'][0]\nTE_signals =  params['TE'][0][0]\nTE =  params['TE'][0][0]\n\n# Noisy data\nSEdata_SNR10 =  np.squeeze(mat_contents['SEdata_SNR10'])\nSEdata_SNR50 =  np.squeeze(mat_contents['SEdata_SNR50'])\nSEdata_SNR90 =  np.squeeze(mat_contents['SEdata_SNR90'])\nSEdata_SNR130 =  np.squeeze(mat_contents['SEdata_SNR130'])\nTE_datapoints =  np.squeeze(mat_contents['EchoTimes'])\nTE_datapoints =  np.squeeze(mat_contents['EchoTimes'])\n\n## Plot\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly.offline import iplot\n\nconfig={'showLink': False, 'displayModeBar': False}\n\n# T2 signals with different SNRs\n\n## SNR = 10 \n\nSNR10 = go.Scatter(\n    x = TE_signals,\n    y = signal_SNR10,\n    name = f'T<sub>2</sub> Fitting (T<sub>2</sub> = {T2_SNR10})',\n    text = f'T<sub>2</sub> = {T2_SNR10}',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#1f77b4', dash='solid'),\n    visible = True\n)\n\ndatapoints_SNR10 = go.Scatter(\n    x = TE_datapoints,\n    y = SEdata_SNR10,\n    name = 'Data points with SNR = 10',\n    hoverinfo = 'x+y',\n    mode='markers', \n    marker=dict(color='red'), \n    visible=True\n)\n\n## SNR = 50\n\nSNR50 = go.Scatter(\n    x = TE,\n    y = signal_SNR50,\n    name = f'T<sub>2</sub> Fitting (T<sub>2</sub> = {T2_SNR50})',\n    text = f'T<sub>2</sub> = {T2_SNR50}',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#1f77b4'),\n    visible = False\n)\n\ndatapoints_SNR50 = go.Scatter(\n    x = TE_datapoints,\n    y = SEdata_SNR50,\n    name = 'Data points with SNR = 50',\n    hoverinfo = 'x+y',\n    mode='markers', \n    marker=dict(color='red'),  \n    visible=False\n)\n\n## SNR = 90\n\nSNR90 = go.Scatter(\n    x = TE_signals,\n    y = signal_SNR90,\n    name = f'T<sub>2</sub> Fitting (T<sub>2</sub> = {T2_SNR90})',\n    text = f'T<sub>2</sub> = {T2_SNR90}',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#1f77b4'),\n    visible = False\n)\n\ndatapoints_SNR90 = go.Scatter(\n    x = TE_datapoints,\n    y = SEdata_SNR90,\n    name = 'Data points with SNR = 90',\n    hoverinfo = 'x+y',\n    mode='markers',  \n    marker=dict(color='red'), \n    visible=False\n)\n\n## SNR = 130\n\nSNR130 = go.Scatter(\n    x = TE_signals,\n    y = signal_SNR130,\n    name = f'T<sub>2</sub> Fitting (T<sub>2</sub> = {T2_SNR130})',\n    text = f'T<sub>2</sub> = {T2_SNR130}',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#1f77b4'),\n    visible = False\n)\n\ndatapoints_SNR130 = go.Scatter(\n    x = TE_datapoints,\n    y = SEdata_SNR130,\n    name = 'Data points with SNR = 130',\n    hoverinfo = 'x+y',\n    mode='markers',  \n    marker=dict(color='red'), \n    visible=False\n)\n\ndata = [SNR10, SNR50, SNR90, SNR130, datapoints_SNR10, datapoints_SNR50, datapoints_SNR90, datapoints_SNR130]\n\nlayout = go.Layout(\n    width=600,\n    height=470,\n    margin=go.layout.Margin(\n        l=100,\n        r=50,\n        b=130,\n        t=20,\n    ),\n    annotations=[\n        dict(\n            x=0.2,\n            y=0.96,\n            showarrow=False,\n            text='<b>True value : T<sub>2</sub> = 109 ms </b>',\n            font=dict(\n                family='Times New Roman',\n                size=14,\n                color = 'black',\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5004254919715793,\n            y=-0.175,\n            showarrow=False,\n            text='Echo Time ‚Äì TE (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Transverse Magnetization (M<sub>xy</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.15,\n            y=-0.35,\n            showarrow=False,\n            text='SNR:',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        range=[0,300],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2,\n        range=[0, 1]\n    ),\n    legend=dict(\n        x=0.55,\n        y=0.97,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    updatemenus=[\n        dict(\n            buttons=list([\n                # Display T2 decay curve and data points with SNR = 10\n                dict(\n                    args=[{'visible': [True, False, False, False, True, False, False, False]}],\n                    label='10',\n                    method='update'\n                ),\n                # Display T2 decay curve and data points with SNR = 50\n                dict(\n                    args=[{'visible': [False, True, False, False, False, True, False, False]}],\n                    label='50',\n                    method='update'\n                ),\n                # Display T2 decay curve and data points with SNR = 90\n                dict(\n                    args=[{'visible': [False, False, True, False, False, False, True, False]}],\n                    label='90',\n                    method='update'\n                ),\n                # Display T2 decay curve and data points with SNR = 130\n                dict(\n                    args=[{'visible': [False, False, False, True, False, False, False, True]}],\n                    label='130',\n                    method='update'\n                ),\n            ]),\n            direction='up',\n            pad={'r': 10, 't': 10},\n            showactive=True,\n            x=0.28,\n            xanchor='left',\n            y=-0.22,\n            yanchor='top',\n            font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n            )\n        ),\n    ]\n) \n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_2.html', config = config)","type":"content","url":"/figure-3-2-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-3-3-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"03-T2\"\ndata_file = \"multiexpo_T2_curves.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n# Get the signals and parameters from Matlab\n\n# Signals\nsignal_mono_MW = np.array(mat_contents['signal_mono_MW'][0])\nsignal_mono_IEW = np.array(mat_contents['signal_mono_IEW'][0])\nsignal_multi_MWF = np.array(mat_contents['signal_multi_MWF'][0])\n\n# MWF from simulation\nFitResult = mat_contents['FitResult']\nMWF = np.round(FitResult['MWF'][0][0]/100, 2)\n\n# TE \nparams = mat_contents['params']\nTE = params['TE'][0][0][0]\n\n# Initialize MWF values for interactive multi-expo curve\ninteractive_multiexpo_signal = MWF*signal_mono_MW + (1-MWF)*signal_mono_IEW\n\n## Plot\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import iplot\n\nconfig={'showLink': False, 'displayModeBar': False}\n\n# Mono-exponential myelin water (MW) signal\n\nMW_T2 = go.Scatter(\n    x = TE,\n    y = signal_mono_MW,\n    name = 'Mono-exponential : Myelin water (MW)',\n    text = 'Myelin Water (MW)',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#2ca02c'),\n    visible = True\n)\n\n# Mono-exponential intra- and extracellular water (IEW) signal\n\nIEW_T2 = go.Scatter(\n    x = TE,\n    y = signal_mono_IEW,\n    name = 'Mono-exponential : Intra- and extracellular water (IEW)',\n    text = 'Intra- and Extracellular Water (IEW)',\n    hoverinfo = 'x+y+text',\n    line=dict(color='#ff7f0e'),\n    visible = True\n)\n\n# Interactive multi-exponential signal (with slider on interactive figure)\n\nmultiexpo_T2_inter = go.Scatter(\n    x = TE,\n    y = interactive_multiexpo_signal[0],\n    name = f'Multi-exponential : MW + IEW',\n    text = f'Interactive multi-expo T2',\n    hoverinfo = 'x+y+text', \n    line=dict(color='#9467bd',dash='dot'),\n    visible = True,\n)\n\ndata = [MW_T2, IEW_T2, multiexpo_T2_inter]\n\n# Define steps for slider\nsteps = [] \nfor value_slider in np.arange(0, 1.05, 0.05):  # For slider with 5% increments\n    interactive_multiexpo_signal = value_slider* signal_mono_MW + (1-value_slider) * signal_mono_IEW\n    steps.append(\n        dict(\n            method='update',\n            args=[\n                {'y': [signal_mono_MW, signal_mono_IEW, interactive_multiexpo_signal]},\n                {'visible': [True, True, True]}, \n                {'name': f'{int(value_slider*100)}% MW   {int((1-value_slider)*100)}% IEW'},\n            ],\n            label=f'<b>{int(value_slider*100)}% MW {int((1-value_slider)*100)}% IEW</b>',\n        )\n    )\n\n\nlayout = go.Layout(\n    width=670,\n    height=475,\n    margin=go.layout.Margin(\n        l=100,\n        r=50,\n        b=30,\n        t=30,\n    ),\n    sliders = [\n            dict(\n            steps=steps,\n            active = int(MWF[0][0] * 20),\n            len = 1.0,\n            pad = {'t':50},\n        )\n    ],\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.175,\n            showarrow=False,\n            text='Echo Time ‚Äì TE (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Transverse Magnetization (M<sub>xy</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2,\n    ),\n    yaxis=dict(\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.36,\n        y=0.97,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n) \n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'ir_fig_2.html', config = config)","type":"content","url":"/figure-3-3-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-3-3-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"03-T2\"\ndata_file = \"multiexpo_T2_image.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n# Get MATLAB data\n\n# Input MET2 data with different TE values\nME_TE_1 = mat_contents['ME_TE_1']\nME_TE_2 = mat_contents['ME_TE_2']\nME_TE_3 = mat_contents['ME_TE_3']\nME_TE_4 = mat_contents['ME_TE_4']\nME_TE_4 = mat_contents['ME_TE_4']\n\n\n# Output MWF, IEW and MW maps from qMRLab simulation\nMWF_map = mat_contents['MWF']\nT2MW_map = mat_contents['T2MW']\nT2IEW_map = mat_contents['T2IEW']\n\n## Plot\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom chart_studio.plotly import plot\nfrom IPython.display import display, HTML\nfrom plotly import tools\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\n\nconfig = {'showLink': False, 'displayModeBar': False}\n\nxAxis = np.arange(0, MWF_map.shape[1])\nyAxis = np.arange(0, MWF_map.shape[0])\n\ntrace1 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=ME_TE_1,\n                    colorscale='Gray',\n                    showscale=False,\n                    visible=False,\n                    name='Signal')\ntrace2 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=ME_TE_2,\n                    colorscale='Gray',\n                    showscale=False,\n                    visible=False,\n                    name='Signal')\ntrace3 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=ME_TE_3,\n                    colorscale='Gray',\n                    showscale=False,\n                    visible=True,\n                    name='Signal')\ntrace4 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=ME_TE_4,\n                    colorscale='Gray',\n                    visible=False,\n                    showscale=False,\n                    name='Signal')\ntrace5 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=MWF_map,\n                    colorscale='Portland',\n                    xaxis='x2',\n                    yaxis='y2',\n                    visible=True,\n                    name='MWF',\n                    zmin=25,\n                    zmax=55)\ntrace6 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=T2IEW_map,\n                    colorscale='Portland',\n                    xaxis='x2',\n                    yaxis='y2',\n                    visible=False,\n                    name='T2 IEW (ms)',\n                    zmin=40,\n                    zmax=100)\ntrace7 = go.Heatmap(x=xAxis,\n                    y=yAxis,\n                    z=T2MW_map,\n                    colorscale='Portland',\n                    xaxis='x2',\n                    yaxis='y2',\n                    visible=False,\n                    name='T2 MW (ms)',\n                    zmin=15,\n                    zmax=40)\n\ndata = [trace1, trace2, trace3, trace4, trace5, trace6, trace7]\n\nupdatemenus = [\n    dict(\n        active=2,\n        x=0.12,\n        xanchor='left',\n        y=-0.15,\n        yanchor='bottom',\n        direction='up',\n        font=dict(family='Times New Roman', size=16),\n        buttons=[\n            dict(label='12.8 ms',\n                 method='update',\n                 args=[{'visible': [True, False, False, False, trace5['visible'], trace6['visible'], trace7['visible']]}]),\n            dict(label='128 ms',\n                 method='update',\n                 args=[{'visible': [False, True, False, False, trace5['visible'], trace6['visible'], trace7['visible']]}]),\n            dict(label='256 ms',\n                 method='update',\n                 args=[{'visible': [False, False, True, False, trace5['visible'], trace6['visible'], trace7['visible']]}]),\n            dict(label='384 ms',\n                 method='update',\n                 args=[{'visible': [False, False, False, True, trace5['visible'], trace6['visible'], trace7['visible']]}])\n        ],\n    ),\n    dict(\n        x=0.7,\n        xanchor='left',\n        y=-0.15,\n        yanchor='bottom',\n        direction='up',\n        font=dict(family='Times New Roman', size=16),\n        buttons=[\n            dict(label='MWF',\n                 method='update',\n                 args=[{'visible': [trace1['visible'], trace2['visible'], trace3['visible'], trace4['visible'], True, False, False]},\n                       {'annotations': [\n                           dict(\n                               x=0.19,\n                               y=1.15,\n                               showarrow=False,\n                               text='MET2w',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=0.85,\n                               y=1.15,\n                               showarrow=False,\n                               text='MWF map',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=1.17,\n                               y=1.15,\n                               showarrow=False,\n                               text='T<sub>2</sub> (ms)',\n                               font=dict(family='Times New Roman', size=26),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=0.02,\n                               y=-0.15,\n                               showarrow=False,\n                               text='TE:',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                       ]}]),\n            dict(label='T2 IEW',\n                 method='update',\n                 args=[{'visible': [trace1['visible'], trace2['visible'], trace3['visible'], trace4['visible'], False, True, False]},\n                       {'annotations': [\n                           dict(\n                               x=0.19,\n                               y=1.15,\n                               showarrow=False,\n                               text='MET2w',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=0.95,\n                               y=1.25,\n                               showarrow=False,\n                               text='T2 map for<br>Intra/Extracellular Water',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=1.17,\n                               y=1.15,\n                               showarrow=False,\n                               text='T<sub>2</sub> (ms)',\n                               font=dict(family='Times New Roman', size=26),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=0.02,\n                               y=-0.15,\n                               showarrow=False,\n                               text='TE:',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                       ]}]),\n            dict(label='T2 MW',\n                 method='update',\n                 args=[{'visible': [trace1['visible'], trace2['visible'], trace3['visible'], trace4['visible'], False, False, True]},\n                       {'annotations': [\n                           dict(\n                               x=0.19,\n                               y=1.15,\n                               showarrow=False,\n                               text='MET2w',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=0.86,\n                               y=1.25,\n                               showarrow=False,\n                               text='T2 map for<br>Myelin Water',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=1.17,\n                               y=1.15,\n                               showarrow=False,\n                               text='T<sub>2</sub> (ms)',\n                               font=dict(family='Times New Roman', size=26),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                           dict(\n                               x=0.02,\n                               y=-0.15,\n                               showarrow=False,\n                               text='TE:',\n                               font=dict(family='Times New Roman', size=22),\n                               xref='paper',\n                               yref='paper'\n                           ),\n                       ]}])\n        ],\n    ),\n]\n\nlayout = dict(\n    width=728,\n    height=448.5,\n    margin=dict(\n        t=90,\n        r=140,\n        b=90,\n        l=30),\n    annotations=[\n        dict(\n            x=0.19,\n            y=1.15,\n            showarrow=False,\n            text='MET2w',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.85,\n            y=1.15,\n            showarrow=False,\n            text='MWF map',  # Default title, will change with dropdown selection\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.17,\n            y=1.15,\n            showarrow=False,\n            text='T<sub>2</sub> (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.02,\n            y=-0.15,\n            showarrow=False,\n            text='TE:',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(range=[0, xAxis[-1]], autorange=False,\n               showgrid=False, zeroline=False, showticklabels=False,\n               ticks='', domain=[0, 0.5]),  # First plot domain\n    yaxis=dict(range=[0, yAxis[-1]], autorange=False,\n               showgrid=False, zeroline=False, showticklabels=False,\n               ticks='', domain=[0, 1]),\n    xaxis2=dict(range=[0, xAxis[-1]], autorange=False,\n                showgrid=False, zeroline=False, showticklabels=False,\n                ticks='', domain=[0.5, 1]),  # Second plot domain\n    yaxis2=dict(range=[0, yAxis[-1]], autorange=False,\n                showgrid=False, zeroline=False, showticklabels=False,\n                ticks='', domain=[0, 1], anchor='x2'),\n    showlegend=False,\n    autosize=False,\n    updatemenus=updatemenus\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename='ir_fig_2.html', config=config)\n","type":"content","url":"/figure-3-3-2","position":1},{"hierarchy":{"lvl1":"T2 Mapping"},"type":"lvl1","url":"/t2-mapping","position":0},{"hierarchy":{"lvl1":"T2 Mapping"},"content":"","type":"content","url":"/t2-mapping","position":1},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Introduction"},"type":"lvl2","url":"/t2-mapping#introduction","position":2},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Introduction"},"content":"T2 relaxation, also known as the transverse or spin-spin relaxation, is characterized by the dephasing of spins, leading to a reduction of the total magnetization in the x-y plane. In practical terms, the T2 value represents the upper limit of the signal decay time under ideal imaging conditions. In practice, magnetic field inhomogeneities cause the transverse magnetization to decay faster than what is captured by T2 relaxation. These inhomogeneities can be macroscopic, caused by factors such as metallic implants or air-tissue interfaces, or microscopic, resulting from differences in magnetic susceptibility between tissues \n\nChavhan et al., 2009\n\nCohen-Adad, 2014 . When considering this phenomenon, we refer to the transverse relaxation as T2*.\n\nT2 mapping, a quantitative magnetic resonance imaging method, offers images of T2 relaxation times (called T2 maps) providing valuable insights into tissue composition. Given that T2 relaxation is sensitive to specific microstructural changes associated with diseases, such as iron accumulation, myelination and inflammation \n\nDortch, 2020, it is considered a promising modality for clinical and research applications. Commonly used T2-mapping techniques are split into two categories: the mono-exponential methods, which consider that the voxel‚Äôs signal arises from a single tissue compartment, and multi-exponential methods, where various tissues that contribute to a single voxel‚Äôs signal are considered. Recently, novel techniques for T2 mapping have emerged beyond the conventional techniques that were developed for NMR, such as MR fingerprinting (Ma et al., 2013), a fast relaxation mapping technique that uses a single image acquisition to quantify multiple parameters \n\nHamilton et al., 2017.\n\nIn the following sections, we will introduce the current state-of-the-art signal modeling and data fitting theory for both mono-exponential and multi-exponential T2 mapping, as well as the benefits and pitfalls of both approaches. An overview of some common applications of T2 mapping (e.g., myelin water fraction (MWF) imaging) will also be presented. We will also cover the fundamentals of T2* mapping and explore how its signal decay curve can differ from that of T2 relaxation.","type":"content","url":"/t2-mapping#introduction","position":3},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"T2 mapping vs T2-weighted imaging","lvl2":"Introduction"},"type":"lvl3","url":"/t2-mapping#t2-mapping-vs-t2-weighted-imaging","position":4},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"T2 mapping vs T2-weighted imaging","lvl2":"Introduction"},"content":"The standard practice in clinical MRI is T2-weighted imaging (T2w), i.e. images in which the different tissues produce signals according to their T2 relaxation times. T2w images are considered qualitative, as they rely on differences in T2 relaxation of various tissues to provide contrast rather than actual quantitative tissue measurements, thus making their interpretation dependent on the observer. Meanwhile, T2 mapping is considered a quantitative technique, as it directly measures the T2 relaxation time of tissues by fitting multiple data points to a decay curve to calculate the T2 constant. The objective nature of T2 mapping makes it a promising technique for various applications in both clinical practice and research, including disease progression monitoring and the identification of novel biomarkers. Another advantage of T2 mapping is that it allows for consistent comparisons across different imaging protocols, thereby enhancing reproducibility and making it ideal for longitudinal and multi-institutional studies \n\nCheng et al., 2012. \n\nFigure 3.1 shows several examples of T2w images acquired at different echo times, compared to the T2 map generated by fitting the decay curve.\n\n\n\nFigure¬†3.1:T2-weighted images at different TE, compared to T2 map following data fitting of the T2 decay curve.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 3.1.%% Requirements\n% qMRLab must be installed: git clone https://www.github.com/qMRLab/qMRLab.git\n% The mooc chapter branch must be checked out: git checkout mooc-03-T2\n% qMRLab must be added to the path inside the MATLAB session: startup\n\n% Define the model \nModel = mono_t2;\n\n% Load data into environment, and rotate mask to be aligned with IR data\ndata = struct;\ndata.SEdata = double(load_nii_data('../data/mono_t2/SEdata.nii.gz'));\ndata.Mask = double(load_nii_data('../data/mono_t2/Mask.nii.gz'));\n\n% Define fitting parameters\nEchoTime  = [12.8000; 25.6000; 38.4000; 51.2000; 64.0000; 76.8000; 89.6000; 102.4000; 115.2000; 128.0000; 140.8000; 153.6000; 166.4000; 179.2000; 192.0000; 204.8000; 217.6000; 230.4000; 243.2000; 256.0000; 268.8000; 281.6000; 294.4000; 307.2000; 320.0000; 332.8000; 345.6000; 358.4000; 371.2000; 384.0000];\nModel.Prot.SEdata.Mat = [ EchoTime ];\nFitResults = FitData(data,Model,0);\n\n% T2w MRI data at different TE values\nTE_1 = imrotate(squeeze(data.SEdata(:,:,:,1).*data.Mask),-90);\nTE_2 = imrotate(squeeze(data.SEdata(:,:,:,10).*data.Mask),-90);\nTE_3 = imrotate(squeeze(data.SEdata(:,:,:,20).*data.Mask),-90);\nTE_4 = imrotate(squeeze(data.SEdata(:,:,:,30).*data.Mask),-90);\n\n% Extract the T2 map from FitResults and rotate it\nT2_map = imrotate(squeeze(FitResults.T2.*data.Mask), -90);\n\n% Plotting the images\nfigure;\n\nsubplot(2, 3, 1);\nimagesc(TE_1);\ncolormap(gray);\ncolorbar;\naxis image;\ntitle('TE = 12.80 ms');\nxlabel('X-axis');\nylabel('Y-axis');\ncaxis([0, 2500]);\n\nsubplot(2, 3, 2);\nimagesc(TE_2);\ncolormap(gray);\ncolorbar;\naxis image;\ntitle('TE = 128.00 ms');\nxlabel('X-axis');\nylabel('Y-axis');\ncaxis([0, 2500]);\n\nsubplot(2, 3, 3);\nimagesc(TE_3);\ncolormap(gray);\ncolorbar;\naxis image;\ntitle('TE = 256.00 ms');\nxlabel('X-axis');\nylabel('Y-axis');\ncaxis([0, 2500]);\n\nsubplot(2, 3, 4);\nimagesc(TE_4);\nT2_map = imrotate(squeeze(FitResults.T2.*data.Mask),-90);\ncolormap(gray);\ncolorbar;\naxis image;\ntitle('TE = 384.00 ms');\nxlabel('X-axis');\nylabel('Y-axis');\ncaxis([0, 2500]);\n\nsubplot(2, 3, 5);\nimagesc(T2_map);\ncolormap(gray); \ncolorbar;\naxis image;\ntitle('T2 map');\nxlabel('X-axis');\nylabel('Y-axis');\ncaxis([80, 150]);\n\n%% Export\n\nEchoTimes = [EchoTime(1), EchoTime(10), EchoTime(20), EchoTime(30)]\nsave(\"T2w_vs_T2map.mat\", \"T2_map\", \"TE_1\", \"TE_2\", \"TE_3\", \"TE_4\", \"EchoTimes\")","type":"content","url":"/t2-mapping#t2-mapping-vs-t2-weighted-imaging","position":5},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Monoexponential T2 Mapping"},"type":"lvl2","url":"/t2-mapping#monoexponential-t2-mapping","position":6},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Monoexponential T2 Mapping"},"content":"The simplest technique for performing T2-mapping involves the acquisition of multiple images using a single-echo sequence with different echo times (TE). This set of data can then be used to fit the T2 from the decaying signal curve \n\nMilford et al., 2015. However, this method is typically not employed in-vivo due to its prohibitively long acquisition times.\n\nMulti-spin echo (MSE) sequences, based on the Carr-Purcell-Meiboom-Gill (CPMG) pulse train \n\nCarr & Purcell, 1954\n\nMeiboom & Gill, 1958, employ multiple 180-degree refocusing pulses to generate multiple echoes within a single acquisition (\n\nFigure 3.2) \n\nFatemi et al., 2020\n\nMilford et al., 2015. This substantially reduces the scan time relative to acquiring multiple echoes using separate single-SE acquisitions, making MSE the sequence of choice in clinical settings.\n\nThe original Carr-Purcell method, which involves applying a 90-degree pulse followed by a series of 180-degree pulses along the same axis (e.g., x-axis), was designed to mitigate diffusion effects by preventing phase accumulation. However, this approach can lead to the accumulation of imperfections in the 180-degree pulses, resulting in a faster than expected loss of transverse magnetization (Mxy) and inaccurate T2 measurements \n\nBrown et al., 2014. The Meiboom-Gill improvement addresses this issue by applying the initial 90-degree pulse along one axis (e.g., x-axis) and the subsequent 180-degree pulses along a perpendicular axis (e.g., y-axis). This phase cycling distributes errors such that they average out over time, producing a more stable and accurate echo train \n\nBrown et al., 2014.\n\n\n\nFigure¬†3.2:Simplified illustration of a multi-spin echo sequence for T2 mapping based on the Carr-Purcell-Meiboom-Gill method\n\nTo fit the data using the mono-exponential model, homogeneity within each voxel is assumed implicitly, implying a consistent T2 decay time across the tissue. This results in a single fitted T2 value for each voxel in the image. Although it is widely used, the mono-exponential model has been shown to be insufficient for proper estimation of tissue T2 relaxation times, given that the signal in a voxel often arises from multiple tissue components with different T2 values \n\nGraham et al., 1996. In \n\na later section of this chapter, we will cover the multi-exponential method and discuss its use in applications such as myelin water fraction (MWF) imaging.","type":"content","url":"/t2-mapping#monoexponential-t2-mapping","position":7},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Signal Modelling","lvl2":"Monoexponential T2 Mapping"},"type":"lvl3","url":"/t2-mapping#signal-modelling","position":8},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Signal Modelling","lvl2":"Monoexponential T2 Mapping"},"content":"The decay of the transverse magnetization (Mxy) is exponential and can be derived from the transverse component of the Bloch equations:\\textit{M}_{xy}\\left ( TE \\right ) = Mz\\left ( 0^{-} \\right )e^{-TE/T_{2}}\n\nwhere Mz(0-) is the longitudinal magnetization immediately preceding the 90 degree excitation pulse. By using this equation, we make the assumption that the measured signal is proportional to the transverse magnetization (Mxy), and that Mz(0-) remains constant regardless of echo time (TE) \n\nDortch, 2020.\n\nFigure 3.3 shows transverse relaxation curves for T2 and T2* values for white matter and gray matter, using the relaxation times from \n\nSiemonsen et al., 2008.\n\n\n\nFigure¬†3.3:Transverse relaxation decay curves for T2 and T2* values in white matter and gray matter. The T2 and T2* constants were taken from \n\nSiemonsen et al., 2008.\n\nIn NMR physics, it has been shown that T2 relaxation times must be equal to or shorter than 2 T1 \n\nLevitt, 2008; however, it has been demonstrated that T2 can exceed T1 in very rare cases \n\nTraficante, 1991. In living organisms however, T2 is always shorter than T1.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 3.3.%% Requirements\n% qMRLab must be installed: git clone https://www.github.com/qMRLab/qMRLab.git\n% The mooc chapter branch must be checked out: git checkout mooc-03-T2\n% qMRLab must be added to the path inside the MATLAB session: startup\n\n%% T2 and T2* decay curves\n% Script to display T2 and T2* relaxometry curves for different tissues\n\n% Simulation parameters\nparams.TE = linspace(0, 300, 100); % Echo times (in ms)\n\n% Define T2 values for different tissues\nparams.T2_WM = 109.77; % T2 of white matter (in ms)\nparams.T2_GM = 96.07; % T2 of gray matter (in ms)\n\n% Define T2* values for different tissues\nparams.T2star_WM = 67.63; % T2* of white matter (in ms)\nparams.T2star_GM = 48.48; % T2* of gray matter (in ms)\n\n% Generate T2 and T2* decay signals\nsignal_WM_T2 = exp(-params.TE / params.T2_WM);\nsignal_GM_T2 = exp(-params.TE / params.T2_GM);\nsignal_WM_T2star = exp(-params.TE / params.T2star_WM);\nsignal_GM_T2star = exp(-params.TE / params.T2star_GM);\n\n% Plot the T2 and T2* signals\nfigure;\nhold on;\nplot(params.TE, signal_WM_T2, '-b', 'DisplayName', 'T2 = 109.77 ms (white matter)');\nplot(params.TE, signal_GM_T2, '-r', 'DisplayName', 'T2 = 96.07 ms (gray matter)');\nplot(params.TE, signal_WM_T2star, '--b', 'DisplayName', 'T2* = 67.63 ms (white matter)');\nplot(params.TE, signal_GM_T2star, '--r', 'DisplayName', 'T2* = 48.48 ms (gray matter)');\nxlabel('Echo Time - TE (ms)');\nylabel('Transverse Magnetization (Mxy)');\nlegend();\ntitle('T2 and T2* Decay Signals');\n\n%% Export\n\nTE = squeeze(params.TE)\nsave(\"t2_and_t2star_curvs.mat\", \"signal_WM_T2\", \"signal_GM_T2\", \"signal_WM_T2star\", \"signal_GM_T2star\", \"params\")\n","type":"content","url":"/t2-mapping#signal-modelling","position":9},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Data Fitting","lvl2":"Monoexponential T2 Mapping"},"type":"lvl3","url":"/t2-mapping#data-fitting","position":10},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Data Fitting","lvl2":"Monoexponential T2 Mapping"},"content":"The T2 signal decay for the mono-exponential model is described mathematically as :\\textit{S}\\left ( TE \\right ) = S_{0}e^{-TE/T_{2}}\n\nwhere S0 is the signal intensity immediately following the excitation pulse \n\nDortch, 2020\n\nMilford et al., 2015.\n\nIn practice, B1 inhomogeneities and RF pulse imperfections can influence the T2 signal decay curve and result in inaccurate T2 estimations. This may cause refocusing pulses to deviate from the ideal 180 degrees, generating additional echoes known as stimulated or spurious echoes. These unwanted echoes can contaminate the signal decay, resulting in erroneous T2 estimations \n\nMcPhee & Wilman, 2018. To account for these stimulated echoes, some studies have shown that T2 fitting accuracy can be improved either by using only even-numbered echoes \n\nFocke et al., 2011\n\nKim et al., 2009, or by discarding the first echo \n\nBiasiolli et al., 2013\n\nMilford et al., 2015.","type":"content","url":"/t2-mapping#data-fitting","position":11},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"T2*","lvl3":"Data Fitting","lvl2":"Monoexponential T2 Mapping"},"type":"lvl4","url":"/t2-mapping#t2t2star","position":12},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"T2*","lvl3":"Data Fitting","lvl2":"Monoexponential T2 Mapping"},"content":"Until now, we have assumed that the transverse signal (Mxy) decays exponentially with the echo time divided by the T2 constant (see \n\nEq. 3.3). However, in practice, other factors such as B0 inhomogeneities can cause a more rapid loss of the transverse signal; this results in a faster transverse decay, which is referred to as T2* relaxation (see \n\nFigure 3.1).\n\nThe relation between T2 and T2* is described as follows \n\nBrown et al., 2014:\\frac{1}{T_{2}^{*}} =  \\frac{1}{T_{2}}  +  \\frac{1}{T_{2}^{'}}\n\nWhere T2‚Ä≤ quantifies the portion of relaxation which is due to magnetic field inhomogeneities. Some studies suggest that T2‚Ä≤ mapping, which can be performed by removing the T2 relaxation effect from T2*, could offer valuable insights for brain disease diagnosis, notably by quantifying blood oxygenation levels \n\nLee et al., 2014 and to predict infarct growth in acute stroke patients \n\nSiemonsen et al., 2008.\n\nThe T2* decay can then be calculated using the same methods as T2, where \n\nEq. 3.3 can be rewritten as follows :\\textit{S}\\left ( TE \\right ) = S_{0}e^{-TE/T_{2}}\n\nUnlike T2 mapping, which uses spin echo type sequences, T2* mapping is performed using gradient echo sequences (GRE), as they are sensitive to magnetic field inhomogeneities \n\nCohen-Adad, 2014\n\nMarkl & Leupold, 2012. Nonetheless, there are specialized sequences such as the spin and gradient echo (SAGE) sequence \n\nStokes et al., 2014 that enable the simultaneous acquisition of both T2 and T2*.","type":"content","url":"/t2-mapping#t2t2star","position":13},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"Noise","lvl3":"Data Fitting","lvl2":"Monoexponential T2 Mapping"},"type":"lvl4","url":"/t2-mapping#noise","position":14},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"Noise","lvl3":"Data Fitting","lvl2":"Monoexponential T2 Mapping"},"content":"In MRI, noise in the data can make it harder to accurately fit the T2 decay curve, which is problematic given the necessity for highly precise T2 values in clinical contexts. This issue is particularly pronounced when using pixel-wise T2 mapping, as the signal-to-noise (SNR) is much lower compared to region-of-interest (ROI) T2 mapping approaches \n\nSandino et al., 2015. \n\nFigure 3.4 shows how varying the level of noise in the acquired data can influence the fitting of the T2 relaxation curve and the resulting T2 constant. As observed in this figure, a low SNR can have a considerable impact on the T2 fitting process.\n\n\n\nFigure¬†3.4:Impact of noise on T2 relaxometry fitting. The figure shows a single voxel fit with a true T2 relaxation time of 109 ms. As the noise level increases, the accuracy of the T2 fitting decreases, leading to deviations in the estimated T2 relaxation time from the true value. This demonstrates how higher noise levels can adversely affect the reliability of T2 measurements and may result in inaccurate representations of tissue relaxation properties.\n\nThe number of echoes used in T2 relaxometry is influenced by several factors, including the need for adequate spacing between echoes, the potential risk of heating the sample, and the challenges associated with processing data from samples with low signal-to-noise ratios. Therefore, selecting an optimal number of echoes is crucial for achieving accurate and reliable results while addressing these constraints \n\nShrager et al., 1998. The Cramer-Rao lower-bound (CRLB) method is a statistical tool that can be used in the context of T2 relaxometry to estimate the smallest possible variance, known as the lower bound, of an unbiased estimator given the noise present in the data \n\nCavassila et al., 2001. Using the lower bounds, the optimal number of echoes needed to accurately fit the T2 decay curve can be determined, ensuring more robust T2 mapping \n\nJones et al., 1996. In their work, \n\nShrager et al., 1998 introduced another method for optimizing the selection of echo time points to improve the accuracy of T2 value estimates based on a predetermined range of expected T2 values. Their approach demonstrated superior accuracy compared to conventional methods that use uniformly-spaced echo times, suggesting that these methods are not optimal for T2 curve fitting accuracy.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 3.5.%% Requirements\n% qMRLab must be installed: git clone https://www.github.com/qMRLab/qMRLab.git\n% The mooc chapter branch must be checked out: git checkout mooc-03-T2\n% qMRLab must be added to the path inside the MATLAB session: startup\n%% T2 and T2* decay curves\n\nclose all\nclear all\nclc\n\n% Define model\nModel = mono_t2;\n\nparams.TE = linspace(0, 300, 100); % Echo times (in ms)\n\n% Define signal parameters for different tissues\nx = struct;\nx.M0 = 1000;\nx.T2 = 109; % (in ms)\n\n% Define the signal-to-noise ratio \nOpt1.SNR = 10;\nOpt2.SNR = 50;\nOpt3.SNR = 90;\nOpt4.SNR = 130;\n\n% Run the simulation for T2 and T2* decay curves\n[FitResult_SNR10, data_SNR10] = Model.Sim_Single_Voxel_Curve(x, Opt1);\n[FitResult_SNR50, data_SNR50] = Model.Sim_Single_Voxel_Curve(x, Opt2);\n[FitResult_SNR90, data_SNR90] = Model.Sim_Single_Voxel_Curve(x, Opt3);\n[FitResult_SNR130, data_SNR130] = Model.Sim_Single_Voxel_Curve(x, Opt4);\n\n% T2 constants\nT2_SNR10 = FitResult_SNR10.T2;\nT2_SNR50 = FitResult_SNR50.T2;\nT2_SNR90 = FitResult_SNR90.T2;\nT2_SNR130 = FitResult_SNR130.T2;\n\n% T2 decay curves\nsignal_SNR10 = FitResult_SNR10.M0/1000 * exp(-params.TE / FitResult_SNR10.T2);\nsignal_SNR50 = FitResult_SNR50.M0/1000 * exp(-params.TE / FitResult_SNR50.T2);\nsignal_SNR90 = FitResult_SNR90.M0/1000 * exp(-params.TE / FitResult_SNR90.T2);\nsignal_SNR130 = FitResult_SNR130.M0/1000 * exp(-params.TE / FitResult_SNR130.T2);\n\n% Noisy data points\nEchoTimes  = [12.8000; 25.6000; 38.4000; 51.2000; 64.0000; 76.8000; 89.6000; 102.4000; 115.2000; 128.0000; 140.8000; 153.6000; 166.4000; 179.2000; 192.0000; 204.8000; 217.6000; 230.4000; 243.2000; 256.0000; 268.8000; 281.6000; 294.4000; 307.2000; 320.0000; 332.8000; 345.6000; 358.4000; 371.2000; 384.0000];\nSEdata_SNR10 = data_SNR10.SEdata/1000;\nSEdata_SNR50 = data_SNR50.SEdata/1000;\nSEdata_SNR90 = data_SNR90.SEdata/1000;\nSEdata_SNR130 = data_SNR130.SEdata/1000;\n\n%% Export\n\ndisp(EchoTimes)\ndisp(params.TE)\n\nsave(\"t2_noise_simulation.mat\", \"params\", \"signal_SNR10\", \"signal_SNR50\", \"signal_SNR90\", \"signal_SNR130\", \"T2_SNR10\", \"T2_SNR50\", \"T2_SNR90\", \"T2_SNR130\", \"SEdata_SNR10\", \"SEdata_SNR50\", \"SEdata_SNR90\", \"SEdata_SNR130\", \"EchoTimes\")\n","type":"content","url":"/t2-mapping#noise","position":15},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Monoexponential T2 Mapping"},"type":"lvl3","url":"/t2-mapping#benefits-and-pitfalls","position":16},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Monoexponential T2 Mapping"},"content":"The main benefit of mono-exponential T2 mapping is its simplicity and straightforward implementation, making it a convenient and efficient method for T2 fitting. Additionally, as mentioned previously, the use of multi-echo spin echo (MESE) sequences significantly reduces the acquisition time, further enhancing its practicality \n\nFatemi et al., 2020\n\nMilford et al., 2015.\n\nDespite these advantages, mono-exponential methods have certain drawbacks. First, by assuming a single T2 relaxation constant per voxel, the mono-exponential method tends to over-simplify the tissue microstructure, potentially leading to inaccurate T2 estimations. This limitation can be particularly problematic when studying tissues that have a complex microstructure, where a single voxel may contain components with different T2 relaxation times. Furthermore, it has been shown that MESE sequences are sensitive to imperfections in the radiofrequency pulses. For instance, factors such as B1 inhomogeneities and reduced flip angles have been shown to overestimate T2 times when using mono-exponential methods \n\nFatemi et al., 2020.","type":"content","url":"/t2-mapping#benefits-and-pitfalls","position":17},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Multiexponential T2 mapping"},"type":"lvl2","url":"/t2-mapping#t2multiexpo","position":18},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Multiexponential T2 mapping"},"content":"By using the mono-exponential curve described in the previous sections, we use a single compartment tissue model. This means that we assume that all tissue components contained in a voxel have the same T2 relaxation time. However, in practice, the assumption of T2 decay uniformity within a voxel can result in inaccurate fittings, as a voxel may contain different tissue compartments with different T2 times. For example, a voxel at a tissue boundary inside the brain can contain both cerebrospinal fluid and gray matter, a phenomenon which is also commonly referred to as the partial volume effect. In such cases, it would be preferable to compartmentalize different tissues inside a single voxel: this is made possible with multi-exponential T2 mapping, where we consider the T2 relaxation contribution of each tissue compartment within a voxel. The multi-exponential T2 mapping method, which will be described in this section, can be useful in many applications, such as myelin water fraction imaging which will be explained further in the \n\nsection on applications.","type":"content","url":"/t2-mapping#t2multiexpo","position":19},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Signal Modelling","lvl2":"Multiexponential T2 mapping"},"type":"lvl3","url":"/t2-mapping#signal-modelling-1","position":20},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Signal Modelling","lvl2":"Multiexponential T2 mapping"},"content":"For multiexponential T2 mapping, the transverse magnetization (Mxy) acquired at different echo times (TE) can be modeled as a sum of exponential decays :\\textit{M}_{xy}\\left ( TE \\right ) = \\sum_{i=1}^{N}M_{z,i}\\left ( 0^-{} \\right )e^{-TE/T_{2,i}}\n\nwhere each term of the summation represents the contribution of the ith tissue component to the overall transverse magnetization decay \n\nCollewet et al., 2022\n\nDortch, 2020.\n\nFigure 3.5 presents a single-voxel simulation of T2 relaxation curves of myelin water (MW) and intra/extracellular water (IEW) using mono-exponential T2 fitting, compared to a multi-exponential fitting for both MW and IEW. In this example, we see that using a multi-exponential model rather than mono-exponential for complex tissues like myelin enables more precise quantification of the T2 relaxation time within each voxel.\n\n\n\nFigure¬†3.5:Comparison of mono-exponential and multi-exponential T2 fitting. This figure contrasts mono-exponential and multi-exponential fitting approaches for a single voxel containing myelin water (MW) and intra/extracellular water (IEW). The green and orange curves represent mono-exponential fittings for MW and IEW, respectively. The dotted purple curve illustrates the multi-exponential fitting, which combines both MW and IEW components.\n\n\n\nFigure¬†3.6:Comparison of mono-exponential and multi-exponential T2 fitting. This figure contrasts mono-exponential and multi-exponential fitting approaches for a single voxel containing myelin water (MW) and intra/extracellular water (IEW). The green and orange curves represent mono-exponential fittings for MW and IEW, respectively. The dotted purple curve illustrates the multi-exponential fitting, which combines both MW and IEW components.\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 3.5.%% Requirements\n% qMRLab must be installed: git clone https://www.github.com/qMRLab/qMRLab.git\n% The mooc chapter branch must be checked out: git checkout mooc-03-T2\n% qMRLab must be added to the path inside the MATLAB session: startup\n\nclose all\nclear all\n\nModel = mwf\n\n% Define initial MWF and T2 times of myelin water and intra- and extracellular water\nx = struct;\nx.MWF = 50;\nx.T2MW = 20;\nx.T2IEW = 120;\n\n\n% Define echo times\nparams.TE = linspace(0, 300, 100);\n\n% Set simulation options\nOpt.SNR = 120;\nOpt.T2Spectrumvariance_Myelin = 5;\nOpt.T2Spectrumvariance_IEIntraExtracellularWater = 20;\n\n% Run simulation\nfigure('Name','Single Voxel Curve Simulation');\nFitResult = Model.Sim_Single_Voxel_Curve(x,Opt);\n\n% T2 relaxation curves for myelin water and intra/extracellular water\n% (using a mono-exponential curve)\nsignal_mono_MW = exp(-params.TE / FitResult.T2MW);\nsignal_mono_IEW = exp(-params.TE / FitResult.T2IEW);\n\n% T2 relaxation curve for multi-expo model\nsignal_multi_MWF = (FitResult.MWF/100)*signal_mono_MW + (1 - FitResult.MWF/100)*signal_mono_IEW;\n\n%% Export\n\nTE = squeeze(params.TE)\nsave(\"multiexpo_T2_curves.mat\", \"signal_mono_MW\", \"signal_mono_IEW\", \"signal_multi_MWF\", \"TE\", \"FitResult\", \"params\", \"x\", \"Opt\")\n","type":"content","url":"/t2-mapping#signal-modelling-1","position":21},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Data Fitting","lvl2":"Multiexponential T2 mapping"},"type":"lvl3","url":"/t2-mapping#data-fitting-1","position":22},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Data Fitting","lvl2":"Multiexponential T2 mapping"},"content":"To fit the data for multi-exponential T2 mapping, \n\nEq. 3.5 can be rewritten to express the signal decay in terms of the initial amplitude (Si) for each tissue component. The multi-exponential T2 signal decay is then given by :\\textit{S}\\left ( TE \\right ) = \\sum_{i=1}^{N}S_{i}e^{-TE/T_{2,i}}\n\nWhere the term Si corresponds to the initial signal amplitude of the ith tissue component, and T2,iis the T2 relaxation time of that component.\n\nFor example, the multi-exponential signal from \n\nFigure 3.5 can be expressed as the combination of the signals from both myelin water (MW) and intra/extracellular water (IEW), as follows :\\textit{S}\\left ( TE \\right )_{MWI} = S_{MW}e^{-TE/T_{2,MW}}+S_{IEW}e^{-TE/T_{2,IEW}}\n\nFigure 3.7 presents an example of multi-exponential T2 fitting applied to an image of the spinal cord. The figure shows the myelin water fraction (MWF) map, which highlights the distribution of myelin water across the spinal cord, as well as the T2 maps for intra/extracellular water and myelin water. The multi-exponential fitting approach allows for the separation of these components, enhancing tissue characterization in complex structures compared to mono-exponential models. In the following section, we will explain why MWF imaging is a key application of multi-exponential T2 mapping, and how it provides valuable insights into the microstructure of the spinal cord, highlighting its potential benefits for understanding and diagnosing neurological conditions.\n\n\n\nFigure¬†3.7:Multi-exponential T2 mapping example of the spinal cord. The left image displays multi-exponential (ME) T2w data acquired at different echo times (TE) used for the data fitting. The right image presents the resulting myelin water fraction (MWF) map and T2 relaxation maps for myelin water (MW) and intra/extracellular water (IEW).\n\nClick here to view the qMRLab (MATLAB/Octave) code that generated \n\nFigure 3.7.%% Requirements\n% qMRLab must be installed: git clone https://www.github.com/qMRLab/qMRLab.git\n% The mooc chapter branch must be checked out: git checkout mooc-03-T2\n% qMRLab must be added to the path inside the MATLAB session: startup\n\n% Define the model \nModel = mwf;\n\n% Load data into environment, and rotate mask to be aligned with IR data\ndata = struct;\nload('../data/mwf/MET2data.mat');\nload('../data/mwf/Mask.mat');\ndata.MET2data = double(MET2data);\ndata.Mask = double(Mask);\n\n% Define fitting parameters\nEchoTime  = [12.8000; 25.6000; 38.4000; 51.2000; 64.0000; 76.8000; 89.6000; 102.4000; 115.2000; 128.0000; 140.8000; 153.6000; 166.4000; 179.2000; 192.0000; 204.8000; 217.6000; 230.4000; 243.2000; 256.0000; 268.8000; 281.6000; 294.4000; 307.2000; 320.0000; 332.8000; 345.6000; 358.4000; 371.2000; 384.0000];\nModel.Prot.SEdata.Mat = [ EchoTime ];\n\n% MET2w MRI data at different TE values\nME_TE_1 = imrotate(squeeze(data.MET2data(:,:,:,1).*data.Mask),-90);\nME_TE_2 = imrotate(squeeze(data.MET2data(:,:,:,10).*data.Mask),-90);\nME_TE_3 = imrotate(squeeze(data.MET2data(:,:,:,20).*data.Mask),-90);\nME_TE_4 = imrotate(squeeze(data.MET2data(:,:,:,30).*data.Mask),-90);\n\n% Fit the data\nFitResults_mwf = FitData(data,Model,0);\n\nMWF = imrotate(squeeze(FitResults_mwf.MWF.*data.Mask), -90);\nT2MW = imrotate(squeeze(FitResults_mwf.T2MW.*data.Mask), -90);\nT2IEW = imrotate(squeeze(FitResults_mwf.T2IEW.*data.Mask), -90);\n\n%% Export\n\nsave(\"multiexpo_T2_image.mat\", \"ME_TE_1\", \"ME_TE_2\", \"ME_TE_3\", \"ME_TE_4\", \"EchoTime\", \"FitResults_mwf\", \"MWF\", \"T2MW\", \"T2IEW\")\n\n","type":"content","url":"/t2-mapping#data-fitting-1","position":23},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"type":"lvl3","url":"/t2-mapping#t2applications","position":24},{"hierarchy":{"lvl1":"T2 Mapping","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"content":"","type":"content","url":"/t2-mapping#t2applications","position":25},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"Myelin water fraction (MWF) imaging","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"type":"lvl4","url":"/t2-mapping#myelin-water-fraction-mwf-imaging","position":26},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"Myelin water fraction (MWF) imaging","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"content":"Myelin water fraction (MWF) imaging demonstrates the clinical relevance of multi-exponential T2 mapping \n\nKumar et al., 2012\n\nMacKay et al., 1994, given that myelin quantification could help identify potential biomarkers for diseases such as multiple sclerosis (MS). Although MWF technically does not directly measure myelin but rather quantifies the amount of total water trapped between the myelin sheaths, it is argued that myelin can be conceptualized as water, as it constitutes its primary composition \n\nAlonso-Ortiz et al., 2015.\n\nConventional T2-weighted images often display hyperintense lesions in MS patients. Unfortunately, these hyperintensities lack specificity for the disease and can be indistinguishable from other biological phenomena such as inflammation, edema and axonal loss \n\nAlonso-Ortiz et al., 2015\n\nLee et al., 2021. MWF holds promise as a potential biomarker for identifying early microstructural changes in myelin, which could improve our understanding of demyelinating diseases such as MS, facilitating both early diagnosis and monitoring of disease progression.\n\nAs described by \n\nEq. 3.8, MWF represents the proportion of the MRI signal attributed to myelin water relative to the total water content in the brain. This total water content includes myelin water (MW) and intra/extracellular water (IEW), also referred to as axonal water \n\nLee et al., 2021.\\textit{MWF} = \\frac{S_{MW}e^{-TE/T_{2,MW}}}{S_{MW}e^{-TE/T_{2,MW}} + S_{IEW}e^{-TE/T_{2,IEW}}}\n\nDirect imaging of myelin itself is challenging due to its very short T2 relaxation times. Instead, an alternative is to image myelin-associated water (MW), which has slightly longer T2 relaxation times, typically around 20 ms \n\nLee et al., 2021. While these times are still short, they are measurable with standard spin-echo MRI sequences. Myelin Water Fraction (MWF) imaging takes advantage of this to differentiate and quantify the signal from myelin-associated water, providing a more feasible approach to studying myelin.","type":"content","url":"/t2-mapping#myelin-water-fraction-mwf-imaging","position":27},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"T2* and quantitative susceptibility mapping (QSM)","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"type":"lvl4","url":"/t2-mapping#t2-and-quantitative-susceptibility-mapping-qsm","position":28},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"T2* and quantitative susceptibility mapping (QSM)","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"content":"Quantitative susceptibility mapping (QSM) is another quantitative MRI technique, which measures variations in tissue magnetic susceptibility \n\nRuetten et al., 2019\n\nWang & Liu, 2015. By assessing the differences in magnetic susceptibility between various tissues, QSM can accurately quantify paramagnetic substances like iron, calcium and oxygen, as well as diamagnetic substances such as myelin \n\nRuetten et al., 2019. The ability to measure these substances has considerable clinical potential, as they provide valuable insights into tissue physiology and integrity. For instance, alterations in iron levels have been linked to neurodegenerative diseases like multiple sclerosis \n\nStephenson et al., 2014 and Parkinson‚Äôs disease \n\nChen et al., 2019, making QSM a promising technique for identifying biomarkers for these neurodegenerative disorders and emphasizing their importance in clinical research.\n\nIn MRI, the acquired signal is complex, consisting of a magnitude and phase component. While traditional contrasts such as T1, T2 and T2* only exploit the magnitude of the MRI signal, the phase component holds valuable information about tissue magnetic susceptibility. This is fundamental for QSM imaging.\n\nAs we have covered in \n\na previous section, T2* accounts for both T2 relaxation times and the relaxation due to magnetic field inhomogeneities, characterized by T2‚Äô. These inhomogeneities induce signal dephasing in MRI. As differences in magnetic susceptibility between tissues are a primary cause of these inhomogeneities, phase information is crucial for measuring tissue susceptibility \n\nRuetten et al., 2019. In QSM, the combination of both magnitude and phase data from T2* acquisitions enables the quantification and spatial mapping of magnetic susceptibility within tissues \n\nShmueli, 2020.\n\nThe following figure shows different susceptibility distributions in ppm a brain resuting from a B0 field map, simulated at 7 T. Two components of the B0 fields were seperated out: a high frequency component (left) and a low frequency component (middle).\n\n\n\nFigure¬†3.8:Susceptibility distributions in ppm a brain resuting from a B0 field map, simulated at 7 T. Two components of the B0 fields were seperated out: a high frequency component (left) and a low frequency component (middle). This figure was generated by reusing","type":"content","url":"/t2-mapping#t2-and-quantitative-susceptibility-mapping-qsm","position":29},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"Benefits and pitfalls of multi-exponential T2 mapping","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"type":"lvl4","url":"/t2-mapping#benefits-and-pitfalls-of-multi-exponential-t2-mapping","position":30},{"hierarchy":{"lvl1":"T2 Mapping","lvl4":"Benefits and pitfalls of multi-exponential T2 mapping","lvl3":"Applications","lvl2":"Multiexponential T2 mapping"},"content":"The primary advantage of multi-exponential T2 mapping lies in its improved accuracy in depicting the T2 relaxation of complex tissue microstructure. By considering each voxel as multi-compartmental with multiple tissues each having distinct T2 relaxation times, multiexponential T2 mapping has proven to be more accurate for capturing the T2 relaxation of complex, heterogeneous tissues. As we saw in the previous sections, this makes multi-exponential T2 mapping particularly advantageous in applications such as myelin water fraction imaging, where it is crucial to distinguish the fraction of water attributed to myelin to better understand demyelinating diseases such as MS \n\nAlonso-Ortiz et al., 2015.\n\nHowever, acquiring multi-exponential T2 mapping comes with its challenges. First, the increased complexity of multi-exponential mapping compared to mono-exponential models results in longer acquisition times \n\nKumar et al., 2012. Additionally, multi-exponential methods are also sensitive to noise \n\nDula et al., 2009, which can make accurate fittings challenging.\n\nIn conclusion, the choice of mono-exponential versus multi-exponential will depend on the specific clinical or research application as well as the complexity of the tissues being studied. While mono-exponential T2 mapping offers simplicity and efficiency, multi-exponential T2 mapping provides a comprehensive and accurate characterization of tissue properties, particularly in heterogeneous or pathological tissues.","type":"content","url":"/t2-mapping#benefits-and-pitfalls-of-multi-exponential-t2-mapping","position":31},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Exercises"},"type":"lvl2","url":"/t2-mapping#exercises","position":32},{"hierarchy":{"lvl1":"T2 Mapping","lvl2":"Exercises"},"content":"a. Using \n\nFigure 3.3, determine the approximate optimal echo time for T2 contrast between white matter and gray matter.\n\nb. Repeat for the T2* signal curves.\n\nc. Observe \n\nFigure 3.1, which shows the signal at different TE values and the corresponding T2 map. In practice, which TE out of these four images would you choose for a T2-weighted image and explain why that value coincides or doesn‚Äôt with the optimal TE you found above.\n\na. Using \n\nFigure 3.5, determine the echo time at which the signal myelin water (MW) signal has reduced by: 50%, 63%, and 90%.\n\nb. Using the signal curve for intra/extra-cellular (IEW) water presented in the same figure, determine the echo time at which the signal has reduced by: 50%, 63%, and 90%.\n\nc. Without fitting, estimate the T2 value for MW and IEW in this figure.\n\nd. Determine the (erroneous) mono-exponential T2 value for voxels that would contain 50% MW and 50% IEW - is it closer to the T2 value of MW or IEW?\n\nUsing \n\nEq. 3.8 and the MW/IEW T2 values estimated in \n\nExercise¬†2, calculate the myelin water fraction (MWF) values at the following TEs: 25, 50, 75, 100, 200, 300. Assume that there is 50% MW and 50% IEW.\n\na. The signal curves in \n\nFigure 3.4 were simulated for different SNR values, however these are relative to the maximum signal (i.e. TE=0). Using Binder or MATLAB and the notebook that was used to generate that figure, estimate the SNR of images acquired TE = 12.8, 128, 256, and 384 ms for a maximum signal SNR of 100.\n\nb. Repeat the same calculations for a T2* of 30 ms.\n\nc. Comment on these results and on how they would impact your imaging protocol planning. What‚Äôs the maximum TE you think is useful for each case?","type":"content","url":"/t2-mapping#exercises","position":33},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-1-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-01-DoubleAngle\"\ndata_file = \"da_fig1.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nnom_first_ang = mat_contents[\"nom_first_ang\"][0][0]\nB1 = mat_contents[\"B1\"][0]\nTR_range = mat_contents[\"TR_range\"][0]\nB1_varTR = mat_contents[\"B1_varTR\"]\nlinfit = mat_contents[\"linfit\"]\n\n## Plot\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\nwm_data = [dict(\n            visible = False,\n            x = B1,\n            y = B1_varTR[ii,:,0],\n            name = \"T1 = 900 ms (WM)\",\n            line=dict(color=\"blue\", width=2),\n            hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nwm_data[22]['visible'] = True\n\n\ngm_data = [dict(\n        visible = False,\n        x = B1,\n        y = B1_varTR[ii,:,1],\n        name = \"T1 = 1500 ms (GM)\",\n        line=dict(color=\"orange\", width=2),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\ngm_data[22]['visible'] = True\n\ncsf_data = [dict(\n        visible = False,\n        x = B1,\n        y = B1_varTR[ii,:,2],\n        name = \"T1 = 4000 ms (CSF)\",\n        line=dict(color=\"green\", width=2),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\ncsf_data[22]['visible'] = True\n\nb1_data = [dict(\n        visible = False,\n        x = B1,\n        y = B1,\n        name = \"B1 identity line\",\n        line=dict(color=\"black\", width=1, dash = 'dash'),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nb1_data[22]['visible'] = True\n\ndata = wm_data + gm_data + csf_data + b1_data\n\n# Create and add slider\nsteps = []\n      \nfor i in range(len(TR_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(b1_data)},],  # layout attribute\n        label = str(TR_range[i])\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    active=22,\n    currentvalue={\"prefix\": \"TR (ms) = \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Computed B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.50,\n            y=-0.15,\n            showarrow=False,\n            text='Actual B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig1.html', config = config)\n","type":"content","url":"/figure-4-1-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-1-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-01-DoubleAngle\"\ndata_file = \"da_fig2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nnom_first_ang = mat_contents[\"nom_first_ang\"][0][0]\nB1 = mat_contents[\"B1\"][0]\nTR_range = mat_contents[\"TR_range\"][0]\nB1_hard = mat_contents[\"B1_hard\"]\nB1_ideal = mat_contents[\"B1_ideal\"]\n\n## Plot\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\nhard_data = [dict(\n            visible = False,\n            x = B1,\n            y = np.abs(B1_hard[ii,:]),\n            name = \"Refocusing pulse = 180*B1 deg\",\n            line=dict(color=\"red\", width=2),\n            hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nhard_data[22]['visible'] = True\n\n\nideal_data = [dict(\n        visible = False,\n        x = B1,\n        y = np.abs(B1_ideal[ii,:]),\n        name = \"Refocusing pulse = 180 deg\",\n        line=dict(color=\"blue\", width=2),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nideal_data[22]['visible'] = True\n\nb1_data = [dict(\n        visible = False,\n        x = B1,\n        y = B1,\n        name = \"B1 identity line\",\n        line=dict(color=\"black\", width=1, dash = 'dash'),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nb1_data[22]['visible'] = True\n\ndata = hard_data + ideal_data + b1_data\n\n# Create and add slider\nsteps = []\n      \nfor i in range(len(TR_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(b1_data)},],  # layout attribute\n        label = str(TR_range[i])\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    active=22,\n    currentvalue={\"prefix\": \"TR (ms) = \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Computed B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.50,\n            y=-0.15,\n            showarrow=False,\n            text='Actual B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig2.html', config = config)\n","type":"content","url":"/figure-4-1-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-1-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-01-DoubleAngle\"\ndata_file = \"da_fig3.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nnom_first_ang = mat_contents[\"nom_first_ang\"][0][0]\nB1 = mat_contents[\"B1\"][0]\nTR_range = mat_contents[\"TR_range\"][0]\nB1_hard = mat_contents[\"B1_hard\"]\nB1_ideal = mat_contents[\"B1_ideal\"]\nB1_composite = mat_contents[\"B1_composite\"]\n\n## Plot\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\nhard_data = [dict(\n            visible = False,\n            x = B1,\n            y = np.abs(B1_hard[ii,:]),\n            name = \"Refocusing pulse = 180*B1 deg\",\n            line=dict(color=\"red\", width=2),\n            hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nhard_data[22]['visible'] = True\n\ncomposite_data = [dict(\n        visible = False,\n        x = B1,\n        y = np.abs(B1_composite[ii,:]),\n        name = \"Composite refocusing pulse = 90x-180y-90x\",\n        line=dict(color=\"blue\", width=2),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\ncomposite_data[22]['visible'] = True\n\nb1_data = [dict(\n        visible = False,\n        x = B1,\n        y = B1,\n        name = \"B1 identity line\",\n        line=dict(color=\"black\", width=1, dash = 'dash'),\n        hoverinfo = \"y\") for ii in range(len(TR_range))]\n\nb1_data[22]['visible'] = True\n\ndata = hard_data + composite_data + b1_data\n\n# Create and add slider\nsteps = []\n      \nfor i in range(len(TR_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(b1_data)},],  # layout attribute\n        label = str(TR_range[i])\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    active=22,\n    currentvalue={\"prefix\": \"TR (ms) = \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Computed B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.50,\n            y=-0.15,\n            showarrow=False,\n            text='Actual B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig3.html', config = config)\n","type":"content","url":"/figure-4-1-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig1.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nparams = mat_contents[\"params\"]\nTR1_range = mat_contents[\"TR1_range\"][0]\nTR2_range = mat_contents[\"TR2_range\"][0]\nsignal1_WM = mat_contents[\"signal1_WM\"]\nsignal2_WM = mat_contents[\"signal2_WM\"]\nsignal1_GM = mat_contents[\"signal1_GM\"]\nsignal2_GM = mat_contents[\"signal2_GM\"]\nsignal1_CSF = mat_contents[\"signal1_CSF\"]\nsignal2_CSF = mat_contents[\"signal2_CSF\"]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\ndata1_1 = [dict(\n        visible = False,\n        line=dict(color='royalblue'),\n        x = params[\"EXC_FA\"][0][0][0].astype(int),\n        y = abs(np.squeeze(np.asarray(signal1_WM[ii]))),\n        name = 'S<sub>1</sub>: T<sub>1</sub> = 0.9 s (White Matter)',\n        text = 'S<sub>1</sub>: T<sub>1</sub> = 0.9 s (White Matter)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata1_1[4]['visible'] = True\n\ndata1_2 = [dict(\n        visible = False,\n        line=dict(color='royalblue', dash='dash'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal2_WM[ii]))),\n        name = 'S<sub>2</sub>: T<sub>1</sub> = 0.9 s (White Matter)',\n        text = 'S<sub>2</sub>: T<sub>1</sub> = 0.9 s (White Matter)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata1_2[4]['visible'] = True\n\ndata2_1 = [dict(\n        visible = False,\n        line=dict(color='firebrick'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_GM[ii]))),\n        name = 'S<sub>1</sub>: T<sub>1</sub> = 1.5 s (Grey Matter)',\n        text = 'S<sub>1</sub>: T<sub>1</sub> = 1.5 s (Grey Matter)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata2_1[4]['visible'] = True\n\ndata2_2 = [dict(\n        visible = False,\n        line=dict(color='firebrick', dash='dash'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal2_GM[ii]))),\n        name = 'S<sub>2</sub>: T<sub>1</sub> = 1.5 s (Grey Matter)',\n        text = 'S<sub>2</sub>: T<sub>1</sub> = 1.5 s (Grey Matter)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata2_2[4]['visible'] = True\n\ndata3_1 = [dict(\n        visible = False,\n        line=dict(color='orange'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_CSF[ii]))),\n        name = 'S<sub>1</sub>: T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n        text = 'S<sub>1</sub>: T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata3_1[4]['visible'] = True\n\ndata3_2 = [dict(\n        visible = False,\n        line=dict(color='orange', dash='dash'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal2_CSF[ii]))),\n        name = 'S<sub>2</sub>: T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n        text = 'S<sub>2</sub>: T<sub>1</sub> = 4.0 s (Cerebrospinal Fluid)',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata3_2[4]['visible'] = True\n\ndata = data1_1 + data1_2 + data2_1 +data2_2 + data3_1 + data3_2\n\nsteps = []\nfor i in range(len(TR1_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1_1)],\n        label = str(TR1_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders=[\n    dict(\n        x = 0,\n        y = -0.09,\n        active = 3,\n        currentvalue = {\"prefix\": \"TR1 value (ms): <b>\"},\n        pad = {\"t\": 50, \"b\": 10},\n        steps = steps)]\n\nlayout = go.Layout(\n    width=650,\n    height=520,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Long. Magnetization (M<sub>z</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.007,\n            y=-0.25,\n            showarrow=False,\n            text='TR<sub>2</sub> = 5TR<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=12\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params[\"EXC_FA\"][0][0][0][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)\n","type":"content","url":"/figure-4-2-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nparams = mat_contents[\"params\"]\nNex_range = mat_contents[\"Nex_range\"][0]\nsignal1_analytical = mat_contents[\"signal1_analytical\"]\nsignal2_analytical = mat_contents[\"signal2_analytical\"]\nsignal1_blochsim = mat_contents[\"signal1_blochsim\"]\nsignal2_blochsim = mat_contents[\"signal2_blochsim\"]\n\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\ndata1_1 = [dict(\n        visible = False,\n        line=dict(color='royalblue', dash='dash'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_analytical[ii]))),\n        name = 'S<sub>1</sub>: Analytical Solution',\n        text = 'S<sub>1</sub>: Analytical Solution',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata1_1[7]['visible'] = True\n\ndata1_2 = [dict(\n        visible = False,\n        line=dict(color='firebrick', dash='dash'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal2_analytical[ii]))),\n        name = 'S<sub>2</sub>: Analytical Solution',\n        text = 'S<sub>2</sub>: Analytical Solution',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata1_2[7]['visible'] = True\n\ndata2_1 = [dict(\n        visible = False,\n        line=dict(color='royalblue'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_blochsim[ii]))),\n        name = 'S<sub>1</sub>: Bloch Simulation',\n        text = 'S<sub>1</sub>: Bloch Simulation',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata2_1[7]['visible'] = True\n\ndata2_2 = [dict(\n        visible = False,\n        line=dict(color='firebrick'),\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal2_blochsim[ii]))),\n        name = 'S<sub>2</sub>: Bloch Simulation',\n        text = 'S<sub>2</sub>: Bloch Simulation',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata2_2[7]['visible'] = True\n\ndata = data1_1 + data2_1 + data1_2 + data2_2\n\nsteps = []\nfor i in range(len(Nex_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1_1)],\n        label = str(Nex_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 5,\n    currentvalue = {\"prefix\": \"n<sup>th</sup> TR1-TR2: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][0][0][0][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)","type":"content","url":"/figure-4-2-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig3.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nparams = mat_contents[\"params\"]\nNex_range = mat_contents[\"Nex_range\"][0]\nsignal1_ideal_spoil = mat_contents[\"signal1_ideal_spoil\"]\nsignal1_optimal_crush_and_rf_spoil = mat_contents[\"signal1_optimal_crush_and_rf_spoil\"]\nsignal1_no_gradient_and_rf_spoil = mat_contents[\"signal1_no_gradient_and_rf_spoil\"]\n\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\n\n# PYTHON CODE\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\ndata1_1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_ideal_spoil[ii]))),\n        name = 'Ideal Spoiling',\n        text = 'Ideal Spoiling',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata1_1[10]['visible'] = True\n\ndata2_1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_optimal_crush_and_rf_spoil[ii]))),\n        name = 'Gradient & RF Spoiling',\n        text = 'Gradient & RF Spoiling',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata2_1[10]['visible'] = True\n\ndata3_1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(signal1_no_gradient_and_rf_spoil[ii]))),\n        name = 'No Spoiling',\n        text = 'No Spoiling',\n        hoverinfo = 'x+y+text') for ii in range(len(Nex_range))]\n\ndata3_1[10]['visible'] = True\n\ndata = data1_1 + data2_1+ data3_1\n\nsteps = []\nfor i in range(len(Nex_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1_1)],\n        label = str(Nex_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 10,\n    currentvalue = {\"prefix\": \"n<sup>th</sup> TR1-TR2: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][0][0][0][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)","type":"content","url":"/figure-4-2-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig4.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nparams = mat_contents[\"params\"]\nT1_range = mat_contents[\"T1_range\"][0]\nr_analytical = mat_contents[\"r_analytical\"]\nr_approximation = mat_contents[\"r_approximation\"]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(r_analytical[ii]))),\n        name = 'Analytical',\n        text = 'Analytical',\n        hoverinfo = 'x+y+text') for ii in range(len(T1_range))]\n\ndata1[10]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(r_approximation[ii]))),\n        name = 'Approximation',\n        text = 'Approximation',\n        hoverinfo = 'x+y+text') for ii in range(len(T1_range))]\n\ndata2[10]['visible'] = True\n\ndata = data1 + data2\n\nsteps = []\nfor i in range(len(T1_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(T1_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 10,\n    currentvalue = {\"prefix\": \"T1 value (ms): <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='r = S<sub>2</sub>/S<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][0][0][0][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)\n","type":"content","url":"/figure-4-2-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-5","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig5.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nparams = mat_contents[\"params\"]\nTR1_range = mat_contents[\"TR1_range\"][0]\nr_analytical = mat_contents[\"r_analytical\"]\nr_approximation = mat_contents[\"r_approximation\"]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\n# PYTHON CODE\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(r_analytical[ii]))),\n        name = 'Analytical',\n        text = 'Analytical',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata1[2]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(r_approximation[ii]))),\n        name = 'Approximation',\n        text = 'Approximation',\n        hoverinfo = 'x+y+text') for ii in range(len(TR1_range))]\n\ndata2[2]['visible'] = True\n\ndata = data1 + data2\n\nsteps = []\nfor i in range(len(TR1_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(TR1_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 2,\n    currentvalue = {\"prefix\": \"TR1 value (ms): <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='r = S<sub>2</sub>/S<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][0][0][0][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)\n","type":"content","url":"/figure-4-2-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-6","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig6.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nparams = mat_contents[\"params\"]\nn_range = mat_contents[\"n_range\"][0]\nr_analytical = mat_contents[\"r_analytical\"]\nr_approximation = mat_contents[\"r_approximation\"]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\n\n\ninit_notebook_mode(connected=True)\n\ndata1 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(r_analytical[ii]))),\n        name = 'Analytical',\n        text = 'Analytical',\n        hoverinfo = 'x+y+text') for ii in range(len(n_range))]\n\ndata1[2]['visible'] = True\n\ndata2 = [dict(\n        visible = False,\n        mode = 'lines',\n        x = params[\"EXC_FA\"][0][0][0],\n        y = abs(np.squeeze(np.asarray(r_approximation[ii]))),\n        name = 'Approximation',\n        text = 'Approximation',\n        hoverinfo = 'x+y+text') for ii in range(len(n_range))]\n\ndata2[2]['visible'] = True\n\ndata = data1 + data2\n\nsteps = []\nfor i in range(len(n_range)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(data1)],\n        label = str(n_range[i])\n        )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.02,\n    active = 2,\n    currentvalue = {\"prefix\": \"n value: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps)]\n\nlayout = go.Layout(\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.18,\n            showarrow=False,\n            text='Excitation Flip Angle (¬∞)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.15,\n            y=0.5,\n            showarrow=False,\n            text='r = S<sub>2</sub>/S<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[0, params['EXC_FA'][0][0][0][-1]],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=False,\n        range=[0, 1],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.9,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)\n","type":"content","url":"/figure-4-2-6","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-7","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig7.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nB1map_raw = mat_contents[\"B1map_raw\"]\nAFIData1 = mat_contents[\"AFIData1\"]\nAFIData2 = mat_contents[\"AFIData2\"]\nmask = mat_contents[\"mask\"]\nxAxis = mat_contents[\"xAxis\"][0]\nyAxis = mat_contents[\"yAxis\"][0]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\nfrom plotly import tools\n\n# Masking B1 map\nB1map_raw = np.asarray(B1map_raw)\nmask = np.asarray(mask)\nB1map_raw_masked = B1map_raw*mask\nB1map_raw_masked[np.isnan(B1map_raw_masked)] = 0\n\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=AFIData1,\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=False,\n                   name = 'Signal1')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=AFIData2,\n                   colorscale='Gray',\n                   showscale = False,\n                   visible=True,\n                   name = 'Signal2')\ntrace3 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=B1map_raw_masked,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'B1 values')\n\ndata=[trace1, trace2, trace3]\n\n\nupdatemenus = list([\n    dict(active=1,\n         x = 0.09,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = 'Signal 1',\n                 method = 'update',\n                 args = [{'visible': [True, False, True]},\n                         ]),\n            dict(label = 'Signal 2',\n                 method = 'update',\n                 args = [{'visible': [False, True, True]},\n                           ]),\n        ])\n    )\n])\n\nlayout = dict(\n    width=560,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.07,\n            y=1.15,\n            showarrow=False,\n            text='Input Data',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.60,\n            y=1.15,\n            showarrow=False,\n            text='Raw B<sub>1</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.12,\n            y=1.15,\n            showarrow=False,\n            text='B<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.58]),\n    yaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    xaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0.40, 0.98]),\n    yaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1], anchor='x2'),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-heatmap', config = config)","type":"content","url":"/figure-4-2-7","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-2-8","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\ndata_file = \"fig7.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nB1map_raw = mat_contents[\"B1map_raw\"]\nAFIData1 = mat_contents[\"AFIData1\"]\nAFIData2 = mat_contents[\"AFIData2\"]\nmask = mat_contents[\"mask\"]\nxAxis = mat_contents[\"xAxis\"][0]\nyAxis = mat_contents[\"yAxis\"][0]\n\n# Masking B1 map\nB1map_raw = np.asarray(B1map_raw)\nmask = np.asarray(mask)\nB1map_raw_masked = B1map_raw*mask\nB1map_raw_masked[np.isnan(B1map_raw_masked)] = 0\n\ndata_dir = Path(\"../../../../DATA/qmrlab-mooc/04-B1-02-AFI\")\ndata_file = \"fig8.mat\"\n\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nB1map_filtered = mat_contents[\"B1map_filtered\"]\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n# PYTHON CODE\nfrom plotly import tools\n\n# Masking B1 map\nB1map_filtered = np.asarray(B1map_filtered)\nmask = np.asarray(mask)\nB1map_filtered_masked = B1map_filtered*mask\nB1map_filtered_masked[np.isnan(B1map_filtered_masked)] = 0\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=B1map_raw_masked,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   showscale = False,\n                   visible=True,\n                   name = 'B1 values')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=B1map_filtered_masked,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True,\n                   name = 'B1 values')\n\ndata=[trace1, trace2]\n\nlayout = dict(\n    width=560,\n    height=310,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.04,\n            y=1.15,\n            showarrow=False,\n            text='Raw B<sub>1</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.60,\n            y=1.15,\n            showarrow=False,\n            text='Filtered B<sub>1</sub> map',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=1.12,\n            y=1.15,\n            showarrow=False,\n            text='B<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.58]),\n    yaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    xaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0.40, 0.98]),\n    yaxis2 = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1], anchor='x2'),\n    showlegend = False,\n    autosize = False,\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-heatmap', config = config)","type":"content","url":"/figure-4-2-8","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\n\n# Imports\n\nfrom pathlib import Path\nimport pandas as pd\nimport json\nimport nibabel as nib\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport glob\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-02-AFI\"\n\n# Configurations\ndata_folder_name = dataset_path / \"04-B1-03-Filtering/images\"\n    \ndef get_image(filename):\n    # Load image data\n    data = nib.load(Path(data_folder_name) / filename)\n    data_volume = data.get_fdata() \n\n    dims = data_volume.shape\n\n    im = np.squeeze(data_volume[:,:])\n\n    xAxis = np.linspace(0,im.shape[0]-1, num=im.shape[0])\n    yAxis = np.linspace(0,im.shape[1]-1, num=im.shape[1])\n    return im, xAxis, yAxis\n\nim_da_raw1, xAxis_da_raw1, yAxis_da_raw1 = get_image('raw_da_1.nii.gz')\nim_da_raw2, xAxis_da_raw2, yAxis_da_raw1 = get_image('raw_da_2.nii.gz')\nim_da_b1, xAxis_da_b1, yAxis_da_b1 = get_image('b1_clt_tse.nii.gz')\n\nim_afi_raw1, xAxis_afi_raw1, yAxis_afi_raw1 = get_image('raw_afi_1.nii.gz')\nim_afi_raw2, xAxis_afi_raw2, yAxis_afi_raw1 = get_image('raw_afi_2.nii.gz')\nim_afi_b1, xAxis_afi_b1, yAxis_afi_b1 = get_image('b1_clt_afi.nii.gz')\n\nim_bs_raw1, xAxis_bs_raw1, yAxis_bs_raw1 = get_image('raw_bs_1.nii.gz')\nim_bs_raw2, xAxis_bs_raw2, yAxis_bs_raw1 = get_image('raw_bs_1.nii.gz')\nim_bs_b1, xAxis_bs_b1, yAxis_bs_b1 = get_image('b1_clt_gre_bs_cr_fermi.nii.gz')\n\nmask, xAxis_mask, yAxis_mask = get_image('brain_mask_es_2x2x5.nii.gz')\n\nim_da_raw1 = np.flipud(im_da_raw1)\nim_da_raw2 = np.flipud(im_da_raw2)\nim_da_b1 = np.flipud(im_da_b1)\n\nim_afi_raw1 = np.flipud(im_afi_raw1)\nim_afi_raw2 = np.flipud(im_afi_raw2)\nim_afi_b1 = np.flipud(im_afi_b1)\n\nim_bs_raw1 = np.flipud(im_bs_raw1)\nim_bs_raw2 = np.flipud(im_bs_raw2)\nim_bs_b1 = np.flipud(im_bs_b1)\n\nmask = np.flipud(mask)\n\n# Normalize raw\n\nim_da_raw1 = im_da_raw1 / np.max([np.max(im_da_raw1*mask),np.max(im_da_raw2*mask)])*1000\nim_da_raw2 = im_da_raw2 / np.max([np.max(im_da_raw1*mask),np.max(im_da_raw2*mask)])*1000\n\nim_afi_raw1 = im_afi_raw1 / np.max([np.max(im_afi_raw1*mask),np.max(im_afi_raw2*mask)])*1000\nim_afi_raw2 = im_afi_raw2 / np.max([np.max(im_afi_raw1*mask),np.max(im_afi_raw2*mask)])*1000\n\nim_bs_raw1 = im_bs_raw2 / np.max([np.max(np.abs(im_bs_raw1)*mask),np.max(np.abs(im_bs_raw2)*mask)])*np.pi\nim_bs_raw2 = im_bs_raw2 / np.max([np.max(np.abs(im_bs_raw1)*mask),np.max(np.abs(im_bs_raw2)*mask)])*np.pi\n\n\n## Plot\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n# Module imports\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import init_notebook_mode, iplot, plot\nconfig={'showLink': False, 'displayModeBar': False, 'responsive': True}\n\ninit_notebook_mode(connected=True)\n\nimport os\nimport markdown\nimport random\nfrom scipy.integrate import quad\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nxAxis_raw = np.linspace(0,128*2-1, num=128*2)\nxAxis_b1 = np.linspace(0,128-1, num=128*2)\nyAxis = np.linspace(0,88-1, num=88*1)\n\n# DA acqs\nda_acqs = np.concatenate((im_da_raw1, im_da_raw2), axis=1)\n\n# AFI acqs\nafi_acqs = np.concatenate((im_afi_raw1, im_afi_raw2), axis=1)\n\n# DA acqs\nbs_acqs = np.concatenate((im_bs_raw1, im_bs_raw2), axis=1)\n\n# Mask\n\nmasks_concat = np.concatenate((mask, mask), axis=1)\n\ntrace_da_raw = go.Heatmap(x = xAxis_raw,\n                   y = yAxis,\n                   z=masks_concat*da_acqs,\n                   zmin=0,\n                   zmax=1000,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=True)\n\ntrace_da_b1 = go.Heatmap(x = xAxis_b1,\n                   y = yAxis,\n                   z=mask*im_da_b1,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   colorbar={\"title\": 'B<sub>1</sub>',\n                             'titlefont': dict(\n                                   family='Times New Roman',\n                                   size=26,\n                                   )\n                            },\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=True)\n                   \ntrace_afi_raw = go.Heatmap(x = xAxis_raw,\n                   y = yAxis,\n                   z=masks_concat*afi_acqs,\n                   zmin=0,\n                   zmax=1000,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=False)\n\ntrace_afi_b1 = go.Heatmap(x = xAxis_b1,\n                   y = yAxis,\n                   z=mask*im_afi_b1,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   colorbar={\"title\": 'B<sub>1</sub> (ms)',\n                             'titlefont': dict(\n                                   family='Times New Roman',\n                                   size=26,\n                                   )\n                            },\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=False)\n                   \ntrace_bs_raw = go.Heatmap(x = xAxis_raw,\n                   y = yAxis,\n                   z=masks_concat*bs_acqs,\n                   zmin=-np.pi,\n                   zmax=np.pi,\n                   colorscale='gray',\n                   showscale = False,\n                   visible=False)\n\ntrace_bs_b1 = go.Heatmap(x = xAxis_b1,\n                   y = yAxis,\n                   z=mask*im_bs_b1,\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   colorbar={\"title\": 'B<sub>1</sub> (ms)',\n                             'titlefont': dict(\n                                   family='Times New Roman',\n                                   size=26,\n                                   )\n                            },\n                   xaxis='x2',\n                   yaxis='y2',\n                   visible=False)\n\ndata=[trace_da_raw, trace_da_b1, trace_afi_raw, trace_afi_b1, trace_bs_raw, trace_bs_b1]\n\nupdatemenus = list([\n    dict(active=0,\n         x = 0.3,\n         xanchor = 'left',\n         y = -0.2,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = 'Double Angle Mapping',\n                 method = 'update',\n                 args = [{'visible': [True, True, False, False, False, False],\n                          'showscale': [False, True, False, False, False, False],},\n                         ]),\n            dict(label = 'Actual Flip angle Imaging',\n                 method = 'update',\n                 args = [\n                            {\n                            'visible': [False, False, True, True, False, False],\n                            'showscale': [False, False, False, True, False, False],},\n                           ]),\n            dict(label = 'Bloch-Siegert shift',\n                 method = 'update',\n                 args = [{'visible': [False, False, False, False, True, True],\n                            'showscale': [False, False, False, False, False, True],},\n                           ]),\n    ])\n    )\n])\n\nlayout = dict(\n    width=700,\n    height=400,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.09,\n            y=1.13,\n            showarrow=False,\n            text='ACQ 1',\n            font=dict(\n                family='Times New Roman',\n                size=28\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.49,\n            y=1.13,\n            showarrow=False,\n            text='ACQ 2',\n            font=dict(\n                family='Times New Roman',\n                size=28\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.9,\n            y=1.13,\n            showarrow=False,\n            text='B<sub>1</sub> (map)',\n            font=dict(\n                family='Times New Roman',\n                size=28\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,225], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 0.83]),\n    yaxis = dict(range = [0,120], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    xaxis2 = dict(range = [0,44], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0.65, 0.98]),\n    yaxis2 = dict(range = [0,120], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1], anchor='x2'),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-heatmap', config = config)\n\n","type":"content","url":"/figure-4-3-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.subplots import make_subplots\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\n\n## Setup for plots\nfig = make_subplots(rows=2, cols=1, vertical_spacing = 0.2,\n                    subplot_titles=(\n    '<b>Signal</b>',\n    '<b>Mean-Convolved</b>',))\n\n# Setup signal\nsignal = np.zeros(100)\nsignal[10] = 1\n\nsignal[25:27] = 1\n\nsignal[50] = 1\nsignal[51] = -1\n\nsignal[50] = 1\nsignal[51] = -1\n\nsignal[70:90] = np.random.uniform(0.95,1.05,20)\n\n# Compute convolution\nconvolved = np.zeros(101)\n\nfor ii in range(1,100):\n    if ii <3 or ii>98:\n        continue\n    else:\n        convolved[ii] = (signal[ii-1]+signal[ii]+signal[ii+1])/3\n\nposition = np.arange(1,101)\n\nsignal_line = [dict(\n            visible = False,\n            x = position,\n            y = signal,\n            name = \"Signal\",\n            mode = 'lines',\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(position))]\n\nsignal_line[4]['visible'] = True\n\nmean_points = []\n\nmean_points.append(            \n        dict(\n                visible = False,\n                x = position[0:2],\n                y = np.array([0,0]),\n                name = \"Signal\",\n                hoverinfo = \"y\",\n                showlegend=False\n                ))\n\nfor ii in range(len(position)-2):\n    mean_points.append(            \n                dict(\n                    visible = False,\n                    x = position[ii:ii+3],\n                    y = signal[ii:ii+3],\n                    name = \"Signal\",\n                    hoverinfo = \"y\",\n                    showlegend=False))\n      \nmean_points.append(   \n            dict(\n                visible = False,\n                x = position[-2:],\n                y = np.array([0,0]),\n                name = \"Signal\",\n                hoverinfo = \"y\",\n                showlegend=False\n                ))\n            \nmean_points[4]['visible'] = True\n\nconvolved_line = [dict(\n            visible = False,\n            x = position,\n            y = convolved[0:ii+1],\n            name = \"Mean-Convolved\",\n            mode = 'lines',\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(position))]\n\nconvolved_line[4]['visible'] = True\n\n\ncur_point = []\n\nfor ii in range(len(position)):\n    cur_point.append(            \n                dict(\n                    visible = False,\n                    x = np.array(position[ii]),\n                    y = np.array(convolved[ii]),\n                    name = \"Current point\",\n                    hoverinfo = \"y\",\n                    showlegend=False))\n\ncur_point[4]['visible'] = True\n\n\n# Add traces\nfor ii in range(len(position)):\n    fig.add_trace(go.Scatter(signal_line[ii], line=dict(color=\"black\", width=2)), row= 1, col=1)\n\nfor ii in range(len(position)):\n    fig.add_trace(go.Scatter(mean_points[ii], marker=dict(\n        symbol='circle',\n        color='red',\n        size= 8,)\n        ), row= 1, col=1)\n\nfor ii in range(len(position)):\n    fig.add_trace(go.Scatter(convolved_line[ii], line=dict(color=\"blue\", width=2)), row= 2, col=1)\n\nfor ii in range(len(position)):\n    fig.add_trace(go.Scatter(cur_point[ii], marker=dict(\n        symbol='circle',\n        color='red',\n        size= 8,)\n        ), row= 2, col=1)\n\n# Create and add slider\nsteps = []\n      \nfor i in range(len(position)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(fig.data), \"showlegend\": [False] * len(fig.data)},],  # layout attribute\n        label = str(i+1)\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+1*len(position)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+2*len(position)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+3*len(position)] = True  # Toggle i'th trace to \"visible\"\n\n    steps.append(step)\n\nsliders = [dict(\n    active=4,\n    currentvalue={\"prefix\": \"Position: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0,100]\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [-1.1,1.1]\n    ),\n    \n    xaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0,100]\n    ),\n    yaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [-1.1,1.1]\n    ),\n    \n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig2.html', config = config)\n","type":"content","url":"/figure-4-3-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.subplots import make_subplots\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\n\n## Setup for plots\nfig = make_subplots(rows=2, cols=1, vertical_spacing = 0.2,\n                    subplot_titles=(\n    '<b>Signal</b>',\n    '<b>Gaussian-Convolved</b>',))\n\n# Setup signal\nsignal = np.zeros(100)\nsignal[10] = 1\n\nsignal[25:27] = 1\n\nsignal[50] = 1\nsignal[51] = -1\n\nsignal[50] = 1\nsignal[51] = -1\n\nsignal[70:90] = np.random.uniform(0.95,1.05,20)\n\n# Compute convolution\nmu = np.linspace(0.1,5,50)\n\ngauss_convolved = np.zeros([100, len(mu)])\n\ndef gaussian(x, mu, sig):\n    return (\n        1.0 / (np.sqrt(2.0 * np.pi) * sig) * np.exp(-np.power((x - mu) / sig, 2.0) / 2)\n    )\n\nfor ii in range(1,100):\n    if ii <5 or ii>95:\n        continue\n    else:\n        for jj in range(len(mu)):\n            x = np.arange(ii-4, ii+5)\n            gauss_convolved[ii, jj] = np.sum(signal[ii-4:ii+5]*gaussian(x, ii, mu[jj])/np.sum(gaussian(x, ii, mu[jj])))\n\nposition = np.arange(1,101)\n\nsignal_line = [dict(\n            visible = False,\n            x = position,\n            y = signal,\n            name = \"Signal\",\n            mode = 'lines',\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(mu))]\n\nsignal_line[0]['visible'] = True\n\n      \nconvolved_line = [dict(\n            visible = False,\n            x = position,\n            y = gauss_convolved[:, ii],\n            name = \"Mean-Convolved\",\n            mode = 'lines',\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(mu))]\n\nconvolved_line[0]['visible'] = True\n\n\n# Add traces\nfor ii in range(len(mu)):\n    fig.add_trace(go.Scatter(signal_line[ii], line=dict(color=\"black\", width=2)), row= 1, col=1)\n\n\nfor ii in range(len(mu)):\n    fig.add_trace(go.Scatter(convolved_line[ii], line=dict(color=\"blue\", width=2)), row= 2, col=1)\n\n\n# Create and add slider\nsteps = []\n      \nfor i in range(len(mu)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(fig.data), \"showlegend\": [False] * len(fig.data)},],  # layout attribute\n        label = str(np.round(mu[i], 1))\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+1*len(mu)] = True  # Toggle i'th trace to \"visible\"\n\n    steps.append(step)\n\nsliders = [dict(\n    active=0,\n    currentvalue={\"prefix\": \"Gaussian width: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0,100]\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [-1.1,1.1]\n    ),\n    \n    xaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0,100]\n    ),\n    yaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [-1.1,1.1]\n    ),\n    \n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig3.html', config = config)\n","type":"content","url":"/figure-4-3-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-03-Filtering\"\ndata_file = \"b1filt_fig1.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nb1_func = mat_contents[\"b1_func\"][0]\ngauss_b1_1d = mat_contents[\"gauss_b1_1d\"]\nmedian_b1_1d = mat_contents[\"median_b1_1d\"]\nspline_b1_1d = mat_contents[\"spline_b1_1d\"]\nvox_range = mat_contents[\"vox_range\"][0]\n\n## Plot\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\nposition = np.arange(1,len(b1_func)+1)\n\nb1_data = [dict(\n            visible = False,\n            x = position,\n            y = b1_func,\n            name = \"True signal\",\n            hoverinfo = \"y\") for ii in vox_range]\n\nb1_data[5]['visible'] = True\n\n\ndata_gauss = [dict(\n        visible = False,\n        x = position,\n        y = list(gauss_b1_1d[ii-1]),\n        name = \"Gaussian filtered\",\n        hoverinfo = \"y\") for ii in vox_range]\n\ndata_gauss[5]['visible'] = True\n\ndata_median = [dict(\n        visible = False,\n        x = position,\n        y = list(median_b1_1d[ii-1]),\n        name = \"Median filtered\",\n        hoverinfo = \"y\") for ii in vox_range]\n\ndata_median[5]['visible'] = 'legendonly'\n\ndata_spline = [dict(\n        visible = False,\n        x = position,\n        y = list(spline_b1_1d[ii-1]),\n        name = \"Spline filtered\",\n        hoverinfo = \"y\") for ii in vox_range]\n\ndata_spline[5]['visible'] = 'legendonly'\n\ndata = b1_data + data_gauss + data_median + data_spline\n\n# Create and add slider\nsteps = []\n      \nfor i in vox_range:\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(data_gauss)},],  # layout attribute\n        label = str(i)\n    )\n    step[\"args\"][0][\"visible\"][i-1] = True  # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    active=5,\n    currentvalue={\"prefix\": \"Filter width or spline/polynomial order: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig1.html', config = config)\n","type":"content","url":"/figure-4-3-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-5","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-03-Filtering\"\ndata_file = \"b1filt_fig2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nb1_func = mat_contents[\"b1_func\"][0]\nnoisy_b1= mat_contents[\"noisy_b1\"]\ngauss_b1_1d = mat_contents[\"gauss_b1_1d\"]\nmedian_b1_1d = mat_contents[\"median_b1_1d\"]\nspline_b1_1d = mat_contents[\"spline_b1_1d\"]\nSNR_range = mat_contents[\"SNR_range\"][0]\n\n## Plot\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.subplots import make_subplots\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\n\n## Setup for plots\nfig = make_subplots(rows=2, cols=2, vertical_spacing = 0.06,\n                    subplot_titles=(\n    '<b>Unfiltered</b>',\n    '<b>Gaussian</b>',\n    '<b>Median</b>',\n    '<b>Spline</b>',))\n\n\n\nposition = np.arange(1,len(b1_func)+1)\n\nb1_data = [dict(\n            visible = False,\n            x = position,\n            y = b1_func,\n            name = \"True signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(SNR_range))]\n\nb1_data[49]['visible'] = True\nb1_data[49]['showlegend'] = True\n\nnoisy_signal = [dict(\n            visible = False,\n            x = position,\n            y = list(noisy_b1[ii]),\n            name = \"Noisy signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(SNR_range))]\n\nnoisy_signal[49]['visible'] = True\nnoisy_signal[49]['showlegend'] = True\n\ngauss_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(gauss_b1_1d[ii]),\n            name = \"Gaussian filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(SNR_range))]\n\ngauss_b1[49]['visible'] = True\ngauss_b1[49]['showlegend'] = True\n\nmedian_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(median_b1_1d[ii]),\n            name = \"Median filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(SNR_range))]\n\nmedian_b1[49]['visible'] = True\nmedian_b1[49]['showlegend'] = True\n\nspline_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(spline_b1_1d[ii]),\n            name = \"Spline interpolation\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(SNR_range))]\n\nspline_b1[49]['visible'] = True\nspline_b1[49]['showlegend'] = True\n\n# Add traces\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=2)), row= 1, col=1)\n\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(noisy_signal[ii], line=dict(color=\"grey\", width=2)), row= 1, col=1)\n\nb1_data[49]['showlegend'] = False\nnoisy_signal[49]['showlegend'] = False\n\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(gauss_b1[ii], line=dict(color=\"red\", width=3)), row= 1, col=2)\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 1, col=2)\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(noisy_signal[ii], line=dict(color=\"grey\", width=1)), row= 1, col=2)\n\nfor ii in range(len(SNR_range)):        \n    fig.add_trace(go.Scatter(median_b1[ii], line=dict(color=\"blue\", width=3)), row= 2, col=1)\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 2, col=1)\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(noisy_signal[ii], line=dict(color=\"grey\", width=1)), row= 2, col=1)\n    \nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(spline_b1[ii], line=dict(color=\"green\", width=3)), row= 2, col=2)\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 2, col=2)\nfor ii in range(len(SNR_range)):\n    fig.add_trace(go.Scatter(noisy_signal[ii], line=dict(color=\"grey\", width=1)), row= 2, col=2)\n    \n# Create and add slider\nsteps = []\n      \nfor i in range(len(SNR_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(fig.data), \"showlegend\": [False] * len(fig.data)},],  # layout attribute\n        label = str(i+1)\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+1*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+2*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+3*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+4*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+5*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+6*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+7*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+8*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+9*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+10*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n\n    step[\"args\"][0][\"showlegend\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+1*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+2*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+5*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+8*len(SNR_range)] = True  # Toggle i'th trace to \"visible\"\n\n    steps.append(step)\n\nsliders = [dict(\n    active=49,\n    currentvalue={\"prefix\": \"SNR: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig2.html', config = config)\n","type":"content","url":"/figure-4-3-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-6","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-03-Filtering\"\ndata_file = \"b1filt_fig3.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nb1_func = mat_contents[\"b1_func\"][0]\ndelta_b1= mat_contents[\"delta_b1\"][0]\ngauss_b1_1d = mat_contents[\"gauss_b1_1d\"]\nmedian_b1_1d = mat_contents[\"median_b1_1d\"]\nspline_b1_1d = mat_contents[\"spline_b1_1d\"]\nvox_range = mat_contents[\"vox_range\"][0]\n\n## Plot\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.subplots import make_subplots\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\n\n## Setup for plots\nfig = make_subplots(rows=2, cols=2, vertical_spacing = 0.06,\n                    subplot_titles=(\n    '<b>Unfiltered</b>',\n    '<b>Gaussian</b>',\n    '<b>Median</b>',\n    '<b>Spline</b>',))\n\n\n\nposition = np.arange(1,len(b1_func)+1)\n\nb1_data = [dict(\n            visible = False,\n            x = position,\n            y = b1_func,\n            name = \"True signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nb1_data[2]['visible'] = True\nb1_data[2]['showlegend'] = True\n\ndelta_signal = [dict(\n            visible = False,\n            x = position,\n            y = delta_b1,\n            name = \"Noisy signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\ndelta_signal[2]['visible'] = True\ndelta_signal[2]['showlegend'] = True\n\ngauss_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(gauss_b1_1d[ii]),\n            name = \"Gaussian filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\ngauss_b1[2]['visible'] = True\ngauss_b1[2]['showlegend'] = True\n\nmedian_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(median_b1_1d[ii]),\n            name = \"Median filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nmedian_b1[2]['visible'] = True\nmedian_b1[2]['showlegend'] = True\n\nspline_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(spline_b1_1d[ii]),\n            name = \"Spline interpolation\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nspline_b1[2]['visible'] = True\nspline_b1[2]['showlegend'] = True\n\n# Add traces\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=2)), row= 1, col=1)\n\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=2)), row= 1, col=1)\n\nb1_data[2]['showlegend'] = False\ndelta_signal[2]['showlegend'] = False\n\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(gauss_b1[ii], line=dict(color=\"red\", width=3)), row= 1, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 1, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=1)), row= 1, col=2)\n\nfor ii in range(len(vox_range)):        \n    fig.add_trace(go.Scatter(median_b1[ii], line=dict(color=\"blue\", width=3)), row= 2, col=1)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 2, col=1)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=1)), row= 2, col=1)\n    \nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(spline_b1[ii], line=dict(color=\"green\", width=3)), row= 2, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 2, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=1)), row= 2, col=2)\n    \n# Create and add slider\nsteps = []\n      \nfor i in range(len(vox_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(fig.data), \"showlegend\": [False] * len(fig.data)},],  # layout attribute\n        label = str(i+1)\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+1*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+2*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+3*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+4*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+5*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+6*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+7*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+8*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+9*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+10*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n\n    step[\"args\"][0][\"showlegend\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+1*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+2*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+5*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+8*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n\n    steps.append(step)\n\nsliders = [dict(\n    active=2,\n    currentvalue={\"prefix\": \"Filter strength: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig3.html', config = config)\n","type":"content","url":"/figure-4-3-6","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-7","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-03-Filtering\"\ndata_file = \"b1filt_fig4.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nb1_func = mat_contents[\"b1_func\"][0]\nstep_b1= mat_contents[\"step_b1\"][0]\ngauss_b1_1d = mat_contents[\"gauss_b1_1d\"]\nmedian_b1_1d = mat_contents[\"median_b1_1d\"]\nspline_b1_1d = mat_contents[\"spline_b1_1d\"]\nvox_range = mat_contents[\"vox_range\"][0]\n\n## Plot\n\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.subplots import make_subplots\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\n\n## Setup for plots\nfig = make_subplots(rows=2, cols=2, vertical_spacing = 0.06,\n                    subplot_titles=(\n    '<b>Unfiltered</b>',\n    '<b>Gaussian</b>',\n    '<b>Median</b>',\n    '<b>Spline</b>',))\n\n\n\nposition = np.arange(1,len(b1_func)+1)\n\nstep_signal = [dict(\n            visible = False,\n            x = position,\n            y = step_b1,\n            name = \"Step signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nstep_signal[2]['visible'] = True\nstep_signal[2]['showlegend'] = True\n\ngauss_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(gauss_b1_1d[ii]),\n            name = \"Gaussian filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\ngauss_b1[2]['visible'] = True\ngauss_b1[2]['showlegend'] = True\n\nmedian_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(median_b1_1d[ii]),\n            name = \"Median filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nmedian_b1[2]['visible'] = True\nmedian_b1[2]['showlegend'] = True\n\nspline_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(spline_b1_1d[ii]),\n            name = \"Spline interpolation\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nspline_b1[2]['visible'] = True\nspline_b1[2]['showlegend'] = True\n\n# Add traces\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(step_signal[ii], line=dict(color=\"black\", width=2)), row= 1, col=1)\n\nstep_signal[2]['showlegend'] = False\n\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(gauss_b1[ii], line=dict(color=\"red\", width=3)), row= 1, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(step_signal[ii], line=dict(color=\"black\", width=1)), row= 1, col=2)\n\nfor ii in range(len(vox_range)):        \n    fig.add_trace(go.Scatter(median_b1[ii], line=dict(color=\"blue\", width=3)), row= 2, col=1)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(step_signal[ii], line=dict(color=\"black\", width=1)), row= 2, col=1)\n    \nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(spline_b1[ii], line=dict(color=\"green\", width=3)), row= 2, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(step_signal[ii], line=dict(color=\"black\", width=1)), row= 2, col=2)\n    \n# Create and add slider\nsteps = []\n      \nfor i in range(len(vox_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(fig.data), \"showlegend\": [False] * len(fig.data)},],  # layout attribute\n        label = str(i+1)\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+1*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+2*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+3*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+4*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+5*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+6*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n\n    step[\"args\"][0][\"showlegend\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+1*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+3*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+5*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n\n    steps.append(step)\n\nsliders = [dict(\n    active=2,\n    currentvalue={\"prefix\": \"Filter strength: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig4.html', config = config)\n","type":"content","url":"/figure-4-3-7","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-8","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-03-Filtering\"\ndata_file = \"b1filt_fig5.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nb1_func = mat_contents[\"b1_func\"][0]\ndelta_b1= mat_contents[\"delta_b1\"][0]\ngauss_b1_1d = mat_contents[\"gauss_b1_1d\"]\nmedian_b1_1d = mat_contents[\"median_b1_1d\"]\nspline_b1_1d = mat_contents[\"spline_b1_1d\"]\nvox_range = mat_contents[\"vox_range\"][0]\n\n## Plot\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nfrom plotly.subplots import make_subplots\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\n\n## Setup for plots\nfig = make_subplots(rows=2, cols=2, vertical_spacing = 0.06,\n                    subplot_titles=(\n    '<b>Unfiltered</b>',\n    '<b>Gaussian</b>',\n    '<b>Median</b>',\n    '<b>Spline</b>',))\n\n\n\nposition = np.arange(1,len(b1_func)+1)\n\nb1_data = [dict(\n            visible = False,\n            x = position,\n            y = b1_func,\n            name = \"True signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nb1_data[2]['visible'] = True\nb1_data[2]['showlegend'] = True\n\ndelta_signal = [dict(\n            visible = False,\n            x = position,\n            y = delta_b1,\n            name = \"Noisy signal\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\ndelta_signal[2]['visible'] = True\ndelta_signal[2]['showlegend'] = True\n\ngauss_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(gauss_b1_1d[ii]),\n            name = \"Gaussian filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\ngauss_b1[2]['visible'] = True\ngauss_b1[2]['showlegend'] = True\n\nmedian_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(median_b1_1d[ii]),\n            name = \"Median filtered\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nmedian_b1[2]['visible'] = True\nmedian_b1[2]['showlegend'] = True\n\nspline_b1 = [dict(\n            visible = False,\n            x = position,\n            y = list(spline_b1_1d[ii]),\n            name = \"Spline interpolation\",\n            hoverinfo = \"y\",\n            showlegend=False) for ii in range(len(vox_range))]\n\nspline_b1[2]['visible'] = True\nspline_b1[2]['showlegend'] = True\n\n# Add traces\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=2)), row= 1, col=1)\n\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=2)), row= 1, col=1)\n\nb1_data[2]['showlegend'] = False\ndelta_signal[2]['showlegend'] = False\n\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(gauss_b1[ii], line=dict(color=\"red\", width=3)), row= 1, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 1, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=1)), row= 1, col=2)\n\nfor ii in range(len(vox_range)):        \n    fig.add_trace(go.Scatter(median_b1[ii], line=dict(color=\"blue\", width=3)), row= 2, col=1)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 2, col=1)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=1)), row= 2, col=1)\n    \nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(spline_b1[ii], line=dict(color=\"green\", width=3)), row= 2, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(b1_data[ii], line=dict(color=\"black\", width=1)), row= 2, col=2)\nfor ii in range(len(vox_range)):\n    fig.add_trace(go.Scatter(delta_signal[ii], line=dict(color=\"grey\", width=1)), row= 2, col=2)\n    \n# Create and add slider\nsteps = []\n      \nfor i in range(len(vox_range)):\n    step = dict(\n        method=\"update\",\n        args=[{\"visible\": [False] * len(fig.data), \"showlegend\": [False] * len(fig.data)},],  # layout attribute\n        label = str(i+1)\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+1*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+2*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+3*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+4*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+5*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+6*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+7*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+8*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+9*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"visible\"][i+10*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n\n    step[\"args\"][0][\"showlegend\"][i] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+1*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+2*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+5*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n    step[\"args\"][0][\"showlegend\"][i+8*len(vox_range)] = True  # Toggle i'th trace to \"visible\"\n\n    steps.append(step)\n\nsliders = [dict(\n    active=2,\n    currentvalue={\"prefix\": \"Filter strength: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='Signal',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ),\n    sliders=sliders\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig5.html', config = config)\n","type":"content","url":"/figure-4-3-8","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-4-3-9","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"04-B1-03-Filtering\"\ndata_file = \"b1filt_fig6.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nda_data = mat_contents[\"da_data\"]\nafi_data = mat_contents[\"afi_data\"]\nbs_data = mat_contents[\"bs_data\"]\n\nmask = mat_contents[\"mask\"]\n\nmedian_smoothing_factors = mat_contents[\"median_smoothing_factors\"][0]\n\ngaussian_smoothing_factors = mat_contents[\"gaussian_smoothing_factors\"][0]\n\nspline_smoothing_factors = mat_contents[\"spline_smoothing_factors\"][0]\n\nfrom os import path\nfrom pathlib import Path\nimport os\n\n\n# Imports\n\nfrom pathlib import Path\nimport pandas as pd\nimport json\nimport nibabel as nib\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport glob\n\nxAxis = list(range(1,np.shape(mask)[1]))\nyAxis = list(range(1,np.shape(mask)[0]))\n\n# DA acqs\nda_low = np.concatenate(\n        (\n        np.rot90(da_data['Raw'][0][0], -1), \n        np.rot90(da_data['median_low'][0][0], -1), \n        np.rot90(da_data['gaussian_low'][0][0], -1), \n        np.rot90(da_data['spline_low'][0][0], -1)\n        ), \n        axis=1\n)\nda_medium = np.concatenate(\n        (\n        np.rot90(da_data['Raw'][0][0], -1), \n        np.rot90(da_data['median_medium'][0][0], -1), \n        np.rot90(da_data['gaussian_medium'][0][0], -1), \n        np.rot90(da_data['spline_medium'][0][0], -1)\n        ), \n        axis=1\n)\nda_high = np.concatenate(\n        (\n        np.rot90(da_data['Raw'][0][0], -1), \n        np.rot90(da_data['median_high'][0][0], -1), \n        np.rot90(da_data['gaussian_high'][0][0], -1), \n        np.rot90(da_data['spline_high'][0][0], -1)\n        ), \n        axis=1\n)\n\n# AFI acqs\nafi_low = np.concatenate(\n        (\n        np.rot90(afi_data['Raw'][0][0], -1), \n        np.rot90(afi_data['median_low'][0][0], -1), \n        np.rot90(afi_data['gaussian_low'][0][0], -1), \n        np.rot90(afi_data['spline_low'][0][0], -1)\n        ), \n        axis=1\n)\nafi_medium = np.concatenate(\n        (\n        np.rot90(afi_data['Raw'][0][0], -1), \n        np.rot90(afi_data['median_medium'][0][0], -1), \n        np.rot90(afi_data['gaussian_medium'][0][0], -1), \n        np.rot90(afi_data['spline_medium'][0][0], -1)\n        ), \n        axis=1\n)\nafi_high = np.concatenate(\n        (\n        np.rot90(afi_data['Raw'][0][0], -1), \n        np.rot90(afi_data['median_high'][0][0], -1), \n        np.rot90(afi_data['gaussian_high'][0][0], -1), \n        np.rot90(afi_data['spline_high'][0][0], -1)\n        ), \n        axis=1\n)\n\n# BS acqs\nbs_low = np.concatenate(\n        (\n        np.rot90(bs_data['Raw'][0][0], -1), \n        np.rot90(bs_data['median_low'][0][0], -1), \n        np.rot90(bs_data['gaussian_low'][0][0], -1), \n        np.rot90(bs_data['spline_low'][0][0], -1)\n        ), \n        axis=1\n)\nbs_medium = np.concatenate(\n        (\n        np.rot90(bs_data['Raw'][0][0], -1), \n        np.rot90(bs_data['median_medium'][0][0], -1), \n        np.rot90(bs_data['gaussian_medium'][0][0], -1), \n        np.rot90(bs_data['spline_medium'][0][0], -1)\n        ), \n        axis=1\n)\nbs_high = np.concatenate(\n        (\n        np.rot90(bs_data['Raw'][0][0], -1), \n        np.rot90(bs_data['median_high'][0][0], -1), \n        np.rot90(bs_data['gaussian_high'][0][0], -1), \n        np.rot90(bs_data['spline_high'][0][0], -1)\n        ), \n        axis=1\n)\n\n# Concate methods\n\ndata_low = np.concatenate(\n        (da_low, afi_low, bs_low), \n        axis=0\n)\n\ndata_medium = np.concatenate(\n        (da_medium, afi_medium, bs_medium), \n        axis=0\n)\n\ndata_high = np.concatenate(\n        (da_high, afi_high, bs_high), \n        axis=0\n)\n\n# PYTHON CODE\n# Module imports\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import init_notebook_mode, iplot, plot\nconfig={'showLink': False, 'displayModeBar': False, 'responsive': True}\n\ninit_notebook_mode(connected=True)\n\nimport os\nimport markdown\nimport random\nfrom scipy.integrate import quad\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# DA acqs\nda_low = np.concatenate(\n        (\n        np.rot90(da_data['Raw'][0][0], -1), \n        np.rot90(da_data['median_low'][0][0], -1), \n        np.rot90(da_data['gaussian_low'][0][0], -1), \n        np.rot90(da_data['spline_low'][0][0], -1)\n        ), \n        axis=1\n)\nda_medium = np.concatenate(\n        (\n        np.rot90(da_data['Raw'][0][0], -1), \n        np.rot90(da_data['median_medium'][0][0], -1), \n        np.rot90(da_data['gaussian_medium'][0][0], -1), \n        np.rot90(da_data['spline_medium'][0][0], -1)\n        ), \n        axis=1\n)\nda_high = np.concatenate(\n        (\n        np.rot90(da_data['Raw'][0][0], -1), \n        np.rot90(da_data['median_high'][0][0], -1), \n        np.rot90(da_data['gaussian_high'][0][0], -1), \n        np.rot90(da_data['spline_high'][0][0], -1)\n        ), \n        axis=1\n)\n\n# AFI acqs\nafi_low = np.concatenate(\n        (\n        np.rot90(afi_data['Raw'][0][0], -1), \n        np.rot90(afi_data['median_low'][0][0], -1), \n        np.rot90(afi_data['gaussian_low'][0][0], -1), \n        np.rot90(afi_data['spline_low'][0][0], -1)\n        ), \n        axis=1\n)\nafi_medium = np.concatenate(\n        (\n        np.rot90(afi_data['Raw'][0][0], -1), \n        np.rot90(afi_data['median_medium'][0][0], -1), \n        np.rot90(afi_data['gaussian_medium'][0][0], -1), \n        np.rot90(afi_data['spline_medium'][0][0], -1)\n        ), \n        axis=1\n)\nafi_high = np.concatenate(\n        (\n        np.rot90(afi_data['Raw'][0][0], -1), \n        np.rot90(afi_data['median_high'][0][0], -1), \n        np.rot90(afi_data['gaussian_high'][0][0], -1), \n        np.rot90(afi_data['spline_high'][0][0], -1)\n        ), \n        axis=1\n)\n\n# BS acqs\nbs_low = np.concatenate(\n        (\n        np.rot90(bs_data['Raw'][0][0], -1), \n        np.rot90(bs_data['median_low'][0][0], -1), \n        np.rot90(bs_data['gaussian_low'][0][0], -1), \n        np.rot90(bs_data['spline_low'][0][0], -1)\n        ), \n        axis=1\n)\nbs_medium = np.concatenate(\n        (\n        np.rot90(bs_data['Raw'][0][0], -1), \n        np.rot90(bs_data['median_medium'][0][0], -1), \n        np.rot90(bs_data['gaussian_medium'][0][0], -1), \n        np.rot90(bs_data['spline_medium'][0][0], -1)\n        ), \n        axis=1\n)\nbs_high = np.concatenate(\n        (\n        np.rot90(bs_data['Raw'][0][0], -1), \n        np.rot90(bs_data['median_high'][0][0], -1), \n        np.rot90(bs_data['gaussian_high'][0][0], -1), \n        np.rot90(bs_data['spline_high'][0][0], -1)\n        ), \n        axis=1\n)\n\n# Concate methods\n\ndata_low = np.concatenate(\n        (da_low, afi_low, bs_low), \n        axis=0\n)\n\ndata_medium = np.concatenate(\n        (da_medium, afi_medium, bs_medium), \n        axis=0\n)\n\ndata_high = np.concatenate(\n        (da_high, afi_high, bs_high), \n        axis=0\n)\n\n\n# Mask\n\nmasks_concat = np.concatenate((np.rot90(mask,-1), np.rot90(mask,-1), np.rot90(mask,-1), np.rot90(mask,-1)), axis=1)\nmask_grid = np.concatenate((masks_concat, masks_concat, masks_concat), axis=0)\n\nxAxis = np.linspace(0,88*4-1, num=88*4)\nyAxis = np.linspace(0,128*3-1, num=128*3)\n\n\ntrace_low = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(mask_grid*data_low),\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   colorbar={\"title\": 'B<sub>1</sub>',\n                             'titlefont': dict(\n                                   family='Times New Roman',\n                                   size=26,\n                                   )\n                            },\n                   visible=False)\n                   \ntrace_medium = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(mask_grid*data_medium),\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   colorbar={\"title\": 'B<sub>1</sub>',\n                             'titlefont': dict(\n                                   family='Times New Roman',\n                                   size=26,\n                                   )\n                            },\n                   visible=True)\n                   \ntrace_high = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.flipud(mask_grid*data_high),\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='RdBu',\n                   colorbar={\"title\": 'B<sub>1</sub>',\n                             'titlefont': dict(\n                                   family='Times New Roman',\n                                   size=26,\n                                   )\n                            },\n                   visible=False)\n\ndata=[trace_low, trace_medium, trace_high]\n\nupdatemenus = list([\n    dict(active=1,\n         x = 0.4,\n         xanchor = 'left',\n         y = -0.08,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = 'Weak filter',\n                 method = 'update',\n                 args = [{'visible': [True, False, False]},\n                         ]),\n            dict(label = 'Medium filter',\n                 method = 'update',\n                 args = [\n                            {\n                            'visible': [False, True, False]},\n                           ]),\n            dict(label = 'Strong filter',\n                 method = 'update',\n                 args = [{'visible': [False, False, True]},\n                           ]),\n    ])\n    )\n])\n\nlayout = dict(\n    width=750,\n    height=750,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.03,\n            y=1.05,\n            showarrow=False,\n            text='Unfiltered',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.305,\n            y=1.05,\n            showarrow=False,\n            text='Median',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.625,\n            y=1.05,\n            showarrow=False,\n            text='Gaussian',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.94,\n            y=1.05,\n            showarrow=False,\n            text='Spline',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.06,\n            y=0.95,\n            showarrow=False,\n            text='Double Angle',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.06,\n            y=0.5,\n            showarrow=False,\n            text='AFI',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.06,\n            y=0.05,\n            showarrow=False,\n            text='Bloch-Siegert',\n            font=dict(\n                family='Times New Roman',\n                size=30\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis = dict(range = [0,88*4-1], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    yaxis = dict(range = [0,128*3-1], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus\n)\n\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-heatmap', config = config)\n","type":"content","url":"/figure-4-3-9","position":1},{"hierarchy":{"lvl1":"B1 Mapping"},"type":"lvl1","url":"/b1-mapping","position":0},{"hierarchy":{"lvl1":"B1 Mapping"},"content":"","type":"content","url":"/b1-mapping","position":1},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Double Angle techniques"},"type":"lvl2","url":"/b1-mapping#double-angle-techniques","position":2},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Double Angle techniques"},"content":"","type":"content","url":"/b1-mapping#double-angle-techniques","position":3},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Transmit and Receive RF field amplitudes","lvl2":"Double Angle techniques"},"type":"lvl3","url":"/b1-mapping#transmit-and-receive-rf-field-amplitudes","position":4},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Transmit and Receive RF field amplitudes","lvl2":"Double Angle techniques"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nIn an MRI experiment, magnetic field amplitude of the radiofrequency field (B1) is an an important physical parameter that is a product of the interaction between RF coil design and the subject‚Äôs position (volume and relative position to the coil) and physical properties (electromagnetic permittivity Œµ and permeability Œº). In any MRI experiments, two B1 fields appear: the transmit RF field amplitude B1+ and the receive RF field amplitude B1-. The latter, B1-, is often referred to in terms of the receive RF coil sensitivities and this is due to the principle of reciprocity \n\nHoult & Richards, 1976\n\nHoult, 2000 property of RF antennas. In terms of an MRI image, B1- is simply a multiplication factor that varies spatially but doesn‚Äôt change between pulse sequences if the subject remains motionless, and techniques to ‚Äúflatten‚Äù images by estimating this field numerically have been developed \n\nSled et al., 1998. Additionally, many quantitative MRI techniques calculate the ratio of images, which eliminates this B1- component from the resulting image.\n\nB1+, however, impacts the resulting MRI images in a much more complex way and is not a simple multiplication factor. B1+ directly perturbs the system of spins by introducing energy in the system, which practically we quantify as the flip angle of an RF pulse. Two different B1+ values will not have the same impact on voxel for different pulse sequences, as spin dynamics and steady-state conditions will vary. For example, let‚Äôs say you acquire a saturation recovery image and also a short TR steady-state gradient echo. For an actual flip angle  = \\alpha \\cdot B_{1}, the magnetization after TE will be M_{z}\\text{sin}\\left( \\alpha \\cdot B_{1} \\right)\\text{exp}\\left(-\\text{TE}/T_{2}   \\right) and M_z prior to the RF pulse is given by \n\nEq. 2.5. Thus, not only does B1+ not appear as a simple multiplication factor, a change of B1 will not impact this voxel for both sequences by the same ratio. Thus, knowledge of B1+ through B1 mapping can help us retroactively understand the dynamics of the spins accurately, and can play the role of a calibration factor for many quantitative MRI techniques (e.g. VFA, T2/T2*, qMT, etc). In addition, B1 mapping can also map the electromagnetic properties, but this won‚Äôt be discussed in this chapter.\n\nIn this chapter, we‚Äôll be discussing a simple but widely used class of methods for B1 mapping, the double angle method. For the sake of simplicity, and for consistency with the quantitative MRI literature, we‚Äôll define B1 = B1+ and will explicitly state B1- when referring to the receive field.","type":"content","url":"/b1-mapping#transmit-and-receive-rf-field-amplitudes","position":5},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Double Angle method(s)","lvl2":"Double Angle techniques"},"type":"lvl3","url":"/b1-mapping#double-angle-method-s","position":6},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Double Angle method(s)","lvl2":"Double Angle techniques"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nThe Double Angle method (DA or DAM) is a class of B1 mapping techniques where two RF pulses at flip angles Œ± and 2Œ± are applied to a pulse sequence, and the ratio of the images are compared to expected output to produce a B1 map. Several main pulse sequences (\n\nFigure 4.1) have been called the double angle method in the literature, and both have their own equations describing the relationship between the expected images and B1. In this chapter, we‚Äôll mostly explore there the Œ±-180 method (\n\nFigure 4.1]), and then briefly explain the other method and its similarities/differences.\n\n\n\nFigure¬†4.1:Pulse sequences for double angle methods. A) Double angle method using a gradiend echo. B) Double angle method using a 180 degree refocusing pulse. C) Double angle method using a 2\\alpha refocusing pulse, acquired with two values \\alpha_{1} and \\alpha_{2} such that \\alpha_{2}=2\\alpha_{1}.","type":"content","url":"/b1-mapping#double-angle-method-s","position":7},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Gradient echo and 180 degree spin echo methods","lvl2":"Double Angle techniques"},"type":"lvl3","url":"/b1-mapping#gradient-echo-and-180-degree-spin-echo-methods","position":8},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Gradient echo and 180 degree spin echo methods","lvl2":"Double Angle techniques"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nThis pulse sequence uses a 180 degree spin-echo refocusing pulse and acquires two images using an excitation pulse Œ± and 2\\alpha. It assumes that there is full signal recovery (long TR), and because it refocuses T2*, it eliminates signal variability caused by B0 in the resulting B1 map \n\nInsko & Bolinger, 1993. Alternatively, a gradient echo could be used?\n\nAssuming a refocusing pulse is used (i.e. isn‚Äôt dependent on B1), we can develop the equation for a gradient echo and spin echo case.M_{\\alpha}=M_{0}\\text{sin}\\left( \\alpha \\right)\\text{e}^{\\left( -\\frac{TE}{T_{2}} \\right)}M_{2\\alpha}=M_{0}\\text{sin}\\left( 2\\alpha \\right)\\text{e}^{\\left( -\\frac{TE}{T_{2}} \\right)}\n\nThus\\frac{M_{\\alpha}}{\\text{sin}\\left(\\alpha \\right)}=\\frac{M_{2\\alpha}}{\\text{sin}\\left(2\\alpha \\right)}\n\nand\\frac{M_{2\\alpha}}{M_{\\alpha}}=\\frac{\\text{sin}\\left(2\\alpha \\right)}{\\text{sin}\\left(\\alpha \\right)}\n\nUsing a well known trigonometry identity (see \n\nAppendix A for derivation),\\text{sin}\\left( 2\\alpha \\right)=2\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)\n\nWe can simplify \n\nEq. 4.5,\\frac{M_{2\\alpha}}{M_{\\alpha}}=\\frac{2\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)}{\\text{sin}\\left(\\alpha \\right)}\\frac{M_{2\\alpha}}{M_{\\alpha}}=2\\text{cos}\\left( \\alpha \\right)\n\nAnd the true flip angle can be calculated from the ratio of these two magnetizations / signals / images:\\alpha=\\text{arcos}\\left( \\frac{M_{2\\alpha}}{2M_{\\alpha}} \\right)\n\nKnowing that \\alpha = B_{1} alpha_nominal, B1 is thus:B_{1}=\\frac{\\text{arcos}\\left( \\frac{M_{2\\alpha}}{2M_{\\alpha}} \\right)}{\\alpha_{nominal}}\n\n\n\nFigure¬†4.2:B1 computed from analytical GRE equations for DA sequence\n\nThis equation is also used for Œ±-180 spin echo pulses, however it assumes no dependency on of the refocusing pulse on B1. \n\nFigure 4.3 explores this using Bloch simulations\n\n\n\nFigure¬†4.3:B1 computed from bloch simulations for ideal spin echo and refocusing pulse where FA = 180*B1\n\n\n\nFigure¬†4.4:B1 computed from bloch simulations for spin echo with refocusing pulse where FA = 180*B1, and composite pulse 90x-180y-90x where each 90 and 180 are also multiplied by B1.","type":"content","url":"/b1-mapping#gradient-echo-and-180-degree-spin-echo-methods","position":9},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Actual Flip Angle Imaging"},"type":"lvl2","url":"/b1-mapping#actual-flip-angle-imaging","position":10},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Actual Flip Angle Imaging"},"content":"Transmit radiofrequency field maps (B1+, or B1 for short) are used in diverse applications in MRI including: the study of electrical properties in tissues in vivo \n\nSled & Pike, 1998\n\nKatscher et al., 2009, specific absorption rate (SAR) calculations \n\nIbrahim et al., 2001, the calibration of quantitative T1 \n\nDeoni, 2007\n\nBoudreau et al., 2017 and T2 \n\nSled & Pike, 2000 maps, better parameter estimation from magnetization transfer measurements \n\nRopele et al., 2005\n\nBoudreau et al., 2018, B1 shimming to improve image quality at whole-body ultra high fields \n\nBergen et al., 2007, or quality control of RF coils \n\nYarnykh, 2007. Several B1 mapping techniques have been developed, and they can be broadly divided as magnitude-based and phase-based methods. The double angle method (DAM) is a saturation-recovery magnitude-based method that takes the ratio of the signal intensity of two magnitude images measured with different excitation flip angles \n\nInsko & Bolinger, 1993\n\nStollberger & Wach, 1996. The Bloch-Siegert shift technique is a rapid phase-based method that encodes the B1 information into phase signal \n\nSacolick et al., 2010. The actual flip-angle imaging (AFI) is a magnitude-based B1 mapping method that consists of a 3D acquisition that benefits from good anatomical coverage. In addition, this technique allows the acquisitions of whole-body (~7 min) and brain (~3 min) B1 maps leading to a feasible implementation in clinics \n\nYarnykh, 2007. On the other hand, the AFI pulse sequence has certain constraints that need to be considered for this B1 mapping method to be widely deployed. Some of the limitations include the use of spoiler gradients that can give rise to prohibitive SAR values \n\nSacolick et al., 2010, and the pulse sequence modifications on the MRI machine to implement the AFI method.\n\nIn this section, we will focus on presenting details about the AFI B1 mapping method. We will cover signal modeling, data fitting, the benefits and the pitfalls of the technique. The figures are generated using the qMRLab module for this method.","type":"content","url":"/b1-mapping#actual-flip-angle-imaging","position":11},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Signal Modelling","lvl2":"Actual Flip Angle Imaging"},"type":"lvl3","url":"/b1-mapping#signal-modelling","position":12},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Signal Modelling","lvl2":"Actual Flip Angle Imaging"},"content":"The pulse sequence of the AFI method (\n\nFigure 4.5) is composed of two identical RF pulses and two different delays (TR1 < TR2). After each RF pulse, the signal intensity is acquired followed by a spoiler to destroy the residual transverse magnetization next to the following RF pulse. This method implements a pulsed steady-state signal with a gradient-echo acquisition, thus preventing the use of long repetition times \n\nYarnykh, 2007. It has been demonstrated that if the delays TR1 and TR2 are sufficiently short (e.g. TR1/TR2 = 20 ms/100 ms), and the transverse magnetization is completely spoiled, the ratio of signal intensities (r = S2/S1) depends on the flip angle of applied pulses and is highly insensitive to T1 \n\nYarnykh, 2007.\n\n\n\nFigure¬†4.5:Simplified pulse sequence diagram of an actual flip-angle imaging (AFI) pulse sequence with a gradient echo readout. TR1: repetition time 1, TR2: repetition time 2, Œ∏: excitation flip angle for the measurement, IMG: image acquisition (k-space readout), SPOIL: spoiler gradient.\n\nThe magnetization of an AFI experiment can be modeled under steady-state conditions by the implementation of a fast repetition of the sequence (TR1 < TR2 < T1). The solution of the \n\nBloch equations for the AFI method is given by Equations 1 and 2 that represent the longitudinal magnetization before the application of the RF pulses:M_{z1}=M_{0}\\frac{1-e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}+\\left( 1- e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}\\right)e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}\\text{cos}\\left( \\theta \\right)}{1-e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}\\text{cos}^{2}\\left( \\theta \\right)}\\text{sin}\\left( \\theta \\right)M_{z2}=M_{0}\\frac{1-e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}+\\left( 1- e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}\\right)e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}\\text{cos}\\left( \\theta \\right)}{1-e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}\\text{cos}^{2}\\left( \\theta \\right)}\\text{sin}\\left( \\theta \\right)\n\nMz1,2 is the longitudinal magnetization of both pulses, M0 is the magnetization at thermal equilibrium, TR1 is the delay time after the first pulse, TR2 is the delay time after the second identical pulse (\n\nFigure 4.6), and Œ∏ is the excitation flip angle. The steady-state longitudinal magnetization Mz curves for different T1 values for a range of \\theta_{n} and TR values are shown in \n\nFigure 4.6.\n\n\n\nFigure¬†4.6:Longitudinal magnetization before the first radiofrequency pulse (\n\nEq. 4.10, solid lines) and before the second identical pulse (\n\nEq. 4.11, dashed lines) for three different T1 values.\n\nThe analytical solution of the Bloch equations in a steady-state experiment (\n\nEq. 4.10 and \n\nEq. 4.11) makes several assumptions leading to practical challenges. First, it is assumed that the longitudinal magnetization has reached a steady state after a sufficiently large number of repetition times (TR), and that the transverse magnetization is perfectly spoiled prior to each pulse. To explore these properties, a numerical approach known as Bloch simulations is used to estimate the signal from an MRI experiment given a set of sequence parameters. Here, the Bloch simulations allow us to estimate the magnetization using a different number of sequence repetitions, and look at a special case when the steady-state is not achieved (due to a small number of sequence repetitions). As can be seen in \n\nFigure 4.7, the number of repetitions required to reach a steady-state depends on T1 and the flip angle.\n\n\n\nFigure¬†4.7:Signal 1 (blue) and Signal 2 (red) curves simulated using Bloch simulations (solid lines) for a number of repetitions ranging from 1 to 150, plotted against the ideal case (\n\nEq. 4.10 and \n\nEq. 4.11 ‚Äì dashed lines). Simulation details: TR1 = 20 ms, TR2 = 100 ms, T1 = 900 ms, 100 spins. Ideal spoiling was used for this set of Bloch simulations (transverse magnetization was set to 0 at the end of each TR1,2).\n\nIn practice, gradient and RF spoiling are important parameters to consider in an AFI experiment. A combination of both \n\nZur et al., 1991\n\nBernstein et al., 2004 is typically recommended, and \n\nFigure 4.8 shows how this better approximates the ideal spoiling case.\n\n\n\nFigure¬†4.8:Signal 1 curves estimated using Bloch simulations for three categories of signal spoiling: (1) ideal spoiling (blue), gradient & RF Spoiling (red), and no spoiling (orange). Simulation details: TR1 = 20 ms, TR2 = 100 ms, T1 = 900 ms, T2 = 100 ms, TE = 5 ms, 100 spins. For the ideal spoiling case, the transverse magnetization is set to zero at the end of each TR. For the gradient & RF spoiling case, each spin is rotated by different increments of phase (2ùúã / # of spins) to simulate complete dephasing from gradient spoiling, and the RF phase of the excitation pulse is \\Phi_{n}=\\Phi_{n-1}+n\\Phi_{0}= 1/2 \\Phi_{0}\\left( n^{2}+n+2 \\right) \n\nBernstein et al., 2004 with \\Phi_{0}=39^{\\circ} \n\nZur et al., 1991 after each TR.","type":"content","url":"/b1-mapping#signal-modelling","position":13},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Data Fitting","lvl2":"Actual Flip Angle Imaging"},"type":"lvl3","url":"/b1-mapping#data-fitting","position":14},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Data Fitting","lvl2":"Actual Flip Angle Imaging"},"content":"The ratio of \n\nEq. 4.10 and \n\nEq. 4.11, gives rise to \n\nEq. 4.12 that depends on the parameters T1, TR1, TR2 and the excitation flip angle (Œ∏).r=\\frac{S_{2}}{S_{1}}=\\frac{1-e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}+\\left( 1-e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}\\right)e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}\\text{cos}\\left( \\theta \\right) }{1-e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}+\\left( 1-e^{\\frac{-\\text{TR}_{1}}{_{T_{1}}}}\\right)e^{\\frac{-\\text{TR}_{2}}{_{T_{1}}}}\\text{cos}\\left( \\theta \\right)}\n\nEq. 4.12 can be simplified if the Taylor series expansion of the exponential function is used, followed by a first-order approximation to its terms. For this expansion, short TR1 and TR2 (TR1 < T1 and TR2 < T1) are assumed to approximate the signal intensities ratio (\n\nEq. 4.13) where n = TR2/TR1.r \\approx \\frac{1+n\\text{cos}\\left( \\theta \\right)}{n+\\text{cos}\\left( \\theta \\right)}\n\nFinally, a measure of the actual flip-angle (Œ∏) can be achieved by solving \n\nEq. 4.13 to obtain \n\nEq. 4.14, which only depends on the signal intensities ratio (r = S2/S1) and the parameters TR1 and TR2.\\theta \\approx\\text{arcos}\\left( \\frac{rn-1}{n-r} \\right)\n\nThe actual flip-angle is estimated using an approximation (\n\nEq. 4.13) of a complete analytical solution (\n\nEq. 4.12), and the nature of this approximation makes it worthwhile to assess the accuracy of the signal intensities ratio between both equations. Next, a set of simulations are displayed to analyze how the choice of r is affected by T1, TR1 and TR2. First, the effect of the relaxation time T1 is simulated in \n\nFigure 4.9 for both the approximation and the complete analytical solution.\n\n\n\nFigure¬†4.9:Effect of the relaxation time T1 on the ratio r. Signal intensities ratio is plotted as a function of the flip angle for the complete analytical solution (\n\nEq. 4.12 - blue) and the first-order approximation (\n\nEq. 4.13 - orange). AFI simulation details: TR1 = 20 ms, TR2 = 100 ms and variable T1.\n\nThe signal ratio r is highly insensitive to the relaxation time T1, except for the low T1 values and large flip angles (>70¬∞). This shows that the Taylor expansion is a good approximation to the signal ratio r because it is possible to get rid of the inverse quadratic T1 dependance by taking the first-order terms of the expansion.\n\nThe effect of the TR1 parameter on the signal ratio is shown in \n\nFigure 4.10. To assess the influence of the repetition time, we fix n=5 and vary the parameter TR1 in accordance to the relation n = TR2/TR1. As TR1 increases (> 50 ms), the approximated ratio r slightly deviates from the analytical approach. Although the deviation is slight only at high flip angles, a good signal ratio approximation can be achieved for a wide range of flip angles and repetition times.\n\n\n\nFigure¬†4.10:Effect of the repetition time TR1 on the ratio r. Signal intensities ratio is plotted as a function of the flip angle for the complete analytical solution (\n\nEq. 4.12 - blue) and the first-order approximation (\n\nEq. 4.13 - orange). AFI simulation details: Variable TR1 ranging from 10 to 60 ms, fixed ratio n = 5 and T1 = 900 ms.\n\nFinally, the effect of the parameter n on the signal ratio r (\n\nFigure 4.11) does not seem to significantly affect the signal ratio between the approximated equation and the analytical approach. However, the parameter n has a major impact on the sensitivity of the AFI method to variations in the flip angle. \n\nFigure 4.11 shows that the increase of the parameter n (= TR2/TR1) allows for improvement of the dynamic range of flip angles measurements. These simulations have shown that an optimal implementation of the AFI method requires a careful selection of sequence parameters.\n\n\n\nFigure¬†4.11:Effect of n (TR2 to TR1 ratio) on the ratio r. The signal intensities ratio is plotted as a function of the flip angle for the complete analytical solution (\n\nEq. 4.12 - blue) and the first-order approximation (\n\nEq. 4.13 - orange). AFI simulation details: Variable n ranging from 2 to 6, fixed TR1 = 20 ms and T1 = 900 ms.\n\nFigure 4.12 displays an example AFI dataset and its corresponding field B1 map in a healthy human brain. Although not clearly visible, both AFI images present a small Gibbs ringing artifact that is propagated and amplified due to the AFI calculation consisting of the division of both images \n\nBoudreau et al., 2017. The ringing artifact is clearly seen in the unfiltered/raw B1 field map shown in \n\nFigure 4.12 (right).\n\n\n\nFigure¬†4.12:Example actual flip-angle imaging dataset (left) and a resulting raw B1 map of a healthy adult brain (right). The relevant VFA protocol parameters used were: TR1 = 20 ms, TR2 = 100 ms and \\theta_{nominal} = 60¬∞. The B1 map (right) was fitted using the approximate r ratio (\n\nEq. 4.14).\n\nThe ringing artifact shown in \n\nFigure 4.12 can be attenuated by implementing a smoothing process. \n\nFigure 4.13 shows the raw (left) and the filtered (right) B1 map where a median filter was used to smooth the field map.\n\n\n\nFigure¬†4.13:Raw (left) and filtered (right) B1 map. A median filter of size 7x7x7 pixels was used to attenuate the Gibbs ringing artifact.","type":"content","url":"/b1-mapping#data-fitting","position":15},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Actual Flip Angle Imaging"},"type":"lvl3","url":"/b1-mapping#benefits-and-pitfalls","position":16},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Actual Flip Angle Imaging"},"content":"B1 mapping is of interest for diverse MRI applications, and several mapping techniques have been developed. The DAM method consists of acquiring two scans at two different flip angles. To avoid the dependence of the signal on T1, long repetition times are required to allow the recovery of the longitudinal magnetization between pulses \n\nYarnykh, 2007\n\nInsko & Bolinger, 1993. The AFI method overcomes this practical limitation by repeating the pulse sequence at a fast rate to achieve a pulsed state of magnetization and shorter time delays between pulses. In addition, due to scan-time constraints, B1 mapping methods are often implemented in 2D \n\nChavez & Stanisz, 2012. However, the accuracy of the measurements of 2D B1 mapping techniques is compromised by the slice profile effects due to the problem of nonuniform excitation across slices \n\nYarnykh, 2007\n\nChavez & Stanisz, 2012. The AFI method on the other hand, adresses this issue using a fast 3D implementation leading to scans with an excellent anatomical coverage in clinically feasible times, with an increase in signal-to-noise ratio compared to 2D multislice acquisitions.\n\nThe performance of the AFI method is based on the following assumptions. First, the two images acquired at different times should be registered to avoid motion effects. It is also assumed that the signal is insensitive to the main magnetic field non-uniformities and chemical shift effects that are canceled out when taking the signal ratio r \n\nYarnykh, 2007. Despite some clear advantages over other B1 mapping techniques, the application of spoiler gradients to mitigate the T1 dependence can be a limitation due to significant levels of RF power depositions \n\nSacolick et al., 2010. Furthermore, it is necessary to adapt the AFI pulse sequence to different scanner manufacturers, and programming experience is required to bring this technique into the clinic.","type":"content","url":"/b1-mapping#benefits-and-pitfalls","position":17},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Filtering"},"type":"lvl2","url":"/b1-mapping#filtering","position":18},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Filtering"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nThe behaviour of electromagnetic fields produced by RF antennas are bound by the laws of physics. The \n\nMaxwell equations impose many limitations on how these fields can not only vary spatially and temporally, but how the electric and magnetic fields are linked. While propagating magnetic fields interface of boundary between materials can be discontinuous (a result of Maxwell‚Äôs equations), it‚Äôs been shown in the context of MRI and tissues that the magnetic field amplitudes are expected to be smoothly varying when using clinical MRIs \n\nSled & Pike, 1998\n\nSled et al., 1998. At ultra-high fields, standing wave artifacts can lead to more B1 variations and even signal nulls, however the field amplitude nonetheless varies continuously \n\nUƒüurbil, 2018\n\nVaughan et al., 2001\n\nYang et al., 2002. Thus, for both B1+ and B1-, their amplitude is expected to be a smoothly varying multiplicative field, and at clinical field strength it‚Äôs also expected to be a slowly or low frequency varying field.\n\nIn practice, measured B1+ maps are rarely perfectly smooth over the anatomy-of-interest being imaged. \n\nFigure 4.14 shows a comparison of measured B1 maps in the brain produced by three methods: double angle, actual flip angle imaging (AFI), and Bloch-Siegert shift.\n\n\n\nFigure¬†4.14:Example B1 maps (right column) along with their raw acquired data (left and middle columns) for three different B1 mapping techniques: double angle (top row), actual flip angle imaging (AFI; middle row), and Bloch-Siegert shift (bottom row).\n\nThe overall ‚Äúshape‚Äù of the B1 map is the same for all three maps, and this nonuniformity pattern is expected due to the elliptical shape of the brain and its electromagnetic properties \n\nSled & Pike, 1998. We see in the B1 maps of \n\nFigure 4.14 that there is some noise, some distinguishable anatomical structures (caused by T1 sensitivity and/or k-space propagation susceptibility effects), and in one case (AFI) an artifact caused by Gibbs ringing in the acquired images. All of these variations are not present in the actual B1+ field that the spins experience during a pulse sequence, and so using this ‚Äúraw‚Äù B1 map to calibration flip angles or RF power for other quantitative MRI techniques (eg. variable flip angle T1 mapping, quantitative magnetization transfer) risks introducing errors during the correction.\n\nAlthough not a perfect solution, researchers often smoothen their B1 maps \n\nYarnykh, 2007\n\nLutti et al., 2010\n\nBoudreau et al., 2017 in an effort to mitigate the error propagation from the B1+ map noise and artifacts prior to use for other techniques. This chapter will discuss some common ways this B1 map smoothing is achieved, show some examples of their benefits and weaknesses, and discuss some best practices.","type":"content","url":"/b1-mapping#filtering","position":19},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Filters and smoothing","lvl2":"Filtering"},"type":"lvl3","url":"/b1-mapping#filt1d","position":20},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Filters and smoothing","lvl2":"Filtering"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nThere are two main ways that field maps are smoothened in practice: filters and fitting. The study of filters is typically presented in a signal processing context, however its basic principles (in particular, convolutions) are observed in many other fields of study, in particular physics.\n\nWe‚Äôll begin by providing a very brief overview of some key filtering properties, then move on to some illustrative 1D examples related to MRI situations before finally returning to their applications in actual B1 maps.\n\nFiltering is presented as a convolution process to produce an output that is smoother, meaning less sharp edges. A convolution is the multiplication of a kernel (a predetermined function or property, such as the mean, median, Gaussian function, etc) that is shifted at each point of the signal or image, and the summed value of this multiplication is assigned to the time or spatial point where it was applied. \n\nFigure 4.16 illustrates this for the mean using a three-position mean as a kernel:\n\n\n\nFigure¬†4.15:Convolution using the mean\n\nIn the context of MRI, the mean is not the best choice for a filter, as it is sensitive to high values relative to the base signal. The median is a better choice, which we‚Äôll demonstrate in the next section.\nIn terms of equations, the convolution is shown using the symbol \\otimes, such that analytically it is represented as:\\left( f \\otimes g \\right)\\left( t \\right) =\\int_{-\\infty }^{\\infty }f\\left( u \\right)g\\left( t-u \\right)du\n\nwhere f\\left( t \\right) is the signal of interest and g\\left( t \\right) is the kernel. Not every kernel will lead to smoothing (reduction of high frequencies) of the signal of interest when convolved, however the Gaussian distribution is one such smoothing function:g\\left( x \\right)=\\frac{1}{\\sqrt{2\\pi\\sigma^{2}}}\\text{e}^{-\\frac{\\left( x-x_{o} \\right)^{2}}{2\\sigma^{2}}}\n\nwhere x_{0} is the center position of the distribution, and œÉ is a measure of the width. The convolution using this function with a 9-point sample for different widths is shown in \n\nFigure 4.16.\n\n\n\nFigure¬†4.16:Convolution using a Gaussian kernel\n\nOne property of the convolution is that the convolution of two functions is the multiplication of the \n\nFourier transforms of each function following by an \n\ninverse Fourier transform:\\left( f\\otimes g \\right)\\left( t \\right)=\\mathcal{F}^{-1}\\left( \\mathcal{F}\\left( k \\right) \\cdot \\mathcal{G}\\left( k \\right) \\right)\n\nAlthough convolutions can be computed this way and may me more conceptually clear, particularly the role of the kernel, practically this ends up being slower than the convolution method when using only a small number of samples for the kernel.\n\nAs for ‚Äúsmoothing‚Äù the signal using fitting, splines are simply a piecewise fit of your signal to some function with a continuity condition set at different points throughout the signal. Typically this is done using polynomials, such as a third-order polynomial: \\text{a}x^{3} + \\text{b}x^{2} +\\text{c}x^{1} + \\text{d}x^{0}. There are a lot of different algorithms and ways to do this, which is out of scope for this work.","type":"content","url":"/b1-mapping#filt1d","position":21},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"B1 map examples","lvl2":"Filtering"},"type":"lvl3","url":"/b1-mapping#b1-map-examples","position":22},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"B1 map examples","lvl2":"Filtering"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nLet‚Äôs revisit our initial B1 maps in \n\nFigure 4.14 and see how they respond to the filters we‚Äôve explored in the previous section. The double angle B1 maps were mostly impacted by noise and structural T1 patterns, AFI had some artifacts that were caused by Gibbs ringing in the raw images, and the Bloch-Siegert B1 map had an artifact caused by a phase pole at the end of a fringe line. \n\nFigure 4.22 shows each of the B1 map and the filtered maps using the median, Gaussian, and spline filtering techniques.\n\n\n\nFigure¬†4.22:Filtered B1 maps\n\nAll three methods worked well with the double angle B1 map, and the outputs of the median and Gaussian are most similar. The top right corner of the spline-filtered double angle B1 map has higher intensity, likely due to an edge effect as discussed in the \n\n1D example section. For AFI, median and gaussian filters removed most of the repeated variations, whereas spline-filtering didn‚Äôt at the medium filter strength. Lastly, for Bloch-Siegert, the median filter performed well at removing the noise and smoothing out the artifact, though some still remains. For the Gaussian and spline cases, there was a single pixel in the left that had very high value in the unfiltered images and this led to a spreading of high B1 values to nearby voxels, something that didn‚Äôt occur for the median filter case. If either of these filters were used in an automated pipeline without quality control, inaccurate B1 values would have been spread, which is undesireable.","type":"content","url":"/b1-mapping#b1-map-examples","position":23},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Recommendations, benefits, and pitfalls","lvl2":"Filtering"},"type":"lvl3","url":"/b1-mapping#recommendations-benefits-and-pitfalls","position":24},{"hierarchy":{"lvl1":"B1 Mapping","lvl3":"Recommendations, benefits, and pitfalls","lvl2":"Filtering"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nOverall, median, Gaussian, and spline filters perform at smoothing noisy B1 maps. If image artifacts exists in the B1 maps, then the choice of filter could impact the output B1 map.  In all our B1 map examples (\n\nFigure 4.22), a 5x5 voxel median filter would have performed sufficiently all while avoiding spreading errors. This may be a relatively safe filter to try first for clinical use in the brain at clinical field strengths. In other field strengths or anatomies, or if different artifacts exist, this may not always be the case. Good care should always be applied when selecting a filter; know why you are using it, what its potential drawbacks are, and look for error spreading in the output B1 map.\n\nIf your filtered B1 map is intended for use at boundary edges, such as grey matter, extra precautions should be taken when applying filters and doing quality control. Know how your filters handle edges, and if needed choose to mirror or extrapolate B1 values beyond the masked region of interest. Quality control is important, as there can be substantial edge artifacts when using filters.\n\nFinally, remember that using the unfiltered B1 map is also a choice, and many researchers use these. It‚Äôs important to report if you filtered or not your B1 maps when reporting them in your research.","type":"content","url":"/b1-mapping#recommendations-benefits-and-pitfalls","position":25},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Appendix A"},"type":"lvl2","url":"/b1-mapping#daappendixa","position":26},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Appendix A"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\\begin{split}\n\\text{e}^{i2\\alpha} &= \\text{e}^{i\\left( \\alpha+\\alpha \\right)} \\\\\n&= \\text{e}^{i\\alpha+i\\alpha} \\\\\n&= \\text{e}^{i\\alpha}\\text{e}^{i\\alpha} \\\\\n&= \\left( \\text{cos}\\left( \\alpha \\right)+i\\text{sin}\\left( \\alpha \\right) \\right)\\left( \\text{cos}\\left( \\alpha \\right)+i\\text{sin}\\left( \\alpha \\right) \\right) \\\\\n&= \\text{cos}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)+i\\text{cos}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)+i\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)+i^{2}\\text{sin}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)\\\\\n&= \\text{cos}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)+i\\text{cos}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)+i\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)+\\left( -1 \\right)\\text{sin}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)\\\\\n&= \\text{cos}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)+i\\text{cos}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)+i\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)-\\text{sin}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)\\\\\n&= \\text{cos}^{2}\\left( \\alpha \\right)+i\\text{cos}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right)+i\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right)-\\text{sin}^{2}\\left( \\alpha \\right)\\\\\n&= \\left( \\text{cos}^{2}\\left( \\alpha \\right)-\\text{sin}^{2}\\left( \\alpha \\right)\\right)+i\\left( \\text{cos}\\left( \\alpha \\right)\\text{sin}\\left( \\alpha \\right) +\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right) \\right)\\\\\n&= \\left( \\text{cos}^{2}\\left( \\alpha \\right)-\\text{sin}^{2}\\left( \\alpha \\right)\\right)+i\\left( \\text{sin}\\left( \\alpha \\right) \\text{cos}\\left( \\alpha \\right)+\\text{sin}\\left( \\alpha \\right)\\text{cos}\\left( \\alpha \\right) \\right)\\\\\n\\text{e}^{i2\\alpha} &= \\left( \\text{cos}^{2}\\left( \\alpha \\right)-\\text{sin}^{2}\\left( \\alpha \\right)\\right)+i\\left( 2\\text{sin}\\left( \\alpha \\right) \\text{cos}\\left( \\alpha \\right) \\right)\\\\\n\\text{cos}\\left( 2\\alpha \\right)+i\\text{sin}\\left( 2\\alpha \\right) &= \\left( \\text{cos}^{2}\\left( \\alpha \\right)-\\text{sin}^{2}\\left( \\alpha \\right)\\right)+i\\left( 2\\text{sin}\\left( \\alpha \\right) \\text{cos}\\left( \\alpha \\right) \\right)\\\\\n\\end{split} \\\\ \\\\\n\\text{For }z \\in \\mathbb{C} \\text{ and }q \\in \\mathbb{C}\\text{,}\\\\\n\\text{if }z=q \\\\ \n\\text{then }\\text{Re}\\left( z \\right)=\\text{Re}\\left( q \\right) \\\\\n\\text{ and }\\text{Im}\\left( z \\right)=\\text{Im}\\left( q \\right) \\\\\n\\text{thus,} \\\\ \\\\\n\\begin{split}\n\\text{Im}\\left( \\text{cos}\\left( 2\\alpha \\right)+i\\text{sin}\\left( 2\\alpha \\right) \\right) &= \\text{Im}\\left( \\left( \\text{cos}^{2}\\left( \\alpha \\right)-\\text{sin}^{2}\\left( \\alpha \\right)\\right)+i\\left( 2\\text{sin}\\left( \\alpha \\right) \\text{cos}\\left( \\alpha \\right) \\right) \\right)\\\\\n\\text{sin}\\left( 2\\alpha \\right) &= 2\\text{sin}\\left( \\alpha \\right) \\text{cos}\\left( \\alpha \\right) \\\\\n\\end{split}\\\\\nQ.E.D.","type":"content","url":"/b1-mapping#daappendixa","position":27},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Exercises"},"type":"lvl2","url":"/b1-mapping#exercises","position":28},{"hierarchy":{"lvl1":"B1 Mapping","lvl2":"Exercises"},"content":"In practice, B_1_ values in the brain have been reported to range from 0.7 to 1.2  \n\nBoudreau et al., 2017. Using \n\nFigure 4.4, estimate the approximate range in error in measured B1 values for B1 maps computed using the double angle method with hard or composite refocusing pulsers.\n\nYou are provided with an animal model subject that has tissue with T_1 values on the order of 100 ms +- 30 ms. Using the figures and accompanying Jupyter Notebooks, develop an imaging protocol for B_1_ mapping using the AFI techhnique that will be insensitive to the T_1 of the tissue. Demonstrate that the resulting B_1_ map will have errors of less than < 1% for this range of T_1 values.\n\nYou are provided with B_1_ mapping data which appears to be very sensitive to the motion of blood in the vessels (i.e. you see bright spots in the B_1_ maps). The researcher indicates that they do not needs accurate B_1_ maps inside these regions, but would like to filter the maps in the brain tissue.\n\nWithout a mask, mhich filter method should you use to filter the B_1_ maps? Why?\n\nHow would you create a mask for the blood vessels in the B_1_ maps?\n\nWith a mask, which filter method should you use to filter the B_1_ maps? Why?","type":"content","url":"/b1-mapping#exercises","position":29},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-1-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"05-B0/data/fmap\"\n\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\nfname_mag_e1 = data_dir / \"sub-fmap_magnitude1.nii.gz\"\nfname_mag_e1_json = data_dir / \"sub-fmap_magnitude1.json\"\nfname_phase_e1 = data_dir / \"sub-fmap_phase1.nii.gz\"\nfname_phase_e2 = data_dir / \"sub-fmap_phase2.nii.gz\"\nfname_mask = data_dir / \"mask.nii.gz\"\nfname_fmap = data_dir / \"fmap.nii.gz\"\nmag_e1 = nib.load(fname_mag_e1).get_fdata()[30:-30,8:108,30]\nphase_e1 = nib.load(fname_phase_e1).get_fdata()[30:-30,8:108,30]\nphase_e2 = nib.load(fname_phase_e2).get_fdata()[30:-30,8:108,30]\nfmap_hz = nib.load(fname_fmap).get_fdata()[30:-30,8:108,30]\n# mag_e1 = nib.load(fname_mag_e1).get_fdata()\n# phase_e1 = nib.load(fname_phase_e1).get_fdata()\n# phase_e2 = nib.load(fname_phase_e2).get_fdata()\n# mask = nib.load(fname_mask).get_fdata()\n# fmap_hz = nib.load(fname_fmap).get_fdata()\n\nwith open(fname_mag_e1_json, 'r') as json_data:\n    data = json.load(json_data)\n\nfreq = data[\"ImagingFrequency\"]\nfmap_t = fmap_hz / GYRO_BAR_RATIO_H * 1e6\nfmap_ppm = fmap_hz / freq\n\nfig = go.Figure()\nfig.add_trace(go.Heatmap(z=np.rot90(mag_e1, k=-1),\n                         colorscale='gray',\n                         colorbar=dict(\n                            title=\"a.u.\",\n                            titleside=\"top\",\n                            tickmode=\"array\"\n                         ))\n             )\nfig.add_trace(go.Heatmap(z=np.rot90(phase_e2 / 4095 * 2 * math.pi - math.pi, k=-1),\n                         colorscale='gray',\n                         colorbar=dict(\n                            title=\"Rad\",\n                            titleside=\"top\",\n                            tickmode=\"array\",\n                            tickvals=[-math.pi, 0, math.pi-0.01],\n                            ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}']\n                        ),\n                         visible=False))\nfig.add_trace(go.Heatmap(z=np.rot90(fmap_hz, k=-1),\n                         colorscale='gray',\n                         colorbar=dict(\n                            title=\"Hz\",\n                            titleside=\"top\",\n                            tickmode=\"array\"\n                        ),\n                         visible=False))\nfig.add_trace(go.Heatmap(z=np.rot90(fmap_t, k=-1),\n                         colorscale='gray',\n                         colorbar=dict(\n                            title=f\"{MICRO_UNICODE}T\",\n                            titleside=\"top\",\n                            tickmode=\"array\"\n                        ),\n                         visible=False))\nfig.add_trace(go.Heatmap(z=np.rot90(fmap_ppm, k=-1),\n                         colorscale='gray',\n                         colorbar=dict(\n                            title=\"ppm\",\n                            titleside=\"top\",\n                            tickmode=\"array\"\n                        ),\n                         visible=False))\n\n\n\nx0=0\ny0=89\nx1=10\ny1=99\nh = 2\nrounded_bottom_left = f' M {x0+h}, {y0} Q {x0}, {y0} {x0}, {y0+h}'#\nrounded_top_left = f' L {x0}, {y1-h} Q {x0}, {y1} {x0+h}, {y1}'\nrounded_top_right = f' L {x1-h}, {y1} Q {x1}, {y1} {x1}, {y1-h}'\nrounded_bottom_right = f' L {x1}, {y0+h} Q {x1}, {y0} {x1-h}, {y0}Z'\npath = rounded_bottom_left + rounded_top_left+\\\n         rounded_top_right+rounded_bottom_right\n\nannotations = ['A', 'B', 'C', 'D', 'E']\nshapes = []\nfor i_shape, annotation in enumerate(annotations):\n    shapes.append(dict(type='path',\n                       path=path,\n                       fillcolor='white',\n                       layer='above',\n                       line=dict(width=1),\n                       label=dict(text=f\"<b>{annotation}</b>\")\n                      )\n                 )\n\nfig.add_shape(shapes[0])\n# Add dropdown\nfig.update_layout(\n    title_text=\"Magnitude\",\n    title_x=0.5,\n    height=500,\n    width=600,\n    updatemenus=[\n        dict(\n            buttons=list([\n                dict(\n                    method=\"update\",\n                    args=[{\"visible\": [True, False, False, False, False]},\n                          {'shapes': [shapes[0]], \"title\": \"Magnitude\"}],\n                    label=\"Magnitude\",\n                ),\n                dict(\n                    method=\"update\",\n                    args=[{\"visible\": [False, True, False, False, False]},\n                          {'shapes': [shapes[1]], \"title\": \"Phase\"}],\n                    label=\"Phase\",\n                    \n                ),\n                dict(\n                    method=\"update\",\n                    args=[{\"visible\": [False, False, True, False, False]},\n                          {'shapes': [shapes[2]], \"title\": \"B0 Fieldmap (Hz)\"}],\n                    label=\"B0 field map (Hz)\",\n                ),\n                dict(\n                    method=\"update\",\n                    args=[{\"visible\": [False, False, False, True, False]},\n                          {'shapes': [shapes[3]], \"title\": f\"B0 Fieldmap ({MICRO_UNICODE}Tesla)\"}],\n                    label=f\"B0 field map ({MICRO_UNICODE}Tesla)\",\n                ),\n                dict(\n                    method=\"update\",\n                    args=[{\"visible\": [False, False, False, False, True]},\n                          {'shapes': [shapes[4]], \"title\": \"B0 Fieldmap (ppm)\"}],\n                    label=\"B0 field map (ppm)\",\n                )\n            ]),\n            direction=\"down\",\n            showactive=True,\n        )\n    ]\n)\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.show()\n","type":"content","url":"/figure-5-1-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-1-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"05-B0/data/fmap\"\n\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\ndef dipole_kernel(b0_dir, voxel_size, n_voxels):\n    \"\"\" Create a dipole kernel\n    dipole kernel: (3*cos(theta)**2 - 1) / (4*pi*r**3)\n                => (3*r**2*cos(theta)**2 - r**2) / (4*pi*r**5)\n                => (3*b0_dir**2 - r**2) / (4*pi*r**2**2.5)\n\n        Function inspired and derived from: https://onlinelibrary.wiley.com/doi/10.1002/mrm.28716\n    \"\"\"\n    eps = 0.00001\n    x, y, z = np.meshgrid(range(round(-n_voxels[0]/2+0.5), round(n_voxels[0]/2+0.5)), range(round(-n_voxels[1]/2+0.5), round(n_voxels[1]/2+0.5)), range(round(-n_voxels[2]/2+0.5), round(n_voxels[2]/2+0.5)), indexing='ij')\n\n    x = x * voxel_size[0] + eps\n    y = y * voxel_size[1] + eps\n    z = z * voxel_size[2] + eps\n\n    r2 = (x**2 + y**2 + z**2)\n\n    d = np.prod(voxel_size) * ( 3 * ((x*b0_dir[0] + y*b0_dir[1] + z*b0_dir[2])**2) - r2 ) / (4 * math.pi * r2**2.5)\n\n    d[np.isnan(d)] = eps\n    D = np.real(fftshift(fftn(ifftshift(d))))\n\n    mid_voxel = n_voxels[0]//2\n    return d[n_voxels[1]//2], D[n_voxels[1]//2]\n\nb0_dir = (0, 0, 1)\nvoxel_size = np.array((1, 1, 1)) * 1e-3\nn_voxels = (201,201,201)\nd, D = dipole_kernel(b0_dir, voxel_size, n_voxels)\n\nfig = go.Figure()\nfig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.13, vertical_spacing = 0.12, subplot_titles=(\"Dipole Kernel (d)\", \"Dipole Kernel (D)\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]])\nfig.add_trace(go.Heatmap(z=d, colorscale='gray', showscale=False, zmin=-1e-6, zmax=1e-6))\nfig.add_trace(go.Heatmap(z=D, colorscale='gray', showscale=False), 1, 2)\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.update_layout(\n    height=400,\n    width=750)\nfig.show()","type":"content","url":"/figure-5-1-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-1-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"05-B0/data\"\n\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\n\n# Load cylinder (Y 64)\nsusc = nib.load(data_dir / \"field_simulations\" / \"cylinder\" / \"Chi.nii.gz\").get_fdata()\nfmap_hz_all = nib.load(data_dir / \"field_simulations\" / \"cylinder\" / \"fmap_hz.nii.gz\").get_fdata()\nlocal_field_cyl = nib.load(data_dir  / \"field_simulations\" / \"cylinder\" / \"local_field.nii.gz\").get_fdata()\n\nfig = make_subplots(rows=1, cols=3, shared_xaxes=False, horizontal_spacing=0.13, vertical_spacing = 0.12, subplot_titles=(f\"Susceptibility distribution ({CHI_UNICODE})\", \"Simulated B0 map\", \"Simulated B0 map<br>no background field\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]])\nfig.add_trace(go.Heatmap(z=susc, colorscale='gray', colorbar_x=1/3 - 0.09, colorbar=dict(title=\"ppm\", titleside=\"top\")), 1, 1)\nfig.add_trace(go.Heatmap(z=fmap_hz_all, colorscale='gray', colorbar_x=2/3 - 0.045, colorbar=dict(title=\"Hz\", titleside=\"top\")), 1, 2)\nfig.add_trace(go.Heatmap(z=local_field_cyl, colorscale='gray', colorbar_x=1-0.004, colorbar=dict(title=\"Hz\", titleside=\"top\")), 1, 3)\n\n### Create buttons for drop down menu\nlabels = [\"Cylinders\", \"Brain\"]\nbuttons = []\nfor i, label in enumerate(labels):\n    if label == \"Cylinders\":\n        visibility = [True, True, True, False, False, False]\n    else:\n        visibility = [False, False, False, True, True, True]\n    button = dict(\n                 label =  label,\n                 method = 'update',\n                 args = [{'visible': visibility},\n                         {'title': \" \"}])\n    buttons.append(button)\n\nupdatemenus = list([\n    dict(active=0,\n         x=0.58,\n         y=1.5,\n         buttons=buttons,\n         showactive=True,\n    )\n])\n\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.update_layout({\"height\": 350, \"width\": 750},\n                  title_text=\" \",\n                  title_x=0.5,\n                  updatemenus=updatemenus,\n                  showlegend=False\n                 )\nfig.show()\n\n# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\n\ndata_dir = Path(\"../../../../DATA/qmrlab-mooc/05-B0/data\")\n\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\n\n# Load cylinder (Y 64)\nsusc = nib.load(data_dir / \"field_simulations\" / \"cylinder\" / \"Chi.nii.gz\").get_fdata()\nfmap_hz_all = nib.load(data_dir / \"field_simulations\" / \"cylinder\" / \"fmap_hz.nii.gz\").get_fdata()\nlocal_field_cyl = nib.load(data_dir  / \"field_simulations\" / \"cylinder\" / \"local_field.nii.gz\").get_fdata()\n\n# Load brain (Z 210)\nsusc_brain = nib.load(data_dir / \"field_simulations\" / \"brain\" / \"chi_masked.nii.gz\").get_fdata()\nfmap_hz_brain_all = nib.load(data_dir / \"field_simulations\" / \"brain\" / \"fmap_masked.nii.gz\").get_fdata()\nlocal_field_brain = nib.load(data_dir / \"field_simulations\" / \"brain\" / \"local_field.nii.gz\").get_fdata()\n\n# Rotate brain\n\nsusc_brain = np.rot90(susc_brain, -1)\nfmap_hz_brain_all = np.rot90(fmap_hz_brain_all, -1)\nlocal_field_brain = np.rot90(local_field_brain, -1)\n\nfig = make_subplots(rows=1, cols=3, shared_xaxes=False, horizontal_spacing=0.13, vertical_spacing = 0.12, subplot_titles=(f\"Susceptibility distribution ({CHI_UNICODE})\", \"Simulated B0 map\", \"Simulated B0 map<br>no background field\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]])\nfig.add_trace(go.Heatmap(z=susc, colorscale='gray', colorbar_x=1/3 - 0.09, colorbar=dict(title=\"ppm\", titleside=\"top\")), 1, 1)\nfig.add_trace(go.Heatmap(z=fmap_hz_all, colorscale='gray', colorbar_x=2/3 - 0.045, colorbar=dict(title=\"Hz\", titleside=\"top\")), 1, 2)\nfig.add_trace(go.Heatmap(z=local_field_cyl, colorscale='gray', colorbar_x=1-0.004, colorbar=dict(title=\"Hz\", titleside=\"top\")), 1, 3)\nfig.add_trace(go.Heatmap(z=np.rot90(susc_brain, k=-1), colorscale='gray', colorbar_x=1/3 - 0.09, zmin=-0.5, zmax=0.5, colorbar=dict(title=\"ppm\", titleside=\"top\"), visible=False), 1, 1)\nfig.add_trace(go.Heatmap(z=np.rot90(fmap_hz_brain_all, k=-1), colorscale='gray', colorbar_x=2/3 - 0.045, zmin=1100, zmax=2300, colorbar=dict(title=\"Hz\", titleside=\"top\"), visible=False), 1, 2)\nfig.add_trace(go.Heatmap(z=np.rot90(local_field_brain, k=-1), colorscale='gray', zmin=-4, zmax=4, colorbar_x=1-0.004, colorbar=dict(title=\"Hz\", titleside=\"top\"), visible=False), 1, 3)\n\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.update_layout({\"height\": 350, \"width\": 700},\n                  title_text=\" \",\n                  title_x=0.5,\n                  showlegend=False\n                 )\n\n# Add annotation for \"a\" (Figure 5-a)\nfig.add_annotation(\n    x=-0.07,  # X position (0 is left, 1 is right)\n    y=-0.05,  # Y position (0 is bottom, 1 is top)\n    xref=\"paper\",  # Use paper coordinates (relative to the entire figure)\n    yref=\"paper\",\n    text=\"a\",  # Text to display\n    showarrow=False,  # Don't show an arrow\n    font=dict(size=50, color=\"black\"),  # Font size and color\n    xanchor=\"left\",  # Anchor text to the left\n    yanchor=\"bottom\"  # Anchor text to the bottom\n)\n\n\nfig.show()\n\n# Load brain (Z 210)\nsusc_brain = nib.load(data_dir / \"field_simulations\" / \"brain\" / \"chi_masked.nii.gz\").get_fdata()\nfmap_hz_brain_all = nib.load(data_dir / \"field_simulations\" / \"brain\" / \"fmap_masked.nii.gz\").get_fdata()\nlocal_field_brain = nib.load(data_dir / \"field_simulations\" / \"brain\" / \"local_field.nii.gz\").get_fdata()\n\n# Rotate brain\n\nsusc_brain = np.rot90(susc_brain, -1)\nfmap_hz_brain_all = np.rot90(fmap_hz_brain_all, -1)\nlocal_field_brain = np.rot90(local_field_brain, -1)\n\nfig_brain = make_subplots(rows=1, cols=3, shared_xaxes=False, horizontal_spacing=0.13, vertical_spacing = 0.12, subplot_titles=(f\"Susceptibility distribution ({CHI_UNICODE})\", \"Simulated B0 map\", \"Simulated B0 map<br>no background field\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]])\n\nfig_brain.add_trace(go.Heatmap(z=np.rot90(susc_brain, k=-1), colorscale='gray', colorbar_x=1/3 - 0.09, zmin=-0.5, zmax=0.5, colorbar=dict(title=\"ppm\", titleside=\"top\")), 1, 1)\nfig_brain.add_trace(go.Heatmap(z=np.rot90(fmap_hz_brain_all, k=-1), colorscale='gray', colorbar_x=2/3 - 0.045, zmin=1100, zmax=2300, colorbar=dict(title=\"Hz\", titleside=\"top\")), 1, 2)\nfig_brain.add_trace(go.Heatmap(z=np.rot90(local_field_brain, k=-1), colorscale='gray', zmin=-4, zmax=4, colorbar_x=1-0.004, colorbar=dict(title=\"Hz\", titleside=\"top\")), 1, 3)\n\nfig_brain.update_xaxes(showticklabels=False)\nfig_brain.update_yaxes(showticklabels=False)\nfig_brain.update_layout({\"height\": 350, \"width\": 700},\n                  title_text=\" \",\n                  title_x=0.5,\n                  showlegend=False\n                 )\n\n# Add annotation for \"a\" (Figure 5-a)\nfig_brain.add_annotation(\n    x=-0.07,  # X position (0 is left, 1 is right)\n    y=-0.05,  # Y position (0 is bottom, 1 is top)\n    xref=\"paper\",  # Use paper coordinates (relative to the entire figure)\n    yref=\"paper\",\n    text=\"b\",  # Text to display\n    showarrow=False,  # Don't show an arrow\n    font=dict(size=50, color=\"black\"),  # Font size and color\n    xanchor=\"left\",  # Anchor text to the left\n    yanchor=\"bottom\"  # Anchor text to the bottom\n)\n\n\nfig_brain.show()\n\nimport copy\n\n# Create a deep copy of fig_brain\nfig_inverse = copy.deepcopy(fig_brain)\n\n# Remove the annotation (\"b\") from the new fig object\nfig_inverse.layout.annotations = [ann for ann in fig.layout.annotations if ann.text != \"b\"]\n\n# Flip the traces (susc_brain and local_field_brain) using data from fig_brain\n# Swap z, zmin, and zmax between the first and third traces\n(fig_inverse.data[0].z, fig_inverse.data[1].z) = (fig_brain.data[1].z, fig_brain.data[0].z)  # Swap z\n(fig_inverse.data[0].zmin, fig_inverse.data[1].zmin) = (fig_brain.data[1].zmin, fig_brain.data[0].zmin)  # Swap zmin\n(fig_inverse.data[0].zmax, fig_inverse.data[1].zmax) = (fig_brain.data[1].zmax, fig_brain.data[0].zmax)  # Swap zmax\n\n# Swap the annotation titles by reusing the existing annotations\n(fig_inverse.layout.annotations[0].text, fig_inverse.layout.annotations[1].text) = (\n    fig_brain.layout.annotations[1].text, fig_brain.layout.annotations[0].text\n)\n\n# Remove the third trace\nfig_inverse.data = fig_inverse.data[0:2]\nfig_inverse.layout.annotations = fig_inverse.layout.annotations[0:2]\n\nfig_inverse.update_layout({\"height\": 350, \"width\": 700},\n                  title_text=\" \",\n                  title_x=0.5,\n                  showlegend=False\n                 )\n\n                 \n\n# Show the updated figure\nfig_inverse.show()","type":"content","url":"/figure-5-1-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-1-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\n\ndata_dir = Path(\"../../../../DATA/qmrlab-mooc/05-B0/data\")\n\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n# Note: Field was reduced a lot to be able to show the sinusoid\n# Note: *2 after lowpass filter is because this is a single coil (sin instead of e^(-ix)) and demodulating by multiplying a sinusoid creates a 1/2 difference. In practice, since we have both x and y components, we can recover the full signal instead of doing X2.\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\nb0 = 0.000002  # [T]\nT2 = 0.3  # s\ny_0_cst = 100\nfs = 10000\n\nf_larmor = b0 * GYRO_BAR_RATIO_H\nt = np.linspace(0, 1, fs + 1)  # 1 second\n\ndef butter_lowpass(cutoff, fs, order=5):\n    return butter(order, cutoff, fs=fs, btype='low', analog=False)\n\ndef butter_lowpass_filter(data, cutoff, fs, order=5):\n    b, a = butter_lowpass(cutoff, fs, order=order)\n    y = filtfilt(b, a, data, method='gust')\n    return y\n\n# Lab frame\ny_0 = y_0_cst * np.sin(2 * math.pi * f_larmor * t)\nexp = np.exp(-t/T2)\ny = y_0 * exp / y_0_cst\ntemp = y * (y_0 / y_0_cst)\ny_demod = butter_lowpass_filter(temp, f_larmor, fs, order=5) * 2\n\nfig = go.Figure()\nfig.add_scatter(x=t, y=y, name=\"FID\")\nfig.add_scatter(x=t, y=y_demod, name=\"Demodulated FID\")\nfig.add_scatter(x=t, y=exp, name=\"T2 decay\")\n\n# 2 isochromats\ny_1amp = y_0_cst / 10\ny_1 = y_1amp * np.sin(2 * math.pi * (f_larmor + 10) * t)\ny = (y_0 + y_1) * exp / (y_0_cst + y_1amp)\ntemp = y * (y_0 / y_0_cst)\ny_demod = butter_lowpass_filter(temp, f_larmor, fs, order=5) * 2\n\nfig.add_scatter(x=t, y=y, name=\"FID\", visible=False)\nfig.add_scatter(x=t, y=y_demod, name=\"Demodulated FID\", visible=False)\nfig.add_scatter(x=t, y=exp, name=\"T2 decay\", visible=False)\n\n# Multiple isochromats\nn_freqs = 100\nfid = y_0 * exp\ny_sum_demod = butter_lowpass_filter(fid * (y_0 / y_0_cst), f_larmor, fs, order=5) * 2\nfor i in range(n_freqs):\n    amp = 1\n    freq_offset = 10\n    scale = freq_offset/n_freqs\n    mid = n_freqs // 2\n    y_1 = amp * np.sin(2 * math.pi * (f_larmor + scale*(mid - i)) * t) * exp\n    fid += y_1\n    y_demod = butter_lowpass_filter(y_1 * (y_0 / y_0_cst), f_larmor, fs, order=5) * 2\n    y_sum_demod += y_demod\n\ny_demod_scaled = y_sum_demod / (y_0_cst + (n_freqs * amp))\nfid_scaled = fid / (y_0_cst + (n_freqs * amp))\n\nfig.add_scatter(x=t, y=fid_scaled, name=\"FID\", visible=False)\nfig.add_scatter(x=t, y=y_demod_scaled, name=\"Demodulated FID\", visible=False)\nfig.add_scatter(x=t, y=exp, name=\"T2 decay\", visible=False)\nfig.update_traces(marker=dict(size=3))\nfig.update_layout(\n    title=\"Single species\",\n    title_x=0.5,\n    updatemenus=[\n        dict(\n            buttons=list([\n                dict(\n                    args=[{\"visible\": [True, True, True, False, False, False, False, False, False]},\n                          {\"title\": \"Single species\"}],\n                    label=\"Single species\",\n                    method=\"update\"\n                ),\n                dict(\n                    args=[{\"visible\": [False, False, False, True, True, True, False, False, False]},\n                          {\"title\": \"Two species\"}],\n                    label=\"Two species\",\n                    method=\"update\"\n                ),\n                dict(\n                    args=[{\"visible\": [False, False, False, False, False, False, True, True, True]},\n                          {\"title\": \"Multiple Species\"}],\n                    label=\"Multiple Species\",\n                    method=\"update\"\n                )\n            ]),\n            direction=\"down\",\n            showactive=True,\n\n        ),\n    ])\nfig.show()","type":"content","url":"/figure-5-1-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-1-5","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport math\nimport json\nimport nibabel as nib\nimport numpy as np\nfrom numpy.fft import ifftn, fftn, ifft, fftshift, ifftshift\nimport os\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom scipy.signal import butter, lfilter, freqz, filtfilt\nfrom scipy.io import loadmat\nimport warnings\nPI_UNICODE = \"\\U0001D70B\"\nCHI_UNICODE = \"\\U0001D712\"\nMICRO_UNICODE = \"\\u00B5\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\ndef calc_dk(gx, gy, dt):\n    dkx = GYRO_BAR_RATIO_H * gx * dt\n    dky = GYRO_BAR_RATIO_H * gy * dt\n    return (dkx, dky)\n\ngy_bad = 100e-6\n\nend_time = 0.0912\nn_times = 913\nt = np.linspace(0, end_time, n_times)\ndt = end_time / n_times\nnx = 64\nk = np.zeros([n_times, 2])\nk_distorted = np.zeros([n_times, 2])\nfor it in range(1, n_times):\n    \n    if it <= 20:\n        gx = -40e-3\n        gy = -40e-3\n    else:\n        n_steps = 138\n        i = (it - 20) % n_steps\n        if i <= 0:\n            gx = 0\n            gy = 25e-3\n        elif i <= nx:\n            gx = 25e-3\n            gy = 0\n        elif i <= nx + 5:\n            gx = 0\n            gy = 25e-3\n        elif i <= (2*nx) + 5:\n            gx = -25e-3\n            gy = 0\n        elif i <= n_steps:\n            gx = 0\n            gy = 25e-3\n\n    dkx, dky = calc_dk(gx, gy, dt)\n    kx = k[it - 1, 0] + dkx\n    ky = k[it - 1, 1] + dky\n    k[it, :] = [kx, ky]\n    dkx, dky = calc_dk(gx, gy + gy_bad, dt)\n    kx = k_distorted[it - 1, 0] + dkx\n    ky = k_distorted[it - 1, 1] + dky\n    k_distorted[it, :] = [kx, ky]\n\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=k[:, 0], y=k[:, 1],\n                     mode='lines',\n                     line=dict(color='#636EFA'),\n                     name='Theoretical trajectory'))\nfig.add_trace(go.Scatter(x=k_distorted[:, 0], y=k_distorted[:, 1],\n                     mode='lines',\n                     line=dict(color='#fa6363'),\n                     name='Inhomogeneous trajectory'))\nframes = [dict(\n    data=[go.Scatter(x=k[:2*i, 0], y=k[:2*i, 1],\n                     mode='lines',\n                     line=dict(color='#636EFA'),\n                     name='Theoretical trajectory'),\n          go.Scatter(x=k_distorted[:2*i, 0], y=k_distorted[:2*i, 1],\n                     mode='lines',\n                     line=dict(color='#fa6363'),\n                     name='Inhomogeneous trajectory')],\n    name=str(i),\n    traces=[0,1]) for i in range(int(n_times/2))]\nfig.frames = frames\n\nfig.update_xaxes(range=[-3500, 3500])\nfig.update_yaxes(range=[-3700, 3700])\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.update_layout(title=\"K-space Trajectory\",\n                  title_x=0.5,\n                  height=600,\n                  width=700,\n                  updatemenus=[dict(\n                                type='buttons',\n                                buttons=[dict(label='Play',\n                                              method='animate',\n                                              args=[None, dict(frame=dict(duration=15, redraw=False), transition=dict(duration=15), fromcurrent=True, mode='immediate')]),\n                                         dict(label='Pause',\n                                              method='animate',\n                                              args=[[None], dict(frame=dict(duration=0, redraw=False), mode='immediate')])\n                                        ])])\nfig.show()","type":"content","url":"/figure-5-1-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-2-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\nPI_UNICODE = \"\\U0001D70B\"\n\n# Parameters\nnum_frames = 200\nomega_0 = 1  # Larmor frequency\nomega_1 = 0.9  # Inhomogeneous spin\ntime_max = 5  # [s]\n\n# Initial phase of the spin\ninitial_phase = 0.5\n\n# Time array\ntime = np.linspace(0, time_max, num_frames)\n\n# Generate data for spins\nx = np.cos(omega_0 * (2*math.pi) * time + initial_phase)\ny = np.sin(omega_0 * (2*math.pi) * time + initial_phase)\nx1 = np.cos(omega_1 * (2*math.pi) * time + initial_phase)\ny1 = np.sin(omega_1 * (2*math.pi) * time + initial_phase)\n\n# Generate data for spins in rotating frame of reference\nx_rot = np.cos((omega_0-omega_0) * (2*math.pi) * time + initial_phase)\ny_rot = np.sin((omega_0-omega_0) * (2*math.pi) * time + initial_phase)\nx1_rot = np.cos((omega_1-omega_0) * (2*math.pi) * time + initial_phase)\ny1_rot = np.sin((omega_1-omega_0) * (2*math.pi) * time + initial_phase)\n\n# Calculate angles\nangles = (np.arctan2(y,x))\nangles1 = (np.arctan2(y1,x1))\nangles_rot = (np.arctan2(y_rot,x_rot))\nangles1_rot = (np.arctan2(y1_rot,x1_rot))\n\n# Create figure\nfig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Rotating Spin\", \"Signal Phase (rad)\"))\n\n# Add spin as an arrow\nfig.add_trace(go.Scatter(\n    x=[0, x[0]],\n    y=[0, y[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='blue', width=3),\n    name='Spin at f0'),\n    row=1, col=1)\nfig.add_trace(go.Scatter(\n    x=[0, x1[0]],\n    y=[0, y1[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='red', width=3),\n    name='Inhomogeneous Spin'),\n    row=1, col=1)\n\n# Add phase of the signal\nfig.add_trace(go.Scatter(\n    x=[time[0]],\n    y=[angles[0]],\n    mode='markers',\n    marker=dict(color='blue', size=5),\n    name='Phase'),\n    row=1, col=2\n)\nfig.add_trace(go.Scatter(\n    x=[time],\n    y=[angles1],\n    mode='markers',\n    marker=dict(color='red', size=5),\n    name='Inhomogeneous Phase'),\n    row=1, col=2\n)\n# Rotating frame\nfig.add_trace(go.Scatter(\n    x=[0, x_rot[0]],\n    y=[0, y_rot[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='blue', width=3),\n    name='Spin at f0', visible=False),\n    row=1, col=1)\nfig.add_trace(go.Scatter(\n    x=[0, x1_rot[0]],\n    y=[0, y1_rot[0]],\n    mode='lines+markers',\n    marker=dict(size=5),\n    line=dict(color='red', width=3),\n    name='Inhomogeneous Spin', visible=False),\n    row=1, col=1)\n\n# Add phase of the signal\nfig.add_trace(go.Scatter(\n    x=[time[0]],\n    y=[angles_rot[0]],\n    mode='markers',\n    marker=dict(color='blue', size=5),\n    name='Phase', visible=False),\n    row=1, col=2\n)\nfig.add_trace(go.Scatter(\n    x=[time],\n    y=[angles1_rot],\n    mode='markers',\n    marker=dict(color='red', size=5),\n    name='Inhomogeneous Phase', visible=False),\n    row=1, col=2\n)\n\nfig.update_xaxes(range=[-1.1, 1.1], row=1, col=1)\nfig.update_yaxes(range=[-1.1, 1.1], row=1, col=1)\nfig.update_xaxes(range=[np.min(time), np.max(time)], row=1, col=2)\nfig.update_yaxes(range=[np.min(angles) + 0.1*np.min(angles), np.max(angles) + 0.1*np.max(angles)], row=1, col=2)\n\n# Add frames\nframes = [dict(\n    data=[go.Scatter(x=[0, x[i]],\n                     y=[0, y[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#636EFA', width=3),\n                     name='Spin at f0'),\n          go.Scatter(x=[0, x1[i]],\n                     y=[0, y1[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#fa6363', width=3),\n                     name='Inhomogeneous Spin'),\n          go.Scatter(x=time[:i],\n                     y=angles[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='blue', width=3),\n                     name='Phase'),\n          go.Scatter(x=time[:i],\n                     y=angles1[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='red', width=3),\n                     name='Inhomogeneous Phase'),\n          go.Scatter(x=[0, x_rot[i]],\n                     y=[0, y_rot[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#636EFA', width=3),\n                     name='Spin at f0'),\n          go.Scatter(x=[0, x1_rot[i]],\n                     y=[0, y1_rot[i]],\n                     mode='lines+markers',\n                     marker=dict(size=5),\n                     line=dict(color='#fa6363', width=3),\n                     name='Inhomogeneous Spin'),\n          go.Scatter(x=time[:i],\n                     y=angles_rot[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='blue', width=3),\n                     name='Phase'),\n          go.Scatter(x=time[:i],\n                     y=angles1_rot[:i],\n                     mode='lines',\n                     marker=dict(size=5),\n                     line=dict(color='red', width=3),\n                     name='Inhomogeneous Phase')\n         \n         \n         ],\n    name=str(i),\n    traces=[0,1,2,3,4,5,6,7]) for i in range(num_frames)]\n\nfig.frames = frames\n\n# Determine the maximum absolute value of coordinates\nmax_coord = max(abs(x.max()), abs(y.max()))\n\nfig.update_xaxes(title_text=\"x\", row=1, col=1)\nfig.update_xaxes(title_text=\"time\", row=1, col=2)\nfig.update_yaxes(title_text=\"y\", row=1, col=1)\nfig.update_yaxes(title_text=\"rad\", tickmode = 'array',\n        tickvals = [-math.pi, 0, math.pi],\n        ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'], row=1, col=2)\n\n\n# Update layout\nfig.update_layout(\n    height=450,\n    width=750,\n    title=\"Spins rotating\",\n    xaxis=dict(autorange=False),\n    yaxis=dict(autorange=False),\n    updatemenus=\n    [dict(\n        type='buttons',\n        buttons=[dict(label='Play',\n                      method='animate',\n                      args=[None, dict(frame=dict(duration=50, redraw=False), fromcurrent=True, mode='immediate')]),\n                 dict(label='Pause',\n                      method='animate',\n                      args=[[None], dict(frame=dict(duration=0, redraw=False), mode='immediate')])\n                ],\n         ),\n     dict(\n        buttons=[dict(\n                    args=[{\"visible\": [True, True, True, True, False, False, False, False]}],\n                    label=\"Laboratory Frame\",\n                    method=\"update\"),\n                dict(\n                    args=[{\"visible\": [False, False, False, False, True, True, True, True]}],\n                    label=\"Rotating Frame\",\n                    method=\"update\"\n                )],\n            direction=\"down\",\n            pad={\"b\": 70},\n            showactive=True,\n            x=-0.13,\n            xanchor=\"left\",\n            y=-0.15,\n            yanchor=\"top\"\n     )\n    ]\n)\n\n# Show figure\nfig.show()","type":"content","url":"/figure-5-2-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-2-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"05-B0/data/fmap\"\n\nPI_UNICODE = \"\\U0001D70B\"\nfname_mag_e1 = data_dir / \"sub-fmap_magnitude1.nii.gz\"\nfname_phase_e1 = data_dir / \"sub-fmap_phase1.nii.gz\"\nfname_phase_e1_json = data_dir / \"sub-fmap_phase1.json\"\nfname_phase_e2 = data_dir / \"sub-fmap_phase2.nii.gz\"\nfname_mask = data_dir / \"mask.nii.gz\"\nfname_fmap = data_dir / \"fmap.nii.gz\"\n\nnii_mag_e1 = nib.load(fname_mag_e1)\nnii_phase_e1 = nib.load(fname_phase_e1)\nnii_phase_e2 = nib.load(fname_phase_e2)\nnii_mask = nib.load(fname_mask)\nnii_fmap = nib.load(fname_fmap)\n\n# Phase evolution though different echo times\nmask = nii_mask.get_fdata()[30:-30,8:105,30]\nfmap = nii_fmap.get_fdata()[30:-30,8:105,30] * mask  # [Hz]\nphase1 = (nii_phase_e1.get_fdata()[30:-30,8:105,30] / 4095 * 2 * math.pi - math.pi) * mask\n\nwith open(fname_phase_e1_json, 'r') as json_data1:\n    data1 = json.load(json_data1)\n    \necho_time1 = data1['EchoTime']\nphase0 = phase1 - (echo_time1 * (fmap * 2 * math.pi))\nzmin = -math.pi\nzmax = math.pi\n\nsteps = 31\nlast_echo_time = 0.03\necho_times = np.linspace(0.0, last_echo_time, steps)\nfig = go.Figure()\nfor i_echo, echo_time in enumerate(echo_times):\n    phase = phase0 + (fmap * echo_time * 2 * math.pi)\n    phase = np.angle(np.exp(1j*phase))\n    if i_echo >= len(echo_times) - 1:\n        fig.add_trace(go.Heatmap(z=np.rot90(phase, k=-1), visible=True, coloraxis = \"coloraxis\"))\n    else:\n        fig.add_trace(go.Heatmap(z=np.rot90(phase, k=-1), visible=False, coloraxis = \"coloraxis\"))\n\nfig.update_layout(coloraxis = {'colorscale':'gray'},\n                 coloraxis_cmin=zmin, coloraxis_cmax=zmax)\nfig.update_coloraxes(\n    colorbar=dict(title=\"Rad\",\n                  titleside=\"top\",\n                  tickmode=\"array\",\n                  tickvals=[-math.pi, 0, math.pi-0.01],\n                  ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}']))\n\necho_times_str = [f\"{time:.2}\" for time in echo_times]\nsteps = []\nfor i in range(len(fig.data)):\n    step = dict(\n        method=\"update\",\n        label=echo_times_str[i],\n        args=[{\"visible\": [False] * len(fig.data)}],  # layout attribute\n    )\n    step[\"args\"][0][\"visible\"][i] = True  # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    active=30,\n    currentvalue={\"prefix\": \"Echo Time (s): \"},\n    steps=steps\n)]\n\nfig.update_layout(\n    sliders=sliders\n)\n\nfig.update_layout(\n    title=dict(text=\"Phase at different echo times\", x=0.5)\n)\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.update_layout({\"height\": 550, \"width\": 500})\nfig.show()","type":"content","url":"/figure-5-2-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-2-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"05-B0/data/fmap\"\n\n\nPI_UNICODE = \"\\U0001D70B\"\nfname_mag_e1 = data_dir / \"sub-fmap_magnitude1.nii.gz\"\nfname_phase_e1 = data_dir / \"sub-fmap_phase1.nii.gz\"\nfname_phase_e1_json = data_dir / \"sub-fmap_phase1.json\"\nfname_phase_e2 = data_dir / \"sub-fmap_phase2.nii.gz\"\nfname_mask = data_dir / \"mask.nii.gz\"\nfname_fmap = data_dir / \"fmap.nii.gz\"\n\nnii_mag_e1 = nib.load(fname_mag_e1)\nnii_phase_e1 = nib.load(fname_phase_e1)\nnii_phase_e2 = nib.load(fname_phase_e2)\nnii_mask = nib.load(fname_mask)\nnii_fmap = nib.load(fname_fmap)\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\nPI_UNICODE = \"\\U0001D70B\"\n\ndef complex_difference(phase1, phase2):\n    \"\"\" Calculates the complex difference between 2 phase arrays (phase2 - phase1)\n\n    Args:\n        phase1 (numpy.ndarray): Array containing phase data in radians\n        phase2 (numpy.ndarray): Array containing phase data in radians. Must be the same shape as phase1.\n\n    Returns:\n        numpy.ndarray: The difference in phase between each voxels of phase2 and phase1 (phase2 - phase1)\n    \"\"\"\n\n    # Calculate phasediff using complex difference\n    comp_0 = np.exp(-1j * phase1)\n    comp_1 = np.exp(1j * phase2)\n    return np.angle(comp_0 * comp_1)\nn=2\ndef plot_2_echo_fmap(phase1, phase2, echotime1, echotime2):\n    phase_diff = complex_difference(phase1, phase2)\n    fmap = phase_diff / (echotime2 - echotime1) / 2 / math.pi\n\n    # Attempt at subplots\n    fig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Phase 1\", \"Phase 2\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]], )\n    \n    fig.add_trace(go.Heatmap(z=np.rot90(phase1, k=-1), colorscale='gray', colorbar_x=1/n - 0.05, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 1)\n    fig.add_trace(go.Heatmap(z=np.rot90(phase2, k=-1), colorscale='gray', colorbar_x=2/n - 0.02, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 2)\n    \n    fig.update_xaxes(showticklabels=False)\n    fig.update_yaxes(showticklabels=False)\n    fig.update_layout({\"height\": 450, \"width\": 750})\n    \n    fig.show()\n\n\ndef plot_2_echo_fmap_bottom(phase1, phase2, echotime1, echotime2):\n    phase_diff = complex_difference(phase1, phase2)\n    fmap = phase_diff / (echotime2 - echotime1) / 2 / math.pi\n\n    # Attempt at subplots\n    fig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Phase difference\", \"B0 field map\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]], )\n    \n    fig.add_trace(go.Heatmap(z=np.rot90(phase_diff, k=-1), colorscale='gray', colorbar_x=1/n - 0.05, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 1)\n    fig.add_trace(go.Heatmap(z=np.rot90(fmap, k=-1), colorscale='gray',colorbar_x=2/n - 0.02,\n                             colorbar=dict(title=\"Hz\",\n                                           titleside=\"top\")), 1, 2)\n    \n    fig.update_xaxes(showticklabels=False)\n    fig.update_yaxes(showticklabels=False)\n    fig.update_layout({\"height\": 450, \"width\": 750})\n    \n    fig.show()\n\ndef get_circle(x, y, r):\n    if x < 1 or y < 1 or r < 1:\n        raise ValueError(\"Input parameters are too small\")\n        \n    my_array = np.zeros([x,y])\n    for i in range(x):\n        for j in range(y):\n            squared = (i-(x/2))**2 + (j-(y/2))**2\n            h = np.sqrt(squared)\n            if h < r:\n                my_array[i,j] = 1\n    return my_array\n\necho1 = get_circle(100, 100, 30) * -1\necho2 = get_circle(100, 100, 30) * 2\necho_time1 = 0.005\necho_time2 = 0.01\n\nplot_2_echo_fmap(echo1, echo2, echo_time1, echo_time2)\n\n\n\nplot_2_echo_fmap_bottom(echo1, echo2, echo_time1, echo_time2)\n","type":"content","url":"/figure-5-2-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-2-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"05-B0/data/fmap\"\n\n\nPI_UNICODE = \"\\U0001D70B\"\nfname_mag_e1 = data_dir / \"sub-fmap_magnitude1.nii.gz\"\nfname_phase_e1 = data_dir / \"sub-fmap_phase1.nii.gz\"\nfname_phase_e1_json = data_dir / \"sub-fmap_phase1.json\"\nfname_phase_e2 = data_dir / \"sub-fmap_phase2.nii.gz\"\nfname_mask = data_dir / \"mask.nii.gz\"\nfname_fmap = data_dir / \"fmap.nii.gz\"\n\nnii_mag_e1 = nib.load(fname_mag_e1)\nnii_phase_e1 = nib.load(fname_phase_e1)\nnii_phase_e2 = nib.load(fname_phase_e2)\nnii_mask = nib.load(fname_mask)\nnii_fmap = nib.load(fname_fmap)\n\n#| label: b0Fig8jn\n\n#| label: b0Fig7jn\n\n# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\n\nimport scipy.io as sio\nfrom pathlib import Path\n\ndata_dir = Path(\"../../../../DATA/qmrlab-mooc/05-B0/data/fmap\")\n\nPI_UNICODE = \"\\U0001D70B\"\nfname_mag_e1 = data_dir / \"sub-fmap_magnitude1.nii.gz\"\nfname_phase_e1 = data_dir / \"sub-fmap_phase1.nii.gz\"\nfname_phase_e1_json = data_dir / \"sub-fmap_phase1.json\"\nfname_phase_e2 = data_dir / \"sub-fmap_phase2.nii.gz\"\nfname_mask = data_dir / \"mask.nii.gz\"\nfname_fmap = data_dir / \"fmap.nii.gz\"\n\nnii_mag_e1 = nib.load(fname_mag_e1)\nnii_phase_e1 = nib.load(fname_phase_e1)\nnii_phase_e2 = nib.load(fname_phase_e2)\nnii_mask = nib.load(fname_mask)\nnii_fmap = nib.load(fname_fmap)\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nimport json\nPI_UNICODE = \"\\U0001D70B\"\n\ndef complex_difference(phase1, phase2):\n    \"\"\" Calculates the complex difference between 2 phase arrays (phase2 - phase1)\n\n    Args:\n        phase1 (numpy.ndarray): Array containing phase data in radians\n        phase2 (numpy.ndarray): Array containing phase data in radians. Must be the same shape as phase1.\n\n    Returns:\n        numpy.ndarray: The difference in phase between each voxels of phase2 and phase1 (phase2 - phase1)\n    \"\"\"\n\n    # Calculate phasediff using complex difference\n    comp_0 = np.exp(-1j * phase1)\n    comp_1 = np.exp(1j * phase2)\n    return np.angle(comp_0 * comp_1)\nn=2\ndef plot_2_echo_fmap(phase1, phase2, echotime1, echotime2):\n    phase_diff = complex_difference(phase1, phase2)\n    fmap = phase_diff / (echotime2 - echotime1) / 2 / math.pi\n\n    # Attempt at subplots\n    fig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Phase 1\", \"Phase 2\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]], )\n    \n    fig.add_trace(go.Heatmap(z=np.rot90(phase1, k=-1), colorscale='gray', colorbar_x=1/n - 0.05, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 1)\n    fig.add_trace(go.Heatmap(z=np.rot90(phase2, k=-1), colorscale='gray', colorbar_x=2/n - 0.02, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 2)\n    \n    fig.update_xaxes(showticklabels=False)\n    fig.update_yaxes(showticklabels=False)\n    fig.update_layout({\"height\": 450, \"width\": 750})\n    \n    fig.show()\n\n\ndef plot_2_echo_fmap_bottom(phase1, phase2, echotime1, echotime2):\n    phase_diff = complex_difference(phase1, phase2)\n    fmap = phase_diff / (echotime2 - echotime1) / 2 / math.pi\n\n    # Attempt at subplots\n    fig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.1, subplot_titles=(\"Phase difference\", \"B0 field map\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]], )\n    \n    fig.add_trace(go.Heatmap(z=np.rot90(phase_diff, k=-1), colorscale='gray', colorbar_x=1/n - 0.05, zmin=-math.pi, zmax=math.pi,\n                             colorbar=dict(title=\"Rad\",\n                                           titleside=\"top\",\n                                           tickmode=\"array\",\n                                           tickvals=[-math.pi, 0, math.pi-0.01],\n                                           ticktext = [f\"-{PI_UNICODE}\", 0, f'{PI_UNICODE}'])), 1, 1)\n    fig.add_trace(go.Heatmap(z=np.rot90(fmap, k=-1), colorscale='gray',colorbar_x=2/n - 0.02,\n                             colorbar=dict(title=\"Hz\",\n                                           titleside=\"top\")), 1, 2)\n    \n    fig.update_xaxes(showticklabels=False)\n    fig.update_yaxes(showticklabels=False)\n    fig.update_layout({\"height\": 450, \"width\": 750})\n    \n    fig.show()\n\ndef get_circle(x, y, r):\n    if x < 1 or y < 1 or r < 1:\n        raise ValueError(\"Input parameters are too small\")\n        \n    my_array = np.zeros([x,y])\n    for i in range(x):\n        for j in range(y):\n            squared = (i-(x/2))**2 + (j-(y/2))**2\n            h = np.sqrt(squared)\n            if h < r:\n                my_array[i,j] = 1\n    return my_array\n\necho1 = get_circle(100, 100, 30) * -1\necho2 = get_circle(100, 100, 30) * 2\necho_time1 = 0.005\necho_time2 = 0.01\n\nmask = nii_mask.get_fdata()[30:-30,8:105,30]\nphase1 = (nii_phase_e1.get_fdata()[30:-30,8:105,30] / 4095 * 2 * math.pi - math.pi) * mask\nphase2 = (nii_phase_e2.get_fdata()[30:-30,8:105,30] / 4095 * 2 * math.pi - math.pi) * mask\necho_time1 = 0.00338\necho_time2 = 0.00558\n\nplot_2_echo_fmap(phase1, phase2, echo_time1, echo_time2)\n\n\nplot_2_echo_fmap_bottom(phase1, phase2, echo_time1, echo_time2)","type":"content","url":"/figure-5-2-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-3-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nfrom dash import Dash, dcc, html\nimport pandas as pd\nPI_UNICODE = \"\\U0001D70B\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\n# Taken from real brain data\nphase1, phase2, phase3, phase4 = (2.9298516102709202, -0.21864564255753116, -2.2884910587688285, 2.392827225041896)\nbeg = 0\nend = 0.015\n\nt = np.array([0.00263, 0.00526, 0.009, 0.013])\nn_echoes = len(t)\ny = np.array([phase1, phase2, phase3, phase4])\ny_unwrapped = np.array([phase1, phase2, phase3, phase4 - (2 * math.pi)])\n\nreg = LinearRegression().fit(t.reshape(-1, 1), y_unwrapped.reshape(-1,1))\n# Slope of linear regression reshaped into the shape of original 3D phase.\nfieldmap_rad = reg.coef_[0]  # [rad / s]\nfieldmap_intercept = reg.intercept_[0]  # [rad / s]\n\nt_predict = np.array([beg, end])\ny_predict = reg.predict(t_predict.reshape(-1,1))[:,0]\n\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=t, y=y, mode='markers', marker=dict(color='blue'), name='Original Phase'))\nfig.add_trace(go.Scatter(x=[t[3]], y=[phase4- (2*math.pi)], mode='markers', marker=dict(color='red'), name='Unwrapped Phase'))\nfig.add_trace(go.Scatter(x=t_predict, y=y_predict, mode='lines', marker=dict(color='green'), name='Fit'))\nfig.add_trace(go.Scatter(x=[beg, end], y=[math.pi, math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.add_trace(go.Scatter(x=[beg, end], y=[-math.pi, -math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\n\nfig.update_xaxes(title_text=\"Time (ms)\", range=[beg, end])\nfig.update_yaxes(title_text=\"Phase (rad)\", tickmode = 'array', range=[-7,7],\n                 tickvals = [-2*math.pi, -math.pi, 0, math.pi, 2*math.pi],\n                 ticktext = [f'-2{PI_UNICODE}', f'-{PI_UNICODE}', '0', f'{PI_UNICODE}', f'2{PI_UNICODE}'])\nfig.update_layout({\"width\": 800})\n\nfig.show()","type":"content","url":"/figure-5-3-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-3-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nfrom dash import Dash, dcc, html\nimport pandas as pd\nPI_UNICODE = \"\\U0001D70B\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\n# Taken from real brain data\nphase1, phase2, phase3, phase4 = (2.9298516102709202, -0.21864564255753116, -2.2884910587688285, 2.392827225041896)\nbeg = 0\nend = 0.015\n\nt = np.linspace(0, 10, 1001)\na = 2\ny = a * t - 10\n\n# \nphase = np.angle(np.exp(1j*y))\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=t, y=phase, mode='lines', name='Wrapped phase'))\nfig.add_scatter(x=t, y=y, mode='lines', name='True phase')\nfig.update_traces(marker=dict(size=3))\nfig.update_xaxes(title_text=\"x\")\nfig.update_yaxes(title_text=\"rad\", tickmode = 'array',\n        tickvals = [-3*math.pi, -2*math.pi, -math.pi, 0, math.pi, 2*math.pi, 3*math.pi],\n        ticktext = [f'-3{PI_UNICODE}', f'-2{PI_UNICODE}', f'-{PI_UNICODE}', '0', f'{PI_UNICODE}', f'2{PI_UNICODE}', f'3{PI_UNICODE}'])\nfig.update_layout({\"width\": 800})\nfig.show()","type":"content","url":"/figure-5-3-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-3-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nfrom dash import Dash, dcc, html\nimport pandas as pd\nPI_UNICODE = \"\\U0001D70B\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\nimport dash\nimport dash_bootstrap_components as dbc\nfrom dash import Dash, html, dcc\nimport plotly.express as px\n\nt = np.linspace(0, 3, 1001)\ny_unwrapped = t + t**2 - 3 * t**3 + t**4\ny_wrapped = np.mod(y_unwrapped, 2 * math.pi);\n\ny_delta = y_unwrapped.max() - y_unwrapped.min()\nmin_y = y_unwrapped.min() - 2 * math.pi - y_delta * 0.05\nmax_y = y_unwrapped.max() + 2 * math.pi + y_delta * 0.05\n\nfig1 = go.Figure()\nfig1.add_trace(go.Scatter(x=t, y=y_wrapped,\n                          mode='lines',\n                          name='Wrapped  '))\nfig1.update_layout(title_text=\"Wrapped\", title_x=0.25, showlegend=True,\n                   legend={\"x\": 0.03, \"y\": 0.95})\nfig1.update_yaxes(range=[min_y, max_y], title_text=\"rad\", tickmode = 'array',\n                  tickvals = [-2*math.pi, -math.pi, 0, math.pi, 2*math.pi, 3*math.pi, 4*math.pi, 5*math.pi],\n                  ticktext = [f'-2{PI_UNICODE}', f'-{PI_UNICODE}', '0', f'{PI_UNICODE}', f'2{PI_UNICODE}', f'3{PI_UNICODE}', f'4{PI_UNICODE}', f'5{PI_UNICODE}'])\nfig1.update_xaxes(fixedrange=True)\nfig1.update_yaxes(fixedrange=True)\n\nfig2 = go.Figure()\nfig2.add_trace(go.Scatter(x=t, y=y_unwrapped,\n                          mode='lines',\n                          name='Solution 1', showlegend=True))\nfig2.add_trace(go.Scatter(x=t, y=y_unwrapped+2*math.pi,\n                          mode='lines',\n                          name='Solution 2', showlegend=True))\nfig2.add_trace(go.Scatter(x=t, y=y_unwrapped-2*math.pi,\n                          mode='lines',\n                          name='Solution 3', showlegend=True))\nfig2.update_layout(title_text=\"Unwrapped\", title_x=0.75,\n                   legend={\"x\": 0.85, \"y\": 0.95})\nfig2.update_yaxes(range=[min_y, max_y], title_text=\"rad\", tickmode = 'array',\n                  tickvals = [-2*math.pi, -math.pi, 0, math.pi, 2*math.pi, 3*math.pi, 4*math.pi, 5*math.pi],\n                  ticktext = [f'-2{PI_UNICODE}', f'-{PI_UNICODE}', '0', f'{PI_UNICODE}', f'2{PI_UNICODE}', f'3{PI_UNICODE}', f'4{PI_UNICODE}', f'5{PI_UNICODE}'])\nfig2.update_xaxes(fixedrange=True)\nfig2.update_yaxes(fixedrange=True)\napp = Dash(\n    __name__,\n    external_stylesheets=[dbc.themes.BOOTSTRAP, dbc.icons.FONT_AWESOME],\n    external_scripts=[{'src':\"https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js\"}]\n)\n\ndef beforeAfterSlide(fig1, fig2, style=None):\n    bfA = []\n    if not style:\n        style = {'width':'100vw', 'height':'100vh'}\n    for key in style:\n        if '%' in style[key]:\n            if key in ['width', 'left']:\n                style[key] = style[key].replace('%','vw')\n            if key in ['top', 'height']:\n                style[key] = style[key].replace('%','vh')\n    bfA.append(html.Div(dcc.Graph(figure=fig2, style=style), className='after'))\n    bfA.append(html.Div(className='middle'))\n    bfA.append(html.Div(dcc.Graph(figure=fig1, style=style), className='before'))\n    return html.Div(bfA, className='beforeAfter', style=style)\n\napp.layout = html.Div(beforeAfterSlide(fig1, fig2, {'height':'75%', 'width':'75%', 'top':'10%', 'left':'6%'}))\n\nif __name__ == \"__main__\":\n    app.run_server(debug=True)","type":"content","url":"/figure-5-3-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-3-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nfrom dash import Dash, dcc, html\nimport pandas as pd\nPI_UNICODE = \"\\U0001D70B\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\n\nseed = 2\nnp.random.seed(seed)\nn_points = 20\nlen_x = 500\nlen_y = 500\nmap = np.zeros([len_x, len_y]) - math.pi\nx, y = np.meshgrid(range(len_x), range(len_y))\n\ndef gauss(a, std_x, std_y, center):\n    x0 = int(center[0] * len_x)\n    y0 = int(center[1] * len_y)\n    return a * np.exp(-((((x-x0)**2)/(std_x**2)) + (((y-y0)**2)/(std_y**2))))\n\n\nfor i_point in range(n_points):\n    point = (np.random.uniform(), np.random.uniform())\n    amp = np.random.randint(4, 9)\n    std_x = np.random.randint(50, 100)\n    std_y = np.random.randint(50, 100)\n    map += gauss(amp, std_x, std_y, point)\n\nwrapped = np.angle(np.exp(1j*map))\n\nfig = make_subplots(rows=1, cols=2, shared_xaxes=False, horizontal_spacing=0.2, subplot_titles=(\"Wrapped\", \"Unwrapped\"), specs=[[{\"type\": \"Heatmap\"}, {\"type\": \"Heatmap\"}]])\nfig.add_trace(go.Heatmap(z=wrapped, colorscale='gray', colorbar_x=0.47, colorbar=dict(title=\"Rad\", titleside=\"top\", tickmode=\"array\", tickvals=[-math.pi, 0, math.pi], ticktext = [f'-{PI_UNICODE}', 0, f'{PI_UNICODE}'])), 1, 1)\nfig.add_trace(go.Heatmap(z=map, colorscale='gray', colorbar=dict(title=\"Rad\", titleside=\"top\", tickmode=\"array\",\n                                                                 tickvals=[-2*math.pi, 0, 2*math.pi, 4*math.pi, 6*math.pi, 8*math.pi, 10*math.pi, 12*math.pi, 14*math.pi],\n                                                                 ticktext = [f'-2{PI_UNICODE}', 0, f'2{PI_UNICODE}', f'4{PI_UNICODE}', f'6{PI_UNICODE}', f'8{PI_UNICODE}', f'10{PI_UNICODE}', f'12{PI_UNICODE}', f'14{PI_UNICODE}'])), 1, 2)\nfig.update_layout({\"height\": 400, \"width\": 750})\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.show()","type":"content","url":"/figure-5-3-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-3-5","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nfrom dash import Dash, dcc, html\nimport pandas as pd\nPI_UNICODE = \"\\U0001D70B\"\nGYRO_BAR_RATIO_H = 42.6e6  # [Hz/T]\nlen_x = 500\nlen_y = 500\nx, y = np.meshgrid(np.linspace(-len_x, len_x/2, len_x//2), np.linspace(-len_y, len_y, len_y), indexing='ij')\nx1 = np.array(x)\ny1 = np.array(y)\nx, y = np.meshgrid(np.linspace(-len_x/2, len_x, len_x//2), np.linspace(-len_y, len_y, len_y), indexing='ij')\nx2 = np.array(x)\ny2 = np.array(y)\nx = np.zeros([len_x, len_y])\ny = np.zeros([len_x, len_y])\nx[:len_x//2] = x1\ny[:len_x//2,:] = -y1\nx[len_x//2:,:] = -x2\ny[len_x//2:,:] = -y2\n\n\nphase = np.rot90(np.arctan2(y.astype(float),x.astype(float)),k=-1)\nfig = make_subplots(rows=1, cols=1, subplot_titles=[(\"Phase Singularities\")], specs=[[{\"type\": \"Heatmap\"}]])\nfig.add_trace(go.Heatmap(z=phase, colorscale='gray', colorbar=dict(title=\"Rad\", titleside=\"top\", tickmode=\"array\", tickvals=[-math.pi+0.01, 0, math.pi-0.01], ticktext = [f'-{PI_UNICODE}', 0, f'{PI_UNICODE}'])))\nfig.add_trace(go.Scatter(x=[370, 370], y=[90, 410], mode='markers',  marker=dict(size=10), line=dict(color='red')))\n\nfig.add_shape(type=\"line\", x0=370, y0=90, x1=370, y1=410, line=dict(color=\"red\",width=3))\nfig.add_shape(type=\"path\", path=\"M 370,90 Q 200,250 370,410\", line=dict(color=\"red\",width=3))\nfig.add_annotation(x=390, y=90, text=\"A\", showarrow=False)\nfig.add_annotation(x=390, y=410, text=\"B\", showarrow=False, font=dict(color=\"white\"))\nfig.update_layout({\"width\": 500, \"height\": 400})\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\nfig.show()","type":"content","url":"/figure-5-3-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-4-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nimport copy\nPI_UNICODE = \"\\U0001D70B\"\nDELTA_UNICODE = \"\\u0394\"\nGYRO_UNICODE = \"\\U0001D6FE\"\nGREEK_DELTA_UNICODE = \"\\u03B4\"\n\nphase1, phase2, phase3 = (-4, -2, 0)\nbeg = 0\nend = 0.01\nt = np.array([0.00263, 0.00526, 0.009])\nn_echoes = len(t)\ny1 = np.array([phase1, phase2, phase3])\ny2 = y1 + 2 * math.pi\n\n# Linear fit of the first line\nreg1 = LinearRegression().fit(t.reshape(-1, 1), y1.reshape(-1,1))\nfieldmap_rad1 = reg1.coef_[0]  # [rad / s]\nfieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\nt_predict1 = np.array([beg, end])\ny_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n\n# Linear fit of the second line\nreg2 = LinearRegression().fit(t.reshape(-1, 1), y2.reshape(-1,1))\nfieldmap_rad2 = reg2.coef_[0]  # [rad / s]\nfieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\nt_predict2 = np.array([beg, end])\ny_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n\n# Plot\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=t, y=y1, mode='markers', marker=dict(color='blue'), name='Unwrapped solution 1'))\nfig.add_trace(go.Scatter(x=t_predict1, y=y_predict1, mode='lines', marker=dict(color='blue'), name='Fit'))\nfig.add_trace(go.Scatter(x=t, y=y2, mode='markers', marker=dict(color='red'), name='Unwrapped solution 2'))\nfig.add_trace(go.Scatter(x=t_predict2, y=y_predict2, mode='lines', marker=dict(color='red'), name='Fit'))\nfig.add_annotation(x=0.004, y=-3, text=f\"Slope: {GYRO_UNICODE}{DELTA_UNICODE}B*t\")\nfig.add_annotation(x=0.004, y=3.3, text=f\"Slope: {GYRO_UNICODE}{DELTA_UNICODE}B*t\")\nfig.update_xaxes(title_text=\"Time (ms)\", range=[beg, end])\nfig.update_yaxes(title_text=\"Phase (rad)\", tickmode = 'array', range=[-8,8],\n                 tickvals = [-2*math.pi, -math.pi, 0, math.pi, 2*math.pi],\n                 ticktext = [f'-2{PI_UNICODE}', f'-{PI_UNICODE}', '0', f'{PI_UNICODE}', f'2{PI_UNICODE}'])\nfig.update_layout({\"width\": 800})\nfig.show()","type":"content","url":"/figure-5-4-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-4-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nimport copy\nPI_UNICODE = \"\\U0001D70B\"\nDELTA_UNICODE = \"\\u0394\"\nGYRO_UNICODE = \"\\U0001D6FE\"\nGREEK_DELTA_UNICODE = \"\\u03B4\"\nphase1, phase2, phase3 = (-1, 2, 14)\nphase_wrapped1 = 14-4*math.pi\nphase_unwrapped1 = 14-2*math.pi\nbeg = 0\nend = 0.016\n\nt1 = np.array([0.00263, 0.00526])\nt2 = np.array([0.00263, 0.00526, 0.015])\nn_echoes1 = len(t1)\nn_echoes2 = len(t2)\ny1 = np.array([phase1, phase2])\ny2 = np.array([phase1, phase2, phase3])\n\nreg1 = LinearRegression().fit(t1.reshape(-1, 1), y1.reshape(-1,1))\n# Slope of linear regression reshaped into the shape of original 3D phase.\nfieldmap_rad1 = reg1.coef_[0]  # [rad / s]\nfieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\nt_predict1 = np.array([beg, end])\ny_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n\nreg2 = LinearRegression().fit(t2.reshape(-1, 1), y2.reshape(-1,1))\n# Slope of linear regression reshaped into the shape of original 3D phase.\nfieldmap_rad2 = reg2.coef_[0]  # [rad / s]\nfieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\nt_predict2 = np.array([beg, end])\ny_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=t2, y=y2, mode='markers', marker=dict(color='green'), name='Unwrapped phase'))\nfig.add_trace(go.Scatter(x=[t2[2]], y=[phase_wrapped1], mode='markers', marker=dict(color='blue'), name='Acquired wrapped phase'))\nfig.add_trace(go.Scatter(x=[t2[2]], y=[phase_unwrapped1], mode='markers', marker=dict(color='orange'), name='Wrong unwrapped phase'))\nfig.add_trace(go.Scatter(x=t_predict1, y=y_predict1, mode='lines', marker=dict(color='blue'), name='Fit with first 2 echoes'))\nfig.add_trace(go.Scatter(x=t_predict2, y=y_predict2, mode='lines', marker=dict(color='green'), name='Fit with 3 echoes'))\nfig.add_trace(go.Scatter(x=[beg, end], y=[math.pi, math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.add_trace(go.Scatter(x=[beg, end], y=[-math.pi, -math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.update_xaxes(title_text=\"Time (ms)\", range=[beg, end])\nfig.update_yaxes(title_text=\"Phase (rad)\", tickmode = 'array', range=[-5,15],\n                 tickvals = [-2*math.pi, -math.pi, 0, math.pi, 2*math.pi, 3*math.pi, 4*math.pi, 5*math.pi],\n                 ticktext = [f'-2{PI_UNICODE}', f'-{PI_UNICODE}', '0', f'{PI_UNICODE}', f'2{PI_UNICODE}', f'3{PI_UNICODE}', f'4{PI_UNICODE}', f'5{PI_UNICODE}'])\nfig.update_layout({\"width\": 800}, title_text=f\"Using fast {DELTA_UNICODE}TE to help temporally unwrapped 3rd echo\", title_x=0.5)\n\nfig.show()","type":"content","url":"/figure-5-4-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-4-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nimport copy\nPI_UNICODE = \"\\U0001D70B\"\nDELTA_UNICODE = \"\\u0394\"\nGYRO_UNICODE = \"\\U0001D6FE\"\nGREEK_DELTA_UNICODE = \"\\u03B4\"\nphase1, phase2, phase3 = (-1, 2, 14)\nphase_wrapped1 = 14-4*math.pi\nphase_unwrapped1 = 14-2*math.pi\nbeg = 0\nend = 0.016\ndef complex_difference(phase1, phase2):\n    \"\"\" Calculates the complex difference between 2 phase arrays (phase2 - phase1)\n\n    Args:\n        phase1 (numpy.ndarray): Array containing phase data in radians\n        phase2 (numpy.ndarray): Array containing phase data in radians. Must be the same shape as phase1.\n\n    Returns:\n        numpy.ndarray: The difference in phase between each voxels of phase2 and phase1 (phase2 - phase1)\n    \"\"\"\n\n    # Calculate phasediff using complex difference\n    comp_0 = np.exp(-1j * phase1)\n    comp_1 = np.exp(1j * phase2)\n    return np.angle(comp_0 * comp_1)\n\ndef umpire_3echoes(phases, times):\n    \"\"\"\n    This function performs unwrapping using the UMPIRE algorithm with 3 echoes. UMPIRE requires echo times that are unevenly spaced.\n    \"\"\"\n    \n    # Complex difference\n    dpTE2 = complex_difference(phases[1], phases[2])\n    dpTE1 = complex_difference(phases[0], phases[1])\n    dpd = complex_difference(dpTE1, dpTE2)\n    # print(\"Diff in phase diff:\" , dpd)\n    dTEs = np.array([times[1]-times[0], times[2]-times[1]])\n    dt_dpd = dTEs[1] - dTEs[0]\n    \n    # Slope\n    slope = dpd / dt_dpd\n    \n    # n wraps in differences\n    n_wraps_dp = np.round((dTEs - dTEs*slope) / (2*math.pi))\n    \n    # Remove wraps in differences\n    dpTE1_prime = dpTE1 - (2*n_wraps_dp[0]*math.pi)\n    dpTE2_prime = dpTE2 - (2*n_wraps_dp[1]*math.pi)\n    \n    # Calculate better slope\n    slope_prime1 = dpTE1_prime / dTEs[0]\n    slope_prime2 = dpTE2_prime / dTEs[1]\n    slope_avg = (slope_prime1 + slope_prime2) / 2\n    \n    # Calculate wraps in original phase\n    n_wraps = np.round((phases - t*slope_avg) / (2*math.pi))\n    \n    # Remove wraps\n    unwrapped_with_phase_offset = phases - 2*math.pi*n_wraps\n    \n    # # Calculate receiver offset\n    # r = (t[0] * unwrapped_with_phase_offset[1] - t[1] * unwrapped_with_phase_offset[0]) / dTEs[0]\n\n    # # Remove receiver phase offset\n    # phase_no_offset = complex_difference(r, unwrapped_with_phase_offset)\n    # # Unwrap one last time\n    # ns = np.round((phase_no_offset - t*slope_avg) / (2*math.pi))\n    # unwrapped_umpire = phase_no_offset - 2*math.pi*ns\n    \n    return unwrapped_with_phase_offset\n\nt = np.array([0.003, 0.011, 0.020])\ny_unwrapped = np.array([1.0, 9.05, 17.75])\nwrapped = copy.deepcopy(y_unwrapped)\nwrapped[0] = np.angle(np.exp(1j*wrapped[0]))\nwrapped[1] = np.angle(np.exp(1j*wrapped[1]))\nwrapped[2] = np.angle(np.exp(1j*wrapped[2]))\nbeg = 0.0\nend = 0.021\n\n# Fit original data\nreg1 = LinearRegression().fit(t.reshape(-1, 1), y_unwrapped.reshape(-1,1))\nfieldmap_rad1 = reg1.coef_[0]  # [rad / s]\nfieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\nt_predict1 = np.array([beg, end])\ny_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n\n# Unwrap with UMPIRE\nunwrapped_umpire = umpire_3echoes(wrapped, t)\n\n# Fit unwrapped data of UMPIRE\nreg2 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_umpire.reshape(-1,1))\n# Slope of linear regression reshaped into the shape of original 3D phase.\nfieldmap_rad2 = reg2.coef_[0]  # [rad / s]\nfieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\nt_predict2 = np.array([beg, end])\ny_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n\n# Plot\nheight_annotations = 7*math.pi + 0.5\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=t, y=wrapped, mode='markers', marker=dict(color='blue'), name='Wrapped'))\nfig.add_trace(go.Scatter(x=t, y=y_unwrapped, mode='markers', marker=dict(color='red'), name='True phase'))\nfig.add_trace(go.Scatter(x=t, y=unwrapped_umpire, mode='markers', marker=dict(color='green'), name='Umpire', visible='legendonly'))\nfig.add_trace(go.Scatter(x=t_predict2, y=y_predict2, mode='lines', marker=dict(color='green'), name='Umpire fit', visible='legendonly'))\nfig.add_trace(go.Scatter(x=[beg, end], y=[math.pi, math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.add_trace(go.Scatter(x=[beg, end], y=[-math.pi, -math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.add_trace(go.Scatter(x=[t[0], t[1]], y=[height_annotations, height_annotations], mode='lines+markers', \n                         marker=dict(symbol=\"line-ns-open\", color=\"black\",size=10),\n                         line=dict(color='black'), showlegend=False))\nfig.add_trace(go.Scatter(x=[t[1], t[2]], y=[height_annotations, height_annotations], mode='lines+markers', \n                         marker=dict(symbol=\"line-ns-open\", color=\"black\",size=10),\n                         line=dict(color='black'), showlegend=False))\nfig.add_trace(go.Scatter(x=[t[1], t[2]], y=[height_annotations-3, height_annotations-3], mode='lines+markers', \n                         marker=dict(symbol=\"line-ns-open\", color=\"black\",size=10),\n                         line=dict(color='black'), showlegend=False))\nfig.add_trace(go.Scatter(x=[0.002, 0.002], y=[y_unwrapped[0], y_unwrapped[1]], mode='lines+markers', \n                         marker=dict(symbol=\"line-ew-open\", color=\"black\",size=10),\n                         line=dict(color='black'), showlegend=False))\nfig.add_annotation(x=(t[1]-t[0])/2 + t[0], y=height_annotations+1.15, text=f\"{DELTA_UNICODE}TE1\", showarrow=False)\nfig.add_annotation(x=(t[2]-t[1])/2 + t[1], y=height_annotations+1.15, text=f\"{DELTA_UNICODE}TE2\", showarrow=False)\nfig.add_annotation(x=(t[2]-t[1])/2 + t[1], y=height_annotations+1.15-3, text=f\"{DELTA_UNICODE}TE1 + {GREEK_DELTA_UNICODE}TE\", showarrow=False)\nfig.add_annotation(x=0.0015, y=(y_unwrapped[1] + y_unwrapped[0]) / 2, text=f\">2{PI_UNICODE}\", showarrow=False)\nfig.update_xaxes(title_text=\"Time (ms)\", range=[beg, end])\nfig.update_yaxes(title_text=\"Phase (rad)\", tickmode = 'array', range=[-4,25],\n                 tickvals = [-2*math.pi, 0, 2*math.pi, 4*math.pi, 6*math.pi],\n                 ticktext = [f'-2{PI_UNICODE}', '0', f'2{PI_UNICODE}', f'4{PI_UNICODE}', f'6{PI_UNICODE}'])\nfig.update_layout({\"width\": 800}, title_text=\"Phase unwrapping using UMPIRE algorithm\", title_x=0.5)\nfig.show()\n\n","type":"content","url":"/figure-5-4-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-5-4-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport numpy as np\nimport plotly.express as px\nimport os\nimport nibabel as nib\nimport numpy as np\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport math\nfrom sklearn.linear_model import LinearRegression\nimport copy\nPI_UNICODE = \"\\U0001D70B\"\nDELTA_UNICODE = \"\\u0394\"\nGYRO_UNICODE = \"\\U0001D6FE\"\nGREEK_DELTA_UNICODE = \"\\u03B4\"\nphase1, phase2, phase3 = (-1, 2, 14)\nphase_wrapped1 = 14-4*math.pi\nphase_unwrapped1 = 14-2*math.pi\nbeg = 0\nend = 0.016\ndef complex_difference(phase1, phase2):\n    \"\"\" Calculates the complex difference between 2 phase arrays (phase2 - phase1)\n\n    Args:\n        phase1 (numpy.ndarray): Array containing phase data in radians\n        phase2 (numpy.ndarray): Array containing phase data in radians. Must be the same shape as phase1.\n\n    Returns:\n        numpy.ndarray: The difference in phase between each voxels of phase2 and phase1 (phase2 - phase1)\n    \"\"\"\n\n    # Calculate phasediff using complex difference\n    comp_0 = np.exp(-1j * phase1)\n    comp_1 = np.exp(1j * phase2)\n    return np.angle(comp_0 * comp_1)\n\ndef umpire_3echoes(phases, times):\n    \"\"\"\n    This function performs unwrapping using the UMPIRE algorithm with 3 echoes. UMPIRE requires echo times that are unevenly spaced.\n    \"\"\"\n    \n    # Complex difference\n    dpTE2 = complex_difference(phases[1], phases[2])\n    dpTE1 = complex_difference(phases[0], phases[1])\n    dpd = complex_difference(dpTE1, dpTE2)\n    # print(\"Diff in phase diff:\" , dpd)\n    dTEs = np.array([times[1]-times[0], times[2]-times[1]])\n    dt_dpd = dTEs[1] - dTEs[0]\n    \n    # Slope\n    slope = dpd / dt_dpd\n    \n    # n wraps in differences\n    n_wraps_dp = np.round((dTEs - dTEs*slope) / (2*math.pi))\n    \n    # Remove wraps in differences\n    dpTE1_prime = dpTE1 - (2*n_wraps_dp[0]*math.pi)\n    dpTE2_prime = dpTE2 - (2*n_wraps_dp[1]*math.pi)\n    \n    # Calculate better slope\n    slope_prime1 = dpTE1_prime / dTEs[0]\n    slope_prime2 = dpTE2_prime / dTEs[1]\n    slope_avg = (slope_prime1 + slope_prime2) / 2\n    \n    # Calculate wraps in original phase\n    n_wraps = np.round((phases - t*slope_avg) / (2*math.pi))\n    \n    # Remove wraps\n    unwrapped_with_phase_offset = phases - 2*math.pi*n_wraps\n    \n    # # Calculate receiver offset\n    # r = (t[0] * unwrapped_with_phase_offset[1] - t[1] * unwrapped_with_phase_offset[0]) / dTEs[0]\n\n    # # Remove receiver phase offset\n    # phase_no_offset = complex_difference(r, unwrapped_with_phase_offset)\n    # # Unwrap one last time\n    # ns = np.round((phase_no_offset - t*slope_avg) / (2*math.pi))\n    # unwrapped_umpire = phase_no_offset - 2*math.pi*ns\n    \n    return unwrapped_with_phase_offset\n\nt = np.array([0.003, 0.011, 0.020])\ny_unwrapped = np.array([1.0, 9.05, 17.75])\nwrapped = copy.deepcopy(y_unwrapped)\nwrapped[0] = np.angle(np.exp(1j*wrapped[0]))\nwrapped[1] = np.angle(np.exp(1j*wrapped[1]))\nwrapped[2] = np.angle(np.exp(1j*wrapped[2]))\nbeg = 0.0\nend = 0.021\n\n# Fit original data\nreg1 = LinearRegression().fit(t.reshape(-1, 1), y_unwrapped.reshape(-1,1))\nfieldmap_rad1 = reg1.coef_[0]  # [rad / s]\nfieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\nt_predict1 = np.array([beg, end])\ny_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n\n# Unwrap with UMPIRE\nunwrapped_umpire = umpire_3echoes(wrapped, t)\n\n# Fit unwrapped data of UMPIRE\nreg2 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_umpire.reshape(-1,1))\n# Slope of linear regression reshaped into the shape of original 3D phase.\nfieldmap_rad2 = reg2.coef_[0]  # [rad / s]\nfieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\nt_predict2 = np.array([beg, end])\ny_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n\nt = np.array([0.003, 0.011, 0.020])\ny_unwrapped = np.array([1.0, 9.05, 17.75])\nwrapped = copy.deepcopy(y_unwrapped)\nwrapped[0] = np.angle(np.exp(1j*wrapped[0]))\nwrapped[1] = np.angle(np.exp(1j*wrapped[1]))\nwrapped[2] = np.angle(np.exp(1j*wrapped[2]))\nbeg = 0.0\nend = 0.021\n\nfig = go.Figure()\nnoises = np.arange(-0.5, 0.51, 0.01)\n# Add traces, one for each slider step\nfor noise in noises:\n    # Noisy unwrapped data\n    unwrapped_noisy = copy.deepcopy(y_unwrapped)\n    unwrapped_noisy[1] += noise\n    fig.add_trace(\n        go.Scatter(\n            visible=False,\n            mode='markers',\n            marker=dict(color='red'),\n            name=\"True Phase\",\n            x=t,\n            y=unwrapped_noisy))\n\n    # Fit of noisy unwrapped data\n    reg1 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_noisy.reshape(-1,1))\n    fieldmap_rad1 = reg1.coef_[0]  # [rad / s]\n    fieldmap_intercept1 = reg1.intercept_[0]  # [rad / s]\n    t_predict1 = np.array([beg, end])\n    y_predict1 = reg1.predict(t_predict1.reshape(-1,1))[:,0]\n    fig.add_trace(go.Scatter(visible=False, x=t_predict1, y=y_predict1, mode='lines', marker=dict(color='red'), name='True linear fit'))\n\n    # Noisy wrapped data\n    wrapped_noisy = copy.deepcopy(unwrapped_noisy)\n    wrapped_noisy[0] = np.angle(np.exp(1j*wrapped_noisy[0]))\n    wrapped_noisy[1] = np.angle(np.exp(1j*wrapped_noisy[1]))\n    wrapped_noisy[2] = np.angle(np.exp(1j*wrapped_noisy[2]))\n    fig.add_trace(\n        go.Scatter(\n            visible=False,\n            mode='markers',\n            marker=dict(color='blue'),\n            name=\"Wrapped Phase\",\n            x=t,\n            y=wrapped_noisy))\n\n    # UMPIRE\n    unwrapped_umpire = umpire_3echoes(wrapped_noisy, t)\n    fig.add_trace(\n        go.Scatter(\n            visible=False,\n            x=t, y=unwrapped_umpire, mode='markers', marker=dict(color='green'), name='Umpire'))\n\n    # Fit unwrapped data of UMPIRE\n    reg2 = LinearRegression().fit(t.reshape(-1, 1), unwrapped_umpire.reshape(-1,1))\n    # Slope of linear regression reshaped into the shape of original 3D phase.\n    fieldmap_rad2 = reg2.coef_[0]  # [rad / s]\n    fieldmap_intercept2 = reg2.intercept_[0]  # [rad / s]\n    t_predict2 = np.array([beg, end])\n    y_predict2 = reg2.predict(t_predict2.reshape(-1,1))[:,0]\n    \n    fig.add_trace(go.Scatter(visible=False, x=t_predict2, y=y_predict2, mode='lines', marker=dict(color='green'), name='Umpire fit'))\n    \nactive = len(noises)//2\nfig.data[active].visible = True\nfig.data[active+1].visible = True\nfig.data[active+2].visible = True\nfig.data[active+3].visible = True\nfig.data[active+4].visible = True\n\n# Static plot\nfig.add_trace(go.Scatter(x=[beg, end], y=[math.pi, math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.add_trace(go.Scatter(x=[beg, end], y=[-math.pi, -math.pi], mode='lines', line=dict(color='gray'), showlegend=False))\nfig.update_xaxes(title_text=\"Time (ms)\", range=[beg, end])\nfig.update_yaxes(title_text=\"Phase (rad)\", tickmode = 'array', range=[-4,25],\n                 tickvals = [-2*math.pi, 0, 2*math.pi, 4*math.pi, 6*math.pi],\n                 ticktext = [f'-2{PI_UNICODE}', '0', f'2{PI_UNICODE}', f'4{PI_UNICODE}', f'6{PI_UNICODE}'])\n\n# Create and add slider\nphase_offsets = [f\"{i:.2}\" for i in noises]\nsteps = []\nfor i in range(len(noises)):\n    step = dict(\n        method=\"update\",\n        label=phase_offsets[i],\n        args=[{\"visible\": [False] * 5*len(noises) + [True] * (len(fig.data) - 5*len(noises))}],  # layout attribute\n    )\n    step[\"args\"][0][\"visible\"][5*i] = True\n    step[\"args\"][0][\"visible\"][5*i + 1] = True\n    step[\"args\"][0][\"visible\"][5*i + 2] = True\n    step[\"args\"][0][\"visible\"][5*i + 3] = True\n    step[\"args\"][0][\"visible\"][5*i + 4] = True\n    steps.append(step)\n\nsliders = [dict(\n    active=active,\n    currentvalue={\"prefix\": \"2nd echo phase offset (rad): \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nfig.update_layout({\"width\": 800},\n                 sliders=sliders,\n                 title_text=\"Effect of noise using UMPIRE phase unwrapping\", title_x=0.5)\n\nfig.show()","type":"content","url":"/figure-5-4-4","position":1},{"hierarchy":{"lvl1":"B0 Mapping"},"type":"lvl1","url":"/b0-mapping","position":0},{"hierarchy":{"lvl1":"B0 Mapping"},"content":"","type":"content","url":"/b0-mapping","position":1},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"B0 inhomogeneities"},"type":"lvl2","url":"/b0-mapping#b0inhomointro","position":2},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"B0 inhomogeneities"},"content":"The main magnetic field, also called the B0 field, plays a crucial role in MRI. It dictates the precessional frequency of the spins and sets-up the bulk magnetization, which plays an important role in the image signal-to-noise ratio. Moreover, the radio frequency coils, tuned to the B0 field, are responsible for flipping the spins in the transverse plane and for acquiring the signal. However, imaging reconstruction techniques assume a perfectly homogeneous B0 field to reconstruct the signal from k-space data. An inhomogeneous B0 field can lead to image artifacts such as signal loss, distortions \n\nJezzard & Balaban, 1995, poor fat saturation \n\nAnzai et al., 1992 and many other image artifacts. In extreme cases, it can completely hinder the ability to create an image. B0 inhomogeneities are also problematic for MR spectroscopy (MRS), because they widen the spectral linewidth.\n\nWhen a subject is introduced in the scanner, the static B0 field can be rendered more homogeneous through a technique called active shimming. Active shimming sends the appropriate amount of current through specific gradient and shim coils, in order to generate a magnetic field that will compensate for the existing (inhomogeneous) magnetic field. This procedure requires precise and accurate mapping of the B0 field. B0 maps show the difference between the current field and the expected field, and are typically displayed in units of magnetic field strength (Tesla [T]), precessional frequency (Hertz [Hz]) or in parts per million (ppm). \n\nEq. 5.1 can be used to convert from the different units.\\frac{f-f_{0}}{f_{0}}\\ast10^{6}=\\frac{\\Delta f}{f_{0}}\\ast10^{6}=\\frac{B-B_{0}}{B_{0}}\\ast10^{6}=\\frac{\\Delta B}{B_{0}}\\ast10^{6}=\\delta_{ppm}\n\nwhere f, f_{0} and \\Delta f represent the actual precessional frequency, the \n\nLarmor frequency and the difference between current and the \n\nLarmor frequency (f-f_{0}=\\Delta f) respectively. B, B{sub}0 and Œî B all have similar interpretations as f, f_{0} and \\Delta f but are in units of field strength (T). The relationship between frequency and field strength can be found using the well known \n\nLarmor equation (f=\\gamma B / 2\\pi). \\delta_{ppm} is the field offset in ppm.\n\nFigure 5.1 shows typical brain magnitude, phase, and B0 field map images of a brain in a 3 T scanner.\n\n\n\nFigure¬†5.1:Magnitude image of the reconstructed MRI signal acquired at 3 T (A), the phase in radians (B), and a computed field map in Hz (C), ùúáT (D) and ppm (E). The dropdown can be used to select between the different images.","type":"content","url":"/b0-mapping#b0inhomointro","position":3},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Sources","lvl2":"B0 inhomogeneities"},"type":"lvl3","url":"/b0-mapping#sources","position":4},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Sources","lvl2":"B0 inhomogeneities"},"content":"","type":"content","url":"/b0-mapping#sources","position":5},{"hierarchy":{"lvl1":"B0 Mapping","lvl4":"Hardware","lvl3":"Sources","lvl2":"B0 inhomogeneities"},"type":"lvl4","url":"/b0-mapping#hardware","position":6},{"hierarchy":{"lvl1":"B0 Mapping","lvl4":"Hardware","lvl3":"Sources","lvl2":"B0 inhomogeneities"},"content":"Although scanner manufacturers try to make magnets that are as homogeneous as possible, they are far from perfect. The manufacturing process requires many kilometers of superconducting wire to be wound to create the main magnet and can lead to inhomogeneities due to manufacturing tolerances. Moreover, large metal objects near the scanner can interact with the field created by the scanner and impact the resulting field within the scanner. This is a more important problem with higher field strength. During the installation process, the empty bore is homogenized in a process called passive shimming. During this process, small ferromagnetic pieces are introduced in the scanner at optimized locations to produce a field that counteracts the inhomogeneities. Hardware inhomogeneities are relatively small (less than 1 ppm \n\nWebb, 2016).\n\nSpecialized equipment such as field probes \n\nDietrich et al., 2016 (e.g.: Skope Magnetic Resonance Technologies, LLC) can be used to evaluate the B0 field of the scanner while it is being installed. This equipment can also be used after installation because it is more precise than B0 field maps and offers better field temporal resolution, allowing the ability to observe \n\neddy currents created from gradient switching.\n\nDuring an imaging session, heating of the different components and of the main magnet can lead to temperature-dependent changes in the B0 field. These can be observed by a frequency drift in the field. As an example, a ~0.4Hz/min has been observed in MRS at 3T but depends on multiple factors \n\nAcademic Press, 2021. Modern scanners usually have systems in place to evaluate and correct for this drift \n\nEl-Sharkawy et al., 2006.","type":"content","url":"/b0-mapping#hardware","position":7},{"hierarchy":{"lvl1":"B0 Mapping","lvl4":"Magnetic susceptibility","lvl3":"Sources","lvl2":"B0 inhomogeneities"},"type":"lvl4","url":"/b0-mapping#magnetic-susceptibility","position":8},{"hierarchy":{"lvl1":"B0 Mapping","lvl4":"Magnetic susceptibility","lvl3":"Sources","lvl2":"B0 inhomogeneities"},"content":"Materials have a property called magnetic susceptibility () that reflects their ability to become magnetized in response to an external magnetic field \n\nSchenck, 1996. The change in magnetic field Bz (the subscript ‚Äúz‚Äù is shown to make it explicit that we are referring to the component parallel to the B0 field) is proportional to the magnetic susceptibility value, the magnetic field strength, and can be affected by the geometry and location of the tissues. It can be modeled as a convolution of the difference in magnetic susceptibility  with the component parallel to the magnetic field induced by a unit magnetic dipole (d=\\frac{\\left( 3\\text{cos}^{2}\\left( \\theta \\right)-1 \\right)}{4\\pi\\left| \\textbf{r} \\right|^{3}}) in spherical coordinates where  \\textbf{r}  is the position vector and  is the angle with B0 \n\nRochefort et al., 2008.\\Delta B_{z}\\left( \\textbf{r} \\right)=B_{0}\\left( \\Delta\\chi \\left( \\textbf{r} \\right) \\otimes  d \\left( \\textbf{r} \\right)\\right)\n\nThe dipole kernel (d) is illustrated in \n\nFigure 5.2 along with the dipole kernel (D) in the k-space domain often used in QSM.\n\n\n\nFigure¬†5.2:Dipole kernel (d) in the image domain as well as in the k-space domain (D).\n\nWhen a subject is introduced in the scanner, it interacts with the B0 field and distorts it. Therefore, a perfectly homogeneous field in an empty bore will usually have an inhomogeneous B0 field once a patient is introduced. This is the reason why active shimming is required when a patient is introduced in the scanner. Although these inhomogeneities happen everywhere in the body, stronger field variations occur at the boundaries of strong susceptibility differences such as air (slightly paramagnetic: +\\chi) and water/tissue (diamagnetic: -\\chi).\n\nThe following figure shows different susceptibility distributions in ppm for a homogeneous cylinder within a larger homogeneous cylinder placed in a homogeneous background (top) and a brain (bottom). The corresponding B0 field maps are simulated at 7 T and shown in \n\nFigure 5.3. In the brain, the B0 field inhomogeneities are dominated by air-tissue boundaries. On the right-hand panel, the slow varying spatial variations (also called background field) were removed to show the local field variations.\n\n\n\n\n\nFigure¬†5.3:Cylinder (top) and brain (bottom) of susceptibility distributions (left), simulated B0 field map (middle) and the B0 field map with the background field removed (right). An in-vivo susceptibility map was used for the brain and was surrounded with air. Note that this simplistic representation still shows the field map being dominated by air-tissue interfaces even though the spatial characteristics of the field are not perfectly representative of reality. An in-vivo field map can be seen in \n\nFigure 5.9.","type":"content","url":"/b0-mapping#magnetic-susceptibility","position":9},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Effects on signal","lvl2":"B0 inhomogeneities"},"type":"lvl3","url":"/b0-mapping#effects-on-signal","position":10},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Effects on signal","lvl2":"B0 inhomogeneities"},"content":"To excite the spins in the transverse plane, a carrier frequency tuned to the \n\nLarmor frequency is used by the transmit coil. If the frequency of the spins does not match the excitation frequency, it results in a suboptimal tip of the spins in the transverse plane. If the frequency of the spins varies across the ROI, the flip angle is affected differently across the image \n\nWang et al., 2006.\n\nWhen a signal is acquired, it is demodulated to remove the carrier frequency (\n\nLarmor frequency) from the signal. An example of a FID is shown in \n\nFigure 5.4. The number of species represent the number of isochromats in the simulation. An isochromat represents an ensemble of spins with the same properties rotating at the same \n\nLarmor frequency. For a single isochromat, if the acquired signal and demodulation frequency perfectly match, the T2 signal can be recovered. If the carrier frequency is different from the expected frequency (such as when there are inhomogeneities), the demodulation introduces low-frequency variations. A non-homogeneous sample is also shown featuring many isochromats. Alternatively, a homogeneous sample with a non-homogeneous B0 field could be simulated as well and would have a similar shape as the one with multiple species. In that case, the difference from the T2 curve would reflect T2* (1/T_{2}^{*}=1/T_{2}+1/T_{2}^{'}) effects. During the relaxation process, spins precessing at different frequencies, due to the presence  of B0 inhomogeneities, will give rise to phase offsets between the spins within a voxel. This intravoxel phase dispersion leads to signal decay.\n\n\n\nFigure¬†5.4:FID curves with signal demodulation at \n\nLarmor frequency (single species), at two different frequencies (\n\nLarmor and offset frequency, two species) and at multiple frequencies (\n\nLarmor frequency and many other offset frequencies, multiple species). The resulting shape of the graphs depends on the relative amplitudes and frequencies.\n\nB0 inhomogeneities can lead to distorted k-space trajectories during the readout gradient. This effect is worse during further k-space traversal due to the compounding of the errors. When inhomogeneities are present, the frequencies of the spins are altered. The one-to-one relationship between frequency and spatial location (required to obtain accurate spatial correspondence) is broken. This leads to geometric distortions. \n\nFigure 5.5 shows an animation of the filing of k-space of an EPI sequence using bi-polar readouts. A theoretical trajectory is shown as well as a trajectory where a constant parasite gradient in the phase encoding direction has been added. One can observe the trajectory differences.\n\n\n\nFigure¬†5.5:K-space trajectory of an EPI sequence using bi-polar readout gradients (blue). A constant gradient in the positive phase encoding direction is applied to simulate inhomogeneities (red). The trajectory with the parasite gradient deviates from the theoretical trajectory. All encoding gradients (G) are instantaneously applied at 40 mT/m. A parasit Gp,phase of 0.1mT/m (G/Gp,phase=0.25%) is added to simulate inhomogeneities. 64 encoding steps are used in both the frequency and phase encoding directions but only one in five phase encoding lines is shown for visualization purposes.\n\nRadiofrequency (RF) pulses can also be affected by an inhomogeneous B0 field. During slice selection for example, the RF pulse excites a range of frequencies that can be mapped to spatial locations by applying a linearly evolving magnetic field along the slice direction. For a perfectly transverse acquisition, the resulting B0 field can be expressed by (G_{z}z+ B_{0}). If B0 inhomogeneities are present (G_{z}z+ B_{0} +\\Delta B_{0} (x,y,z)), the excited slice profile can be distorted or offset from the expected location. When B0 inhomogeneities are very inhomogeneous, they can also disrupt frequency-selective RF pulses such as fat saturation pulses. There are also other effects such as ringing artifacts, blurring, and ghosting that can occur.\n\nAll of these effects can be minimized with B0 shimming. To do so, a map of the B0 field can be acquired. In addition to shimming, B0 mapping is important for other techniques that will be discussed later. The next section will show how to perform B0 mapping using two echoes.","type":"content","url":"/b0-mapping#effects-on-signal","position":11},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Dual echo B0 mapping"},"type":"lvl2","url":"/b0-mapping#b0dualecho","position":12},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Dual echo B0 mapping"},"content":"B0 mapping estimates the B0 field from the expected field for every voxel. These B0 maps can be used to perform prospective B0 shimming to minimize B0 inhomogeneities \n\nJezzard & Balaban, 1995, they can be used to retrospectively correct for geometric distortions (FSL FUGUE \n\nJenkinson et al., 2012\n\nSmith et al., 2004) (e.g.: for EPI), or to perform retrospective correction for k-space readout trajectory (e.g.: for spiral readout). Moreover, they can be used for retrospective recovery of enhanced signal decay \n\nAn & Lin, 2002\n\nAlonso-Ortiz et al., 2017, for T2* mapping and they are also vital to quantitative susceptibility mapping (QSM) where the goal is to map the susceptibility of the subject.\n\nOne of the most simple and widely adopted techniques used to perform B0 mapping is the 2-echo phase difference technique. This technique is faster and simpler than most other alternatives. Before we dive into the technique, let‚Äôs dip our toes in some theory.","type":"content","url":"/b0-mapping#b0dualecho","position":13},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Signal Theory","lvl2":"Dual echo B0 mapping"},"type":"lvl3","url":"/b0-mapping#signal-theory","position":14},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Signal Theory","lvl2":"Dual echo B0 mapping"},"content":"In the ideal case, spins rotate at the \n\nLarmor frequency, shown in blue in \n\nFigure 5.6. In the presence of field inhomogeneities, the frequency of the spins (shown in red) is different and is proportional to the field inhomogeneities. Both the laboratory and rotating frame of reference are shown. Importantly, note that the \n\nLarmor frequency phase appears stationary in the rotating frame of reference.\n\n\n\nFigure¬†5.6:Two spins rotating (one at the Larmor frequency (f_{0}), one at a lower frequency). A view of the spins in the transverse plane (left) and of their phase (right) is shown. A dropdown is available to select between the laboratory frame and the rotating frame of reference.\n\nThe phase (œï) evolution follows the following equation (not considering transient effects such as \n\neddy currents) in the rotating frame of reference.\\phi\\left(\\textbf{r},t \\right) = \\phi_{0}\\left( \\textbf{r} \\right)+\\gamma\\Delta B_{0}\\left( \\textbf{r} \\right)\\cdot t\n\nwhere x,y,z are the coordinate locations, t is time,  is the gyromagnetic ratio, B0 is the B0 field offset (Tesla) and \\phi_{0} is an initial constant phase offset (e.g.: coil induced, material induced through local conductivity/permittivity). We can observe phase evolution through time in \n\nFigure 5.7 by looking at phase data acquired in the brain at progressively longer echo times. The phase at a single voxel changes linearly (not considering transient effects). Note that the sharp variations forming vertical lines in the previous figure are called phase wraps and occur because the phase is defined over - to . Phase-wrapping effects will be discussed in more detail in the following section. Wraps can also occur spatially as sharp variations as seen in the following figure. Note that the longer the echo times, the more wraps there are.\n\n\n\nFigure¬†5.7:Phase shown at different echo times. The slider can be used to show the phase that would be acquired at different echo times.\n\nMRI manufacturers do not all output phase data by default. It should be possible to toggle the output of phase data on all MRI systems. It can also be computed from real/imaginary data using \n\nEq. 5.4.\\angle \\left( \\text{real}+i\\text{ imaginary} \\right) =\\text{arctan2}\\left( \\text{imaginary, real} \\right)\n\nwhere \\angle is the phase operator.\n\nAs phase changes linearly with time (t) and with the field offset (B0), it is possible to acquire two phase images at two different echo times and compute B0(x,y,z).\\Delta B_{0}\\left( \\textbf{r} \\right)=\\frac{\\phi\\left( \\textbf{r}, \\text{TE}_{2} \\right)-\\phi\\left( \\textbf{r}, \\text{TE}_{1} \\right)}{\\gamma\\cdot \\left( \\text{TE}_{2}-\\text{TE}_{1}  \\right)}=\\frac{\\Delta\\phi\\left( \\textbf{r}\\text{,}\\Delta \\text{TE}\\right)}{\\gamma\\Delta\\text{TE}}\n\nwhere TE1 and TE2 are the echo times, and  ŒîTE = TE2- TE1. To compute the phase offset \\Delta \\phi, phase subtraction is necessary. The complex difference can be used to keep the phase between -\\pi to +\\pi, although other phase difference techniques are also possible.\\Delta\\phi\\left( \\textbf{r},\\Delta\\text{TE} \\right)=\\angle \\left( \\text{e}^{i\\phi\\left( \\textbf{r}\\text{,TE}_{2} \\right)} \\right)\\cdot \\left( \\text{e}^{-i\\phi\\left( \\textbf{r}\\text{,TE}_{1} \\right)} \\right)\n\nIn some sequences, the phase images are exported as a single phase difference image \\Delta \\phi \\left( x,y,z, \\Delta \\text{TE} \\right).","type":"content","url":"/b0-mapping#signal-theory","position":15},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Single Frequency Population","lvl2":"Dual echo B0 mapping"},"type":"lvl3","url":"/b0-mapping#single-frequency-population","position":16},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Single Frequency Population","lvl2":"Dual echo B0 mapping"},"content":"To build intuition about field maps, let us imagine a sample at a constant offset frequency from f_{0} . Note that this simplistic representation of the field typically does not occur due to how the susceptibilities of the neighboring regions interact with one another to create the B0 field offset (see the \n\nB0 inhomogeneity section, but is shown as such for learning purposes. The sample is shown as a circle in \n\nFigure 5.8. As the frequency is not at the \n\nLarmor frequency, phase accumulation is observed at the different echo times and a phase difference map can be computed. The B0 field map is then calculated using the echo times. Note that if ŒîTE is too long, the phase could make more than a half revolution between the two echo times resulting in an erroneous B0 field estimation. This is because phase is defined over -\\pi to +\\pi and the sampled points should respect the \n\nNyquist criteria. In practice, this example field (constant offset) could easily be corrected by adjusting the transmit and receive frequency of the scanner.\n\n\n\n\n\nFigure¬†5.8:Different images of a homogeneous cylinder field offset showing a simulated phase at two echo times, the calculated phase difference image and the computed B0 field map.","type":"content","url":"/b0-mapping#single-frequency-population","position":17},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Multi Frequency Population","lvl2":"Dual echo B0 mapping"},"type":"lvl3","url":"/b0-mapping#multi-frequency-population","position":18},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Multi Frequency Population","lvl2":"Dual echo B0 mapping"},"content":"A brain dataset is used to show a concrete example of a field map that could be acquired in practice. \n\nFigure 5.9 shows two phase images where phase accumulation is shown due to frequency offsets that vary spatially. As mentioned previously, phase wraps are visible where phase transitions from  -\\pi to +\\pi and will be discussed in more detail in the next chapter. The phase difference and B0 field maps are also shown. Note that taking the phase difference eliminates the wraps in this example, however, there could be residual wraps when the field is more inhomogeneous.\n\n\n\n\n\nFigure¬†5.9:Two phase images, a phase difference and a B0 field map. Phase wraps are visible where the phase transitions from  -\\pi to +\\pi.","type":"content","url":"/b0-mapping#multi-frequency-population","position":19},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Dual echo B0 mapping"},"type":"lvl3","url":"/b0-mapping#b0dualechobenpit","position":20},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Benefits and Pitfalls","lvl2":"Dual echo B0 mapping"},"content":"When acquiring a field mapping sequence, many parameters will affect the resulting images. A minimum of two phase images is required to compute B0 field maps, as the initial phase \\phi_{0}\\left( x,y,z \\right) is generally not known and non-zero. Multi-echo field mapping with more than two echoes will be discussed in the the advanced \n\nB0 mapping section.\n\nThese phase maps can be acquired by many sequences. The general principle includes the use of sequences that cause accumulation of phase. This can be done using GRE sequences or using spin-echo sequences with asymmetric echoes (e.g.: first echo at the spin echo and second echo shifted by 1-2 ms to create an accumulation of phase caused by B0 inhomogeneities). The sequence parameters are chosen such that the data does not suffer much from distortions and other artifacts caused by B0 inhomogeneities. High bandwidth, thin slices and multi-shot sequences are therefore preferred \n\nAkcakaya et al., 2022. This means EPI sequences are generally not used for field mapping because of their sensitivity to B0 inhomogeneities.\n\nWhen acquiring multiple echoes, the readout direction of the even echoes can be chosen to either be in the same direction (monopolar) as the odd echoes or in opposite directions (bipolar). Using opposite directions can slightly reduce TE, but doing so can cause a slight misregistration between the even and odd echoes and we therefore recommend using readouts in the same direction.\n\nThe standard deviation of the phase (\\sigma_{phase}) is inversely proportional to the SNR of the magnitude image (SNRmag) \n\nBrown et al., 2014.\\sigma_{phase}=\\frac{1}{\\text{SNR}_{mag}}\n\nA high SNR image will therefore provide a more reliable phase image. With this in mind, the main parameters to choose are the echo times. The first echo time is usually chosen to be quite fast to maximize SNR and minimize phase wraps. The choice of the second echo time is then chosen according to many factors. i) Fat has ~3.35 ppm frequency offset from water. This can cause errors in the fieldmap measurement, where a chemical shift is mistaken for a field shift near and within fatty tissues. ŒîTE can be chosen so that fat and water are in phase and reduce this problem (~2.34ms at 3T). Note that different fat components have different chemical shifts. These values are given as first estimates. ii) Longer ŒîTE maximizes the difference between the phase measurements and can provide a better estimate if SNR is still sufficient. iii) Shorter ŒîTE minimizes the number of wraps and therefore reduces errors due to unwrapping. If the field offset is known, a maximum ŒîTE can be calculated to yield no phase wrapping.\n\nAs echoes are usually acquired in rapid successions to avoid phase wrapping, rapid gradient switching is required which leads to \n\neddy currents that can impact the acquired phase data. To mitigate the issue, a single echo per RF pulse can be acquired. A dual-echo sequence would have twice the number of RF pulses (alternating between acquiring both echoes) but allows slower gradient switching and removes \n\neddy currents effects from the gradient work of the first echo on the second echo. However, this technique requires longer scan time.\n\nAs seen in this section, phase wrapping can be an issue, as phase is defined over 2\\pi. The next section deals with this problem.","type":"content","url":"/b0-mapping#b0dualechobenpit","position":21},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Phase Unwrapping"},"type":"lvl2","url":"/b0-mapping#phaseunwrapintro","position":22},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Phase Unwrapping"},"content":"Phase unwrapping stems from the fact that phase can only be measured over the range of -\\pi to +\\pi. If the measured phase crosses from -\\pi to +\\pi, a ‚Äúwrap‚Äù is observed as a 2\\pi jump where in reality, the phase was smoothly varying. In the context of MRI, phase wrapping occurs when measuring phase data that varies by more than 2\\pi  within the region of interest. In reality, the number of rotations that a spin can have done is not limited to a single revolution. To accurately recover the true phase information, unwrapping is necessary.\n\nThere are two main families of unwrapping techniques. Temporal unwrapping techniques use temporal information from different phase time points and the assumption that the difference between time points is smoothly varying (offset less than ) to correct for phase jumps that can occur in time. Spatial unwrapping uses spatial information and relies on the fact that neighboring voxels should be smoothly varying to identify and correct for 2\\pi  jumps.","type":"content","url":"/b0-mapping#phaseunwrapintro","position":23},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Temporal Unwrapping","lvl2":"Phase Unwrapping"},"type":"lvl3","url":"/b0-mapping#temporal-unwrapping","position":24},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Temporal Unwrapping","lvl2":"Phase Unwrapping"},"content":"Temporal unwrapping uses multiple time points (>=2) to unwrap the image. By acquiring phase data that vary by at most -\\pi to +\\pi, the difference between 2 echoes (using complex difference) yields an unwrapped image free of wraps. Eq. 1 describes the field offset (\\Delta f_{0}) experienced during ŒîTE in the presence of field inhomogeneities.\\Delta f_{0}\\left( \\textbf{r} \\right)=\\frac{\\gamma}{2\\pi}\\Delta B_{0}\\left( \\textbf{r}\\text{,}\\Delta \\text{TE} \\right)=\\frac{1}{2\\pi}\\frac{\\Delta\\phi\\left( \\textbf{r}\\text{,}\\Delta \\text{TE} \\right)}{\\Delta \\text{TE} }\n\nIf we assume a maximum field offset \\Delta f_{0,max} of 1 ppm at 3T (~127 MHz), we can calculate a maximum field offset (\\Delta f_{0,max}) of 1 ¬µT or 127 Hz. The \n\nNyquist criteria can be used to calculate the maximum echo time difference (TE) required to satisfy the no-wrapping requirement in the phase difference image (\\Delta \\text{TE} = \\left( \\Delta f_{0,max} \\right)^{-1}). \n\nTable¬†5.1 shows TE for multiple field strength assuming inhomogeneities of 1 ppm. As shown, the echo spacing is B0 dependent, as higher field offsets are observed at higher field strengths.\n\nTable¬†5.1:Maximum echo time required to respect the Nyquist criteria for different field strengths for ŒîB0 of 1 ppm.\n\nB0 (T)\n\ndeltaTE (ms)\n\n0.064\n\n183.39\n\n0.1\n\n117.37\n\n0.3\n\n39.12\n\n1.5\n\n7.82\n\n3\n\n3.91\n\n7\n\n1.68\n\nIf a longer TE is selected, or if the inhomogeneities are bigger than originally anticipated in some parts of the image, the phase difference image could also have wraps, and spatial unwrapping would be necessary.\n\nTemporal unwrapping can also be performed without phase difference. \n\nFigure 5.10 shows the phase of a voxel acquired at four echo times in blue. Note that the last echo time is wrapped (i.e.: the phase rotated by more than 2\\pi and ‚Äúwrapped‚Äù to the positive side). With the assumption that phase does not vary by more than 2\\pi, we can unwrap the phase by, in this case, subtracting 2\\pi from the acquired phase to recover the true phase (in red). A linear fit is shown in green. Note that the slope would represent the field map value.\n\n\n\nFigure¬†5.10:Four phase voxels acquired at different echo times (blue). The phase is unwrapped temporally and plotted, which in this case changes the phase of the 4th echo (red). A linear fit is also shown (green).","type":"content","url":"/b0-mapping#temporal-unwrapping","position":25},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Spatial Unwrapping","lvl2":"Phase Unwrapping"},"type":"lvl3","url":"/b0-mapping#spatial-unwrapping","position":26},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Spatial Unwrapping","lvl2":"Phase Unwrapping"},"content":"Spatial unwrapping uses the spatial characteristics of images to unwrap the data. The wrapped image should vary smoothly. Spatial unwrapping typically uses a  region-growing algorithm which identifies and rectifies where there are offsets greater than 2\\pi. An example of a 1D signal of a linearly evolving phase is shown in \n\nFigure 5.11 to illustrate the phase that we would want to recover from the wrapped phase that would be acquired through space.\n\n\n\nFigure¬†5.11:1D example of a wrapped phase (blue) with the true phase (red)\n\nA more complex example is shown in \n\nFigure 5.12 where phase varies spatially in a non-linear fashion. When the signal is unwrapped, different solutions are expected. These solutions vary by 2n\\pi. Its cause and potential remedy are described in the following section.\n\n\n\nFigure¬†5.12:A more complex example of a signal wrapped and unwrapped. Note that three possibilities are possible when unwrapping, depending on which part of the signal is selected to be the true phase. The slider can be moved left to right to show the wrapped and unwrapped data.\n\nA common issue with spatial unwrapping which stems from region growing algorithms is that the region of interest needs to be defined in a single region, or there can be a 2n\\pi offset between regions. Moreover, region growing algorithms usually require thresholding so that noise is not unwrapped.\n\nA 2D example of wrapped and unwrapped simulated data is shown in \n\nFigure 5.13. The concept can be expanded to 3D data as well. Note that more wraps result in higher field inhomogeneity.\n\n\n\nFigure¬†5.13:2D wrapped and unwrapped simulated data.","type":"content","url":"/b0-mapping#spatial-unwrapping","position":27},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Phase unwrapping ambiguity","lvl2":"Phase Unwrapping"},"type":"lvl3","url":"/b0-mapping#phase-unwrapping-ambiguity","position":28},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Phase unwrapping ambiguity","lvl2":"Phase Unwrapping"},"content":"There is ambiguity to unwrapping and a choice needs to be made regarding the true signal (see \n\nFigure 5.12). If the wrong one is selected, this creates a 2n\\pi offset from the true phase. When unwrapping a single phase volume, an educated guess can be made by calculating the average phase in the ROI and expect that to be close to 0 (we assume here that a good frequency shim was first performed in the ROI). n is chosen and the 2n\\pi offset is removed from the unwrapped phase map such that the average phase in the ROI is close to 0. Note that this is not a perfectly robust solution because phase is also affected by other factors such as the receive coil, RF pulse and \n\neddy currents which could cause the average phase offset to deviate from 0. Fortunately, phase difference images are more reliably unwrapped since some of the phase offsets are constant in both phase images and are removed  when performing the phase difference resulting in a phase offset closer to 0.\n\nIf multiple echoes are acquired, a combination of spatial and temporal unwrapping may be necessary. Multi-echo field mapping is discussed in the following section. Note that with appropriate selections of the echo times, the 2n\\pi offset ambiguity can be remedied.","type":"content","url":"/b0-mapping#phase-unwrapping-ambiguity","position":29},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Problematic phase map properties","lvl2":"Phase Unwrapping"},"type":"lvl3","url":"/b0-mapping#problematic-phase-map-properties","position":30},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Problematic phase map properties","lvl2":"Phase Unwrapping"},"content":"Phase maps sometimes have wraps that are not possible to unwrap with traditional phase unwrapping techniques. One example is shown in \n\nFigure 5.14. Phase singularities, also called poles or open ended fringe lines, hinder the abilities of unwrappers to get an accurate unwrapped phase. As can be seen in the following figure, there are two points where the phase is ambiguous. When unwrapping spatially, if two points are selected arbitrarily in the ROI, one would expect that all possible paths linking both points to cross the same number of wraps. Otherwise, crossing a different number of wraps results in ambiguous phase values. Counting wraps can be done by counting the sharp phase transitions where -\\pi to +\\pi (black to white) results in +1 wrap and +\\pi to -\\pi (white to black) results -1 wrap. However, phase singularities create paths that have a different number of wrap crossings, resulting in ambiguous phase values. \n\nFigure 5.14 is used as an example to illustrate the above statements. When unwrapping from point A to B, the left path crosses no wraps and would therefore expect the phase to go from 3/4\\pi to -3/4\\pi, however, the right path crosses a wrap and would therefore expect to go from 3/4\\pi to -3/4\\pi+2\\pi. This is problematic as the phase becomes ambiguous. Phase singularities are usually a result of a poor coil combination process. There are some techniques to mitigate the issue, but the main solution is to correctly combine the coil maps to avoid the singularities altogether.\n\n\n\nFigure¬†5.14:Synthetic phase data showing two phase singularities. The red paths show two different paths a region growing algorithm could use to go from point A to point B. The left path does not cross a phase wrap whereas the right path crosses a phase wrap. This yields an ambiguous phase result.","type":"content","url":"/b0-mapping#problematic-phase-map-properties","position":31},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Software","lvl2":"Phase Unwrapping"},"type":"lvl3","url":"/b0-mapping#software","position":32},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Software","lvl2":"Phase Unwrapping"},"content":"Laplacian unwrapping can be very robust even with highly wrapped images but does so at the expense of accuracy. It typically unwraps with an error of low spatial variability. This can be a perfectly reasonable unwrapping technique for some applications such as QSM where the background field (low spatial variability) is subsequently removed. However, in applications such as shimming or qMRI where the accuracy is important, Laplacian unwrapping is not recommended.\n\nOther unwrapping algorithms and softwares are listed below.\n\nPRELUDE: Spatial unwrapping technique using region growing algorithm \n\nJenkinson, 2003.\nSEGUE: Spatial unwrapping technique based on similar principles to Prelude with optimizations to improve the speed \n\nKarsa & Shmueli, 2019.\nBEST PATH: 3D unwrapping algorithm using spatial information to assess the quality of the phase data and unwrap high quality regions first. \n\nAbdul-Rahman et al., 2007\nROMEO: Unwrapping technique using temporal and spatial information to guide the path of unwrapping \n\nDymerska et al., 2021.\nUMPIRE:Temporal unwrapping technique using unevenly spaced echoes to accurately unwrap phase images. This technique requires three or more echoes \n\nRobinson et al., 2014.","type":"content","url":"/b0-mapping#software","position":33},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Advanced B0 Mapping Methods"},"type":"lvl2","url":"/b0-mapping#advanced-b0-mapping-methods","position":34},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Advanced B0 Mapping Methods"},"content":"Although dual-echo field mapping can be used for many applications, more advanced B0 mapping techniques are available depending on the use-case. Multi-echo field mapping, which makes use of more echoes, can be used to increase the accuracy of the computed field map. This can be useful for qMRI, shimming, or QSM, where the goal is to gather field information to map the susceptibility of the tissues. QSM is sensitive to small local variations, therefore a more accurate approach can be beneficial. This section also discusses fast B0 field mapping in the context of capturing B0 variations due to air differences generated by breathing. B0 maps can be affected by \n\neddy currents and \n\na section is dedicated to their reduction.","type":"content","url":"/b0-mapping#advanced-b0-mapping-methods","position":35},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Multi-echo B0 mapping","lvl2":"Advanced B0 Mapping Methods"},"type":"lvl3","url":"/b0-mapping#b0multiecho","position":36},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Multi-echo B0 mapping","lvl2":"Advanced B0 Mapping Methods"},"content":"Multi-echo field mapping (three or more echoes) makes use of more echo times than the dual-echo standard field map. With more time points, the field maps can be expected to be more accurate. All \n\nbenefits and pitfalls of dual echo B0 mapping apply in multi-echo field mapping, with the added criteria that the later echoes should have enough signal to provide a benefit to the technique. As seen in the \n\ndual echo B0 mapping section, the phase generally evolves linearly with respect to time. Another way to look at B0 field mapping is realizing that we are looking for how much the phase changes per unit time (i.e.: the slope).\\phi\\left( \\textbf{r}\\text{,}t \\right)=\\phi_{0}\\left( \\textbf{r}\\right)+\\gamma \\Delta B_{0}\\left( \\textbf{r} \\right)\\cdot t\n\nThere are many ways to perform multi-echo field mapping. The most straightforward way (after dual-echo) is to spatially unwrap the phase of all the echo times, then temporally unwrap the resulting data to remove any 2n\\pi offsets between time points that could arise from spatial unwrapping. A linear fit can then be done to retrieve the field map. This technique requires the echo times between time points to be reasonably short so that temporal unwrapping can accurately unwrap the data (\\Delta \\phi < \\pi ). \n\nFigure 5.15 shows two solutions that can be obtained from this processing (note the exact 2\\pi difference at each timepoint). The difference could be explained from the choice of seed voxel used for unwrapping spatially. However, as the slope (change in phase over time) is the same for both solutions, an accurate field map can still be recovered even if the underlying phase maps have a 2n\\pi offset. This is another advantage over phase difference algorithms.\n\n\n\nFigure¬†5.15:Two different unwrapped solutions from unwrapping phase data of three echoes. A 2 offset is observed between both solutions.\n\nAnother way to perform multi-echo field mapping is to have two echoes that are relatively close to avoid temporal phase wrapping and a later echo with sufficient SNR. The first two echoes can be treated as a dual-echo and the resulting field map can help temporally unwrap the 3rd echo. This 3rd echo can be used to get a better fit. This is shown in \n\nFigure 5.16.\n\n\n\nFigure¬†5.16:Three-echo acquisition, where the first two echoes respect the \n\nNyquist criteria and can be temporally unwrapped accurately, while the third echo has a much longer echo time. The first two echoes can be used to predict the number of wraps of the third echo. With all three echoes accurately unwrapped, a fit with three echoes can be computed.\n\nAs mentioned in the \n\nphase unwrapping section, the standard deviation of the phase is inversely proportional to the SNR of the magnitude image of the field mapping acquisition. This means that longer echo times can have a detrimental impact on the field map if it is not accounted for. One way to address the issue is to weigh the contribution of the echoes by the SNR of the magnitude images.\n\nMore complex algorithms such as UMPIRE [24] exploit echo timings to only rely on temporal unwrapping to unwrap the phase images. A minimum of three echoes is necessary for this algorithm. With three echoes, the two echo time differences (ŒîTE1=TE2-TE1, ŒîTE2=TE3-TE2) are chosen to be slightly different. Doing this allows us to calculate the accrued phase during TE2-TE1= Œ¥TE which is chosen to be small and is therefore free of wraps. Using this, the wraps in the different echoes can be estimated and removed yielding unwrapped phase images which can be fit to calculate the field map. An advantage of the technique is that it allows us to select echo times that would normally be too long, as ŒîTEx can be larger than œÄ. An important prerequisite of this algorithm is that the phase offset occurring during Œ¥TE should be less than  but greater than zero, such that a good estimate of the phase can still be calculated. \n\nFigure 5.17 shows an example of a single voxel being unwrapped using UMPIRE. As previously stated, the slope of the linear fit is proportional to the resulting field map. The traces can be toggled on and off by clicking the legend.\n\n\n\nFigure¬†5.17:Three echo data unwrapped using the UMPIRE algorithm. Note that UMPIRE is able to unwrap phase data that varies by more than œÄ. The different traces can be toggled on or off clicking the desired trace in the legend.\n\nAlthough UMPIRE has many advantages, it suffers from being susceptible to noise. \n\nFigure 5.18 uses the same phase data as the previous figure, but adds a slider that simulates a phase offset added to the second echo.\n\n\n\nFigure¬†5.18:Effect of noise using UMPIRE. A slider is provided to change the field offset of the second echo and to see its effect on the resulting unwrapped data and linear fit.\n\nUnwrappers, such as PRELUDE \n\nJenkinson, 2003 are less susceptible to noise, but do not have the ability to resolve >\\pi phase offsets between timepoints and can take longer to unwrap the data. The SEGUE \n\nKarsa & Shmueli, 2019 algorithm performs similarly to PRELUDE but can be much faster. ROMEO \n\nDymerska et al., 2021 is also an algorithm that is quite fast and has been shown to perform better than PRELUDE and BEST PATH\n\nAbdul-Rahman et al., 2007 with noise.","type":"content","url":"/b0-mapping#b0multiecho","position":37},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Reducing eddy currents","lvl2":"Advanced B0 Mapping Methods"},"type":"lvl3","url":"/b0-mapping#b0eddy","position":38},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Reducing eddy currents","lvl2":"Advanced B0 Mapping Methods"},"content":"Up to this point we have assumed that the phase changes linearly with time. However, this is not always the case. \n\nEddy currents can be generated inside the ROI when gradients are changed rapidly. These decaying \n\neddy currents create a spatially and temporally varying field that can therefore be different depending on the echo time. As the \n\neddy currents are not constant, they do not cancel out when computing a phase difference. Longer TRs can help minimize \n\neddy currents and avoid the issue. For smaller TRs, it is possible to acquire the same acquisition twice with the frequency, phase and slice encoding directions reversed. This has the effect of reversing the \n\neddy currents polarity. The field map for each acquisition can be computed and then averaged to minimize their effect.","type":"content","url":"/b0-mapping#b0eddy","position":39},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Realtime B0 mapping","lvl2":"Advanced B0 Mapping Methods"},"type":"lvl3","url":"/b0-mapping#realtime-b0-mapping","position":40},{"hierarchy":{"lvl1":"B0 Mapping","lvl3":"Realtime B0 mapping","lvl2":"Advanced B0 Mapping Methods"},"content":"Specific applications impose constraints that can make field mapping protocols different. One such application is to acquire field maps as close to real-time as possible to characterize the effect of respiration on the field through time. The constraint is therefore to acquire a field map in much less time than a respiration cycle. To save some time, the association of the field with time can be done by acquiring slices one at a time. A 2D scan is therefore preferable in this case, as the slice timing can be associated with the field of the slice rather than using the volume time and the entire volume. An EPI can be used to acquire a field map much faster than a standard gradient-echo. However, as mentioned previously, the distortions might not make this a suitable solution. A 2D dual-echo gradient-echo can be used with minimum TR. Short TEs and RF pulses are also preferable to again reduce the TEs and the TR.","type":"content","url":"/b0-mapping#realtime-b0-mapping","position":41},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Exercises"},"type":"lvl2","url":"/b0-mapping#exercises","position":42},{"hierarchy":{"lvl1":"B0 Mapping","lvl2":"Exercises"},"content":"A researcher wants to map the B0 field but fears potential errors that could occur from phase unwrapping. What Œ¥TE should the researcher choose in a dual-echo GRE acquisition considering he/she expects a maximum field offset of 1.5ppm at 1.5T so that no phase unwrapping is necessary?\n\nWhat is the phase offset created by an inhomogeneous B0 field of 50Hz in a dual-echo GRE acquisition with {math}\\delta`TE = 3 ms.\n\nA perfectly homogeneous field of exactly 3T in the entire FOV is being imaged in a homogeneous phantom on a 3T scanner. Due to manipulation errors, the imaging frequency (f0/Larmor frequency) was set to that of the field 3T - 4.69731 ŒºT.\n\na. In a dual-echo GRE with Œ¥TE=5ms, explain what the field-map would look like.\n\nb. If the imaging frequency offset was set to 3T - 2.35 ŒºT, what would the field map look like?\n\nHere is a 3-echo GRE dataset.\n\n**a. ** From this data, calculate a field-map using the first 2 echoes\n\nb. Calculate a field map using all echoes\n\nc. Compute the difference\n\nYou are wearing a smart watch that‚Äôs connected to the internet, and is always in sync with your international time zone. One morning, you walk into the lab at 9 am and see that your room‚Äôs analog wall clock also shows 9 am. Some time later, you see that the wall clock shows it‚Äôs 9:45 am, but your watch shows 9:30am.\n\n\n\na. Is the wall clock running fast or slow?\n\nb. What frequency is the wall clock running at, in terms of minutes on the wall clock per true hours?\n\nc. Does it make a difference if ‚Äúsome time later‚Äù is the same day, or different days?\n\nSomeone comes in and repairs the clock, but they accidentally broke the hour hand, leaving only the minute hand. They assure you though that the minute hand is accurate, but you still are in doubt. Every break you take, as well as when you arrive and leave, you decide to track the time it shows on your watch vs the number that the minute hand points to on the clock . After a day, you have the following table:\n\n\n\nd. Can you tell if the wall clock is running fast or slow?\n\ne. Estimate the frequency of the wall clock (minutes on wall clock per true hours)if you believe it is running fast.\n\nf. Estimate the frequency if you believe it is running slow\n\ng. Are there other frequencies it could be running at?\n\nA post-doc nearby sees what you‚Äôre doing, and suggests that maybe you should consider shortening the time on your watch between when you track the wall clock time, and to take the angle relative to the 12 position for better precision. You take the angle every 5 minutes for an hour, and get the following angles (in degrees) of the wall clock:\n\n\n\nh. Can you tell if the wall clock is running fast or slow?\n\ni. Estimate the frequency of the wall clock in terms of radians per hour.\n\nj. Are you confident in this value? Could it be other frequencies?","type":"content","url":"/b0-mapping#exercises","position":43},{"hierarchy":{"lvl1":"Magnetization Transfer"},"type":"lvl1","url":"/magnetization-transfer-imaging","position":0},{"hierarchy":{"lvl1":"Magnetization Transfer"},"content":"","type":"content","url":"/magnetization-transfer-imaging","position":1},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Quantitative Magnetization Transfer"},"type":"lvl2","url":"/magnetization-transfer-imaging#qmtintro","position":2},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Quantitative Magnetization Transfer"},"content":"Magnetization Transfer (MT) has been extensively applied to study macromolecular biological tissue composition. The imaging contrast resides in the magnetization transfer between free-water protons and macromolecular proton compartments, through chemical exchange and dipolar interactions. In the two-pool tissue model, highly mobile protons are associated with the free-water pool while protons found in semisolid macromolecular sites are defined as the restricted pool \n\nSled, 2018. A simple method for visualizing MT effects includes acquiring two images with and without an off-resonance MT pulse to calculate the MT ratio (MTR), which is the normalized difference of these two images \n\nWolff & Balaban, 1989. Despite its proven usefulness to study multiple sclerosis \n\nZheng et al., 2018, Alzheimer‚Äôs disease \n\nFornari et al., 2012 and psychiatric disorders \n\nChen et al., 2015, the MTR is a semi-quantitative metric that depends critically on the imaging sequence parameters \n\nSeiberlich et al., 2020. Another semi-quantitative approach is the estimation of MT saturation (MTsat) by fitting the MT signal obtained from an MT-weighted (MTw), a proton density (PD) weighted and T1-weighted (T1w) contrast \n\nHelms et al., 2008. Quantitative MT (qMT) consists of fitting multiple images to a mathematical model to extract tissue-specific parameters related to physical quantities, such as pool sizes, magnetization exchange rates between pools, and T1, T2 relaxation times of each pool. Compared to semi-quantitative approaches (MTR, MTsat), qMT has long acquisition protocols and sometimes needs additional measurements (eg. B0, B1, T1), and the complex models required to fit the quantitative maps makes it a challenging imaging technique.\n\nIn 2015, our lab published qMTLab \n\nCabana et al., 2015, an open-source software project seeking to unify three qMT methods in the same interface: qMT using spoiled gradient echo (qMT-SPGR), qMT using balanced steady-state free precession (qMT-bSSFP), and qMT using selective inversion recovery with fast spin echo (qMT-SIRFSE). qMTLab allowed users to simulate, evaluate, fit, and visualize qMT data with the possibility to share qMT protocols between researchers, allowing them to compare the performance of their methods \n\nCabana et al., 2015. Since then, we have extended the project and renamed it to qMRLab, \n\nKarakuzu et al., 2020, which in addition to qMT now provides over 20 quantitative techniques under one umbrella, such as relaxation and diffusion models, quantitative susceptibility mapping, B0 and B1 mapping. In addition, we created interactive tutorials (see the T1 mapping chapters using the \n\ninversion recovery, \n\nvariable flip angle, and \n\nMP2RAGE techniques) and blog posts for several qMRI techniques that were published under a creative commons license made it into a quantitative MRI book published by Elsevier \n\nSeiberlich et al., 2020. This blog post is a continuation of our qMRLab outreach initiative, where we will focus on qMT and the tools we provide in qMRLab for this class of techniques.\n\nThis section is an introduction to qMT (with a focus on qMT-SPGR), where we will cover signal modelling and data fitting.","type":"content","url":"/magnetization-transfer-imaging#qmtintro","position":3},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Signal Modelling","lvl2":"Quantitative Magnetization Transfer"},"type":"lvl3","url":"/magnetization-transfer-imaging#signal-modelling","position":4},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Signal Modelling","lvl2":"Quantitative Magnetization Transfer"},"content":"The magnetization transfer in a two-pool model is modelled by a set of coupled differential equations \n\nSled & Pike, 2000:\\frac{d M_{x,f}}{dt}=-\\frac{M_{x,f}}{T_{2,f}}+\\Delta M_{y,f}-\\text{Im}\\left( \\omega_{1} \\right)M_{z,f}\\frac{d M_{y,f}}{dt}=-\\frac{M_{y,f}}{T_{2,f}}+\\Delta M_{x,f}-\\text{Re}\\left( \\omega_{1} \\right)M_{z,f}\\frac{d M_{z,f}}{dt}=-\\frac{\\left( M_{0,f}-M_{z,f} \\right)}{T_{1,f}}+k_{r}M_{z,r}+\\text{Im}\\left( \\omega_{1} \\right)M_{x,f}-\\text{Re}\\left( \\omega_{1} \\right)M_{y,f}\\frac{d M_{z,r}}{dt}=-\\frac{\\left( M_{0,r}-M_{z,r} \\right)}{T_{1,r}}-k_{r}M_{z,r}+k_{f}M_{z,f}+WM_{z,r}W=\\pi\\omega_{1}^{2}G\\left(\\Delta,T_{2,r}  \\right)\n\nwhere the magnetization at time t is given by \\textbf{M}\\left( t \\right)=\\left[ M_{x,f}, M_{y,f}, M_{z,f}, M_{z,r} \\right] and M_{x,f} and M_{y,f} are the transverse magnetization for the free pool in the x and ùë¶ direction, respectively. The longitudinal magnetization for the free and restricted pool is denoted by M_{z,f} and M_{z,r}. Due to the very short T2 of the restricted pool (on the order of microseconds), the transverse magnetization of this pool is not explicitly modelled.\n\nThe constants kf and kr represent the exchange rate of the longitudinal magnetization from the free pool to the restricted pool (kf) and from the restricted to the free pool (kr). The ratio of these quantities is constrained by the size of the restricted to the free-water pool, expressed as k_{f}/k_{r}=M_{0,r}/M_{0,f}. This ratio is called the pool size ratio F defined as F=M_{0,r}/M_{0,f}. The precessional frequency \\omega_{1} is a measure of the power of the off-resonance radiofrequency pulse and ‚àÜ is a frequency offset at which the magnetic B1+ field is applied. As shown in \n\nFigure 6.1, an on-resonance (‚àÜ = 0) radiofrequency pulse is also part of the pulse sequence and is applied after the MT pulse. The relaxation time constants for the free and restricted pools are denoted by T1,f and T1,r for the longitudinal magnetization, and T2,f and T2,r for the transverse magnetization. Finally,  ùëä is the saturation rate of the restricted pool, which is a function of the absorption lineshape  ùê∫ that depends on the frequency offset and the transverse relaxation of the restricted pool (\n\nFigure 6.2).\n\n\n\nFigure¬†6.1:Simplified pulse sequence diagram of a magnetization transfer spoiled gradient (MT-SPGR) experiment with an MT pulse followed by a spoiler gradient to destroy any transverse magnetization before the application of the on-resonance excitation pulse.\n\nThe absorption lineshape of the restricted pool that best characterizes the proton system depends on the environment. For simple systems such as agar gel phantoms, the Gaussian lineshape describes magnetization transfer effects well \n\nHenkelman et al., 1993, while for more complicated and biologically relevant models, the super-Lorentzian lineshape is the best choice \n\nMorrison et al., 1995.\n\n\n\nFigure¬†6.2:Gaussian, Lorentzian and super-Lorentzian absorption lineshapes plotted as a function of the frequency offset ‚àÜ and T2,r.\n\nIn a standard qMT experiment, multiple measurements are required where the off-resonance radiofrequency pulse angle (MT angle) and offset frequency are changed for each measurement, and at least one measurement is acquired in the absence of an MT pulse. The acquired signal plotted as a function of the offset frequency is known as the ‚ÄúZ-spectrum‚Äù, and \n\nFigure 6.3 shows the Z-spectrum simulated using different absorption lineshapes. The off-resonance MT pulse is modelled either as a continuous wave or as a pulsed irradiation scheme. In a continuous wave irradiation mode, long off-resonance pulses of constant saturation and fixed frequency offset are applied to generate well-defined MT states in the two pools \n\nHenkelman et al., 2001. For more practical implementations, pulsed off-resonance irradiations are used with a spoiled gradient echo sequence (SPGR) to generate MT-weighted images at different saturation rates and frequency offsets \n\nSled & Pike, 2000. In the qMT-SPGR sequence shown in \n\nFigure 6.1, the MT preparation pulse is applied, followed by a spoiler gradient to eliminate any residual transverse magnetization produced by the long MT pulses, and to destroy the MR signal from previous measurements. A signal equation for this type of pulsed MT experiment can be derived by approximating the pulse sequence to a series of stages described by a continuous wave off-resonance irradiation period, followed by free precession, and instant saturation of the free-water pool \n\nCabana et al., 2015\n\nSled & Pike, 2000\n\nSled & Pike, 2001. This pulse sequence decomposition allows for analytically solving the Bloch-McConnell equations at a steady-state, but it is also possible to numerically solve the Bloch equations to perform simulations that provide a more realistic approximation when the system has not been driven to a steady-state. A comparison between the Bloch simulations and the analytical solution is shown in \n\nFigure 6.4 for different numbers of preparation MT pulses. As can be seen, different frequency offsets and MT flip angles require different numbers of repetition times to reach the steady-state, which is of paramount importance since the analytical solution used for parameter estimation is derived assuming the steady-state. In terms of data acquisition optimization, the k-space periphery is sampled during the preparation pulses whereas the center of k-space, that contains the overall image contrast, is acquired once the steady-state is achieved.\n\n\n\nFigure¬†6.3:Z-spectrum simulated using different absorption lineshapes (Gaussian, Lorentzian, and super-Lorentzian).\n\n\n\nFigure¬†6.4:Z-spectrum simulated using Bloch simulations (dashed lines) for a number of MT pulses ranging from 1 to 600. Bloch simulations are compared with the Z-spectrum obtained from the analytical solution (solid lines).","type":"content","url":"/magnetization-transfer-imaging#signal-modelling","position":5},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Data Fitting","lvl2":"Quantitative Magnetization Transfer"},"type":"lvl3","url":"/magnetization-transfer-imaging#data-fitting","position":6},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Data Fitting","lvl2":"Quantitative Magnetization Transfer"},"content":"In qMT imaging, the biophysical model relates the parameters observed in the two-pool tissue model to physical quantities such as the fractional size of the pools, relaxation times and magnetization exchange rates of the free and restricted pool \n\nSled & Pike, 2001\n\nSled, 2018. However, qMT experiments usually consist of long acquisition imaging protocols accompanied by complex data fitting. To this end, some software solutions have been proposed \n\nKarakuzu et al., 2020\n\nTabelow et al., 2019\n\nC Wood, 2018. qMRLab is an open-source project for quantitative MR analysis that is an extension of qMTLab, a software for data simulation and analysis of three MT models: qMT-SPGR, qMT-bSSFP and qMT-SIRFSE. In addition to the quantitative MT methods, qMRLab also contains semi-quantitative MT models including the magnetization transfer ratio (MTR) and magnetization transfer saturation (MTsat).\n\nThe qMT-SPGR method in qMRLab contains three fitting models: Sled and Pike, Ramani, and Yarnykh and Yuan \n\nSled & Pike, 2001\n\nRamani et al., 2002\n\nYarnykh, 2002. For the Sled and Pike model, the saturation fraction effect of the MT pulse on the free pool is pre-computed to accelerate the processing times. The MT effect of the pulse is approximated as an instantaneous fractional saturation of the longitudinal magnetization of the free pool, assuming the absence of chemical exchange processes \n\nPike, 1996\n\nSled & Pike, 2001. To fit the model, additional parameters related to the pulse sequence are required, namely timing parameters, the absorption lineshape, and the characteristics of the MT pulse, such as the shape and the bandwidth or the time-bandwidth product. In \n\nFigure 6.5, the qMT-SPGR method is used to show a single voxel curve simulation for the same MT data fitted by three different models. The fitted parameters were the pool size ratio F, the magnetization transfer rate from the restricted to the free-water pool (kr), and the transverse relaxation time of the free-water (T2,f) and restricted (T2,r) pool.\n\n\n\nFigure¬†6.5:Sled and Pike, Ramani, and Yarnykh and Yuan models to fit the MT data from a qMT-SPGR experiment.\n\nIn addition to acquiring the MT data, three more quantitative measurements are typically required for model correction purposes. The magnetic field B0 inhomogeneity affects the actual off-resonance frequency experienced by the tissue at each voxel. In MT, B0 maps are computed to correct for off-resonance frequency values of the MT pulse in the presence of magnetic field non-uniformity. Radiofrequency field B1 inhomogeneity is another source of inaccuracies that depend on the operating frequency of the scanner, the pulse sequence, and the shape and electrical properties of the sample \n\nSled & Pike, 1998. Therefore, B1 maps are typically needed to correct the radiofrequency amplitude variations that affect the nominal values of the MT pulse flip angle and the excitation flip angle \n\nBoudreau et al., 2018. Longitudinal relaxation T1 values vary naturally in biological tissue, but the choice of the T1 mapping method, has also been shown to influence the variability of T1 measurements \n\nStikov et al., 2015. In the context of a qMT experiment, T1 maps are acquired with an independent measurement of the apparent relaxation time T1 (T1, meas). The T1 map is related to the relaxation rate of the free pool (R1,f) as described by \n\nEq. 6.6, expressed in terms of  ùêπ, kf, R1,meas and R1,r, where the relaxation rate of the restricted pool is arbitrarily set to 1 s-1 because it is insensitive to this kind of MT experiments \n\nSled & Pike, 2001. Multiple qMRI maps with a range of B0 and B1 inaccuracies, as well as T1 maps with a variety of relaxation times, have been simulated to show the effect of the quality of these input maps on the qMT fitted parameters as shown in \n\nFigure 6.6.R_{1,f}=R_{1}^{meas}-\\frac{k_{f}\\left( R_{1,r}-R_{1}^{meas} \\right)}{\\left( R_{1,r}-R_{1}^{meas} \\right)+\\frac{k_{f}}{F}}\n\n\n\nFigure¬†6.6:Errors (%) in fitted parameters when input maps of different quality are used. A B1 map of 0.9 means that the input has a 10% lower value than expected. The fitted parameters include the pool size ratio, F, the magnetization exchange rate, kf, the free pool T2,f, and the restricted pool T2,r. The errors were simulated for B0, B1 and T1 maps of different quality.\n\nAs described above in \n\nFigure 6.6, inaccurate MT pulse flip angles and excitation flip angles affect the fitted MT parameters, and there is an additional error source related to the T1 mapping measurement. As shown in \n\nBoudreau et al., 2018, using specific acquisitions protocols, T1 values can be affected by B1 field non-uniformities, such as the variable flip angle method, while the inversion recovery method is insensitive to these field inhomogeneities \n\nStikov et al., 2015.\n\nFigure 6.7 displays an example human dataset with the input qMRI maps used to fit the qMT parameters F, kf, T2,f, T2,r.\n\n\n\n\n\nFigure¬†6.7:Example magnetization transfer spoiled gradient dataset showing qMRI maps used to fit the MT data (top), and the fitted parameters F, kf, T2,f, T2,r (bottom).","type":"content","url":"/magnetization-transfer-imaging#data-fitting","position":7},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Summary","lvl2":"Quantitative Magnetization Transfer"},"type":"lvl3","url":"/magnetization-transfer-imaging#summary","position":8},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Summary","lvl2":"Quantitative Magnetization Transfer"},"content":"In summary, the Bloch-McConnell equations, an analytical solution to the steady-state signal can be derived and fitted with one of the existing models that make different approximations to fit the qMT data for a different set of parameters. The Sled and Pike model \n\nSled & Pike, 2001 constrains the solution space by computing complementary T1 maps, whose acquisition method influences the B1 sensitivity of the fitted parameters \n\nBoudreau et al., 2018. This fitting model can be implemented with a continuous or a rectangular wave irradiation of the restricted pool \n\nCabana et al., 2015. Ramani‚Äôs fitting model is an alternative approach that assumes a continuous wave irradiation scheme with the MT pulse on both free and restricted pools \n\nRamani et al., 2002. Another fitting model was proposed by Yarnykh \n\nYarnykh, 2002 where an analytical solution to describe the magnetization is found when the direct saturation of the free pool is neglected.\n\nIn future blog posts, we will explore other MT methods, such as MTR \n\nWolff & Balaban, 1989, MTsat \n\nHelms et al., 2008 and qMT-bSSFP \n\nBieri & Scheffler, 2007\n\nGloor et al., 2008. Additionally, we will also be looking at the effects of RF field inhomogeneity on the generated magnetization transfer maps.","type":"content","url":"/magnetization-transfer-imaging#summary","position":9},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Magnetization Transfer Ratio"},"type":"lvl2","url":"/magnetization-transfer-imaging#magnetization-transfer-ratio","position":10},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Magnetization Transfer Ratio"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nConventional MRI techniques, such as those used for clinical diagnosis, can only directly measure hydrogen bonded to water molecules. Thus, a non-negligible proportion of body mass is not visible with clinical MRIs, such as non-hydrogen atoms (different resonance frequencies) and hydrogen atoms bonded to large molecules which restricts the motion of the atoms (rapid signal decay, T2 ~ Œºs). The latter, called macromolecules, play an important role in the physiology of the body; for example, myelin in the white matter of the brain plays an important role in signal transmission, and is composed largely of macromolecules (lipids and proteins). Although the images acquired by clinical MRI machines can only be generated from signal from mobile hydrogen, these hydrogen atoms interact with nearby molecules and atoms via the electromagnetic fields they mutually generate. In the 70s and 80s, a cross-relaxation mechanism was discovered that sensitizes mobile protons to nearby targeted semi-solid molecules, such as myelin \n\nEdzes & Samulski, 1977\n\nEdzes & Samulski, 1978\n\nWolff & Balaban, 1989. With proper experimental design, a higher density of nearby macromolecules in the tissue results in a lower MRI signal. This class of MRI techniques is known as magnetization transfer (MT) imaging.\n\nIn the preceding chapter, we delved into the quantitative aspects of magnetization transfer (qMT) imaging, exploring the Bloch-McConnell model, signal modeling, and fitting techniques using qMRLab. Now, we shift our focus to the more accessible and widely used application of MT: magnetization transfer ratio (MTR). Although less quantitative than qMT, MTR is easier to set up and implement, making it popular choices in the MRI community interested in quantifying myelin loss.\n\nIn the simplest and most used MT imaging method, only two images are acquired (one with MT preparation, and one without), and a normalized difference between the two images is calculated. This quantity is known as the magnetization transfer ratio (MTR), and has been used extensively to infer information on myelin diseases and disorders, such as \n\nmultiple sclerosis (MS). The proportional relationship between MTR and myelin density has been established using post-mortem immunohistological studies in humans \n\nSchmierer et al., 2004\n\nSchmierer et al., 2007 and animals \n\nMerkler et al., 2005\n\nZaaraoui et al., 2008. MTR has also already been used in clinical drug trials for MS \n\nMaguire et al., 2013\n\nBrown et al., 2016. Its widespread use is due to the fact that most scanners are equipped with the necessary software so that it can be added to an imaging protocol with the click of a button, and it is also a very quick measurement with a short acquisition time.\n\nAs summarized in the previous chapter, MR physicists have also developed other MT-related techniques that aim to extract quantitative physical information of tissues, using the mathematical models that describe the MT process. This sub-field is called quantitative MT, and the tissue properties that are typically measured are: the pool-size ratio F (density of the macromolecular content‚Äôs (restricted pool) equilibrium magnetization divided by the the same value for the liquid content (free pool)), the exchange rate R, the longitudinal relaxation of the free pool T1,f, and the transverse relaxation of both the free and restricted pools (T2,f and T2,r). In contrast to MTR, quantitative MT techniques are not as widely used because of the long image acquisition times required that impedes clinical use. qMT also requires additional calibration measurements (B0, B1+, and T1), which can be challenging to measure accurately and thus contribute to additional propagation of errors to the measured qMT parameters \n\nBoudreau et al., 2018\n\nBoudreau & Pike, 2018. Despite these challenges, a lot of research focuses on developing and using qMT techniques in smaller studies, because the measured qMT parameters are desensitized to effects that can bias MTR measurements (eg T1, B1+). Another semi-quantitative MT technique that was recently developed is the MT saturation (MTsat) technique, which is the focus of \n\nanother section of this book.","type":"content","url":"/magnetization-transfer-imaging#magnetization-transfer-ratio","position":11},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"MTR in theory","lvl2":"Magnetization Transfer Ratio"},"type":"lvl3","url":"/magnetization-transfer-imaging#mtr-in-theory","position":12},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"MTR in theory","lvl2":"Magnetization Transfer Ratio"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nThe full mathematical description of the magnetization transfer two-pool exchange model was explained in the \n\nqMT section. Although it‚Äôs these same equations that explain the signal differences between the two images acquired used to calculate MTR, in this section we‚Äôll present a more conceptual explanation of the MT exchange process.\n\nIn its most basic form, MT is modeled as an exchange process between two ‚Äúpools‚Äù of protons, those from ‚Äúmobile‚Äù protons (eg, hydrogen in liquid water) named the ‚Äúfree‚Äù pool (those that are directly measured with conventional MRI), and those from ‚Äúrestricted‚Äù protons (i.e. macromolecules) named the ‚Äúrestricted‚Äù pool (these cannot be measured directly with conventional MRI). Macromolecular hydrogen cannot be measured directly because the restricted movement creates a more static local electromagnetic environment that doesn‚Äôt average out, and this results in a transverse relaxation T2,r (signal decay) that is too short to provide measurable signal (T2,r ~ Œºs << feasible TE). Another consequence of this short signal decay time is a broadening of the absorption lineshape in the frequency domain (eg. the range of ‚Äúresonant‚Äù frequencies of that pool of protons). This is a known property of the Fourier Transform, and the phenomenon is isomorphic to the quantum mechanics uncertainty principle; as Œîx‚ãÖŒîp ‚â• constant in quantum mechanics means that if Œîx increases Œîp will decrease, we observe a similar relationship approximated to T2‚ãÖFWHM (full width at half maximum) of the frequencies = constant such that if T2 decreases, the FWHM of the frequencies will increase. If T2 is very very short (such as the case for macromolecules), the range of resonant frequencies will be very wide. MT leverages this property by selectively exciting restricted protons far from the mobile proton resonance frequency (applying a pulse off-resonance), but where the energy will be absorbed by some of the protons in the restricted pool. This is the initial preparation of the MT experiment that triggers the conditions needed for cross-relaxation between the unobservable molecules (restricted pool) and observable protons (free pool).\n\nConventionally, the two-pool exchange model is explained conceptually as a process of magnetization exchange, which is also how it‚Äôs described mathematically using the Bloch-McConnel equations. However, this conceptual model can be challenging to understand, particularly for people with physics backgrounds, because unlike energy and momentum, the total magnetization in a voxel is not a conserved physical property. This can be seen simply by observing the evolution of the total magnetization vector after an excitation pulse; the total magnetization vector is (mostly) conserved during the RF pulse, but then decays quickly to near 0 due to T2 relaxation, and takes a long time to grow back to M0 from T1 relaxation. The vector is not constant. So, if magnetization is not a conserved property, how do we know if and how much of it is being exchanged?\n\nAs explained in more detail in \n\nAppendix A, an MT experiment involves the conservation and transfer of energy between spin populations. The off-resonance RF pulse introduces extra energy into the restricted pool of protons, and the relaxation back to thermal equilibrium occurs through spin-lattice relaxation, where the ‚Äúlattice‚Äù includes nearby free-pool protons. This energy exchange results in a reduction of net magnetization in the free pool and a corresponding decrease in observable MR signal. This process underlies the contrast observed in MT imaging, which reflects differences in tissue microstructure and composition.\n\nNow that we have a better grasp of the magnetization exchange process, we can see how this applies for MTR. In MTR, we acquire one image with MT saturation (low signal where there is high macromolecular density), and one image without MT saturation (higher relative signal where there are macromolecules). The MTR signal is then simply calculated as a normalized difference in percentage, that is:\\text{MTR} \\left( \\text{\\%} \\right) = \\frac{S_{0}-S_{MT}}{S_{0}} \\cdot 100\n\nWhat does this calculated MTR value mean? MTR is the reduction in the steady-state signal resulting from an MT-sensitizing pulse and the ensuing MT exchange that occurs. The higher the density of macromolecular content there is, the more reduction in MT-weighted signal will occur, resulting in a higher MTR value. Typically, MTR values in healthy white matter are higher than in grey matter, and MTR values where there is myelin loss are smaller relative to healthy tissue.","type":"content","url":"/magnetization-transfer-imaging#mtr-in-theory","position":13},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"MTR in practice","lvl2":"Magnetization Transfer Ratio"},"type":"lvl3","url":"/magnetization-transfer-imaging#mtr-in-practice","position":14},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"MTR in practice","lvl2":"Magnetization Transfer Ratio"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nTypically, MTR imaging protocols are implemented on the scanner by adding a relatively long (~5-10 ms) high amplitude off-resonance (~2kHz) preparation RF pulse prior to each TR of an existing imaging sequence. In the early days of MT, the MT pulse was a very long pulse (~10 seconds) prior to one imaging readout of saturation-recovery sequences, but this results in impractically long acquisition times and is very SAR (Specific Absorption Rate) prohibitive. Alternative approaches were explored (eg. 1-2-1 pulses), however now most MT-weighted sequences are done using steady-state sequences (eg SPGR) with a shorter preparation pulse (~10 milliseconds). \n\nFigure 6.8  illustrated this using a spoiled-gradient recalled echo (SPGR) sequence, with a Gaussian-shaped MT preparation pulse prior to the excitation pulse.\n\n\n\nFigure¬†6.8 :Simplified pulse sequence diagram of an MTR imaging sequence. An off-resonance and high powered MT-preparation pulse is followed by a spoiler gradient to destroy any transverse magnetization prior the application of the imaging sequence, in this case a spoiled gradient recalled echo (SPGR).\n\nEach MRI vendor optimizes their MT-weighted protocol parameters (eg MT shape, duration, frequency, and amplitude), and few of these details are typically shared with the end-user. \n\nTable¬†6.2   shares protocol parameters used by different MRI manufacturers as reported by two publications.\n\nTable¬†6.2  :Literature MTR protocol parameters (sources: \n\nBrown et al., 2013\n\nKarakuzu et al., 2022)\n\n\n\nBrown 2013\n\nKarakuzu 2022\n\n\n\nSiemens\n\nPhilips\n\nGE\n\nSiemens\n\nFA (deg)\n\n15\n\n15\n\n6\n\n6\n\nTR (ms)\n\n30\n\n47\n\n32\n\n32\n\nTE (ms)\n\n11\n\n8\n\n4\n\n4\n\nOffset (Hz)\n\n1500\n\n1100\n\n1200\n\n1200\n\nMT pulse shape\n\nGaussian\n\nSinc-Gaussian\n\nFermi\n\nGaussian\n\nMT pulse length (ms)\n\n7.68\n\n15\n\n8\n\n10\n\nMT pulse angle (deg)\n\n500\n\n620\n\n540\n\n540\n\nThese differences in protocol parameters can result in MTR values that vary greatly between vendors and sites, meaning that MTR can be challenging to compare unless great care in details are taken. \n\nFigure 6.9 shows MTR simulations using the fundamental qMT parameters for four different tissues (\n\nTable¬†6.3  ; healthy cortical grey matter, healthy white matter, NAWM, early white matter multiple sclerosis lesion, late white matter multiple sclerosis lesion) using the four MT-weighted SPGR protocols from \n\nTable¬†6.2  .\n\nTable¬†6.3  :Quantitative MT parameters in healthy and diseased human tissue reported for a study at 1.5 T \n\nSled & Pike, 2001.\n\n\n\nHealthy cortical GM\n\nHealthy WM\n\nNAWM\n\nEarly WM MS lesion\n\nLate WM MS lesion\n\nF\n\n0.072 ¬± 0.013\n\n0.161 ¬± 0.025\n\n0.15 ¬± 0.02\n\n0.12 ¬± 0.02\n\n0.094 ¬± 0.015\n\nkf\n\n2.4 ¬± 0.013\n\n4.3 ¬± 1.0\n\n4.9 ¬± 1.3\n\n3.6 ¬± 0.8\n\n2.7 ¬± 0.7\n\nR1,f (s-1)\n\n0.93 ¬± 0.2\n\n1.8 ¬± 0.3\n\n1.78 ¬± 0.4\n\n1.52 ¬± 0.2\n\n1.26 ¬± 0.3\n\nR1,r (s-1)\n\n1\n\n1\n\n1\n\n1\n\n1\n\nT2,f (ms)\n\n56 ¬± 8\n\n37 ¬± 8\n\n38 ¬± 7\n\n43 ¬± 6\n\n52 ¬± 9\n\nT2,r (Œºs)\n\n11.1 ¬± 8\n\n12.3 ¬± 1.6\n\n11.4 ¬± 1.4\n\n10.3 ¬± 1.1\n\n10.9 ¬± 1.4\n\n\n\nFigure¬†6.9:MTR values calculated from fundamental qMT tissue parameters for four different MTR imaging protocols.\n\nAs demonstrated in the above simulations, one MTR value could have the same value for healthy tissue on one scanner as diseased tissue would have on another scanner. So for the most part, MTR is best used / compared within vendors at the very least, though some normalization techniques have been developed.\n\nIn addition to being very sensitive to protocol implementations, MTR values are also sensitive to other tissue properties. As seen in the qMT blog post, the parameter most closely related to macromolecular content is the pool-size ratio F. But, if some disease / symptom impacts T1  independently of underlying macromolecular content, MTR will also change. That is to say, MTR is sensitive to tissue‚Äôs T1 value independently of the macromolecular content metric F, as shown in \n\nFigure 6.10.\n\n\n\nFigure¬†6.10:MTR value for (protocol?) and (tissue?) changes as a function of the underlying T1 value (T1,obsobs or T1,f?).\n\nIn addition to being sensitive to tissue properties, MTR is also sensitive to system properties such as B1 (via MT pulse amplitude) and B0 (via off-resonance frequency). In particular, B1 can vary up to 30% the nominal value at 3T, and without correction this can introduce substantial errors. \n\nFigure 6.11 illustrates how MTR can vary with different B1 values.\n\n\n\nFigure¬†6.11:MTR value for (protocol?) and (tissue?) changes as a function of the underlying B1 value (T1,obsobs or T1,f?).\n\nLastly, MTR is sensitive to protocol adjustments, which could be done by a scanner operator to accommodate issues during an imaging session. \n\nFigure 6.12 demonstrates how MTR varies with TR adjustments.\n\n\n\nFigure¬†6.12:MTR value for (protocol?) and (tissue?) changes as a function protocols TR value.\n\n\n\nFigure¬†6.13:Surface map","type":"content","url":"/magnetization-transfer-imaging#mtr-in-practice","position":15},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Parting thoughts","lvl2":"Magnetization Transfer Ratio"},"type":"lvl3","url":"/magnetization-transfer-imaging#parting-thoughts","position":16},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Parting thoughts","lvl2":"Magnetization Transfer Ratio"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nTo sum up, our exploration of Magnetization Transfer Ratio (MTR) has highlighted its widespread utility within the field of MRI, in particular for myelin quantification applications. However, it‚Äôs essential to emphasize that MTR, while immensely valuable, is not a truly quantitative metric. This point underscores the need for caution when comparing MTR values or conducting longitudinal studies, as various factors, including scanner upgrades (both in hardware and software), can potentially result in variations in MTR values for the same subject or samples.\n\nIn our next section, we‚Äôll shift our focus to MTsat, which is a promising semi-quantitative metric that rivals MTR for its ease of use and rapid acquisition times. MTsat aims to address some of the challenges associated with MTR, while still offering robust sensitivity to macromolecular content.","type":"content","url":"/magnetization-transfer-imaging#parting-thoughts","position":17},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Magnetization Transfer Saturation"},"type":"lvl2","url":"/magnetization-transfer-imaging#mtsatintro","position":18},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Magnetization Transfer Saturation"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nMagnetization Transfer Saturation (MTsat) is a semi-quantitative MRI technique that offers unique insights into tissue microstructure. Built upon the spoiled gradient-recalled echo (SPGR) sequence, the MTsat protocol acquires images with and without an MT-preparation off-resonance pulse to acquire different contrast that varies with macromolecular density and T1.\n\nThe foundation of MTsat lies in a 2008 model by Helms and colleagues \n\nHelms et al., 2008, which treats the off-resonance pulse as a second excitation pulse, allowing us to model the effects of MT analytically without the need of the complex Bloch-McConnel equations. Following some reasonable approximations and the acquisition of three distinct MRI images, this model allows for analytical computation of a parameter that models the % reduction in free-pool longitudinal magnetization due to a single off-resonance pulse, MTsat.\n\nThis introduction provides a glimpse into the theoretical basis of MTsat, its practical applications, and sensitivity to variables like tissue T1 and B1. By exploring the unique properties and potential of MTsat, we hope to give readers a better understanding of the advantages and limitations of this MRI technique in both research and clinical practice, as well as give a deeper conceptual understanding of what the MTsat value means.\n\nMTsat, like MTR and many flavours of quantitative MT, is based on spoiled gradient recalled echo (SPGR) images \n\nHaase et al., 1986\n\nSekihara, 1987\n\nHargreaves, 2012 preceded by an off-resonance RF pulse to provide magnetization transfer contrast \n\nWolff & Balaban, 1989\n\nHenkelman et al., 1993\n\nSled & Pike, 2000\n\nSled, 2018. \n\nFigure 6.14 presents a simplified diagram of this MT-prepared SPGR pulse sequence (imaging gradients are not shown). A standard SPGR sequence (low flip angle [~5-10¬∞], short TR [~10-30ms], and a strong spoiler gradient) are preceded by a long (~10 ms) off-resonance (~1-5 kHz) pulse with a strong peak amplitude (the total pulse has an equivalent on-resonance flip angle of 200¬∞-700¬∞). A smooth shape (e.g. Gaussian or Fermi) is typically used for the off-resonance pulse in order to have a single off-resonance frequency (from Fourier analysis). A strong spoiler gradient is also added between the off-resonance MT-preparation pulse and the on-resonance excitation pulse in order to destroy residual transverse magnetization that may have been created by the off-resonance pulse. Images acquired without MT saturation are acquired using the same timing as this sequence, but with the off-resonance RF pulse either completely off or using a very large off-resonance frequency (e.g. ~30+ kHz).\n\n\n\nFigure¬†6.14:Simplified pulse sequence diagram of an MTR imaging sequence. An off-resonance and high powered MT-preparation pulse is followed by a spoiler gradient to destroy any transverse magnetization prior the application of the imaging sequence, in this case a spoiled gradient recalled echo (SPGR).\n\nIn the initial MTsat paper \n\nHelms et al., 2008\n\nHelms et al., 2010, the main innovation stems from a new model of the MT-weighted SPGR sequence shown in \n\nFigure 6.14. There, \n\nHelms et al., 2008 proposed to interpret the effects of the MT-preparation pulse as a second excitation RF pulse of an unknown flip angle. That is to say, they modeled the reduction of the longitudinal magnetization of the free pool due to the MT pulse to be the same reduction caused by the flip angle rotation of a second instantaneous excitation RF pulse. \n\nFigure 6.15   presents the Helms model, where to be consistent with the convention presented in mathematical derivations in \n\nHelms et al., 2008\n\nHelms et al., 2010, the order of the pulses are switched such that the readout excitation pulse comes first (\\alpha_{1}), and the excitation pulse modelling the effects of the MT pulse comes second (\\alpha_{2}). Note that, after a steady-state is reached, this order would not not impact the signal value during image readout.\n\n\n\nFigure¬†6.15  :Pulse sequence model used in MTSat to approximate the effects occurring in the actual MT-weighted sequence (\n\nFigure 6.14), but as a dual-excitation sequence. Note that the defined TR is shifted so that the beginning of the TR occurs at the excitation pulse, instead of the MT pulse as per \n\nFigure 6.14, which once a steady-state is established won‚Äôt impact the calculations.","type":"content","url":"/magnetization-transfer-imaging#mtsatintro","position":19},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Theory","lvl2":"Magnetization Transfer Saturation"},"type":"lvl3","url":"/magnetization-transfer-imaging#theory","position":20},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Theory","lvl2":"Magnetization Transfer Saturation"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nAs has been derived in many introductory MRI physics textbooks, the steady-state signal equation for a standard SPGR pulse sequence (that is, one excitation flip angle per entire TR) has been shown to be:S\\left( \\alpha,\\text{TR} \\right)=A\\text{sin}\\left( \\alpha \\right)\\frac{1-\\text{e}^{-R_{1}\\cdot \\text{TR}}}{1-\\text{cos}\\left( \\alpha \\right) \\text{e}^{-R_{1}\\text{TR}}}\n\nwhere A is some proportionality constant (e.g. gyromagnetic ratio, density, coil sensitivity, etc), …ë is the excitation flip angle, R1 = 1/T1 (assuming a monoexponential longitudinal relaxation curve), and TR is the repetition time. Similarly, an analytical equation for the steady-state signal of a dual-excitation SPGR experiment (\n\nFigure 6.15  ) can be derived, and \n\nHelms et al., 2008 demonstrated it to be:S\\left( \\alpha_{1},\\text{TR}_{1},\\alpha_{2},\\text{TR}_{2} \\right)=A\\text{sin}\\left( \\alpha _{1}\\right)\\frac{1-\\text{e}^{-R_{1}\\cdot \\text{TR}}-\\left( 1-\\text{cos}\\left( \\alpha_{2} \\right) \\right)\\cdot \\left[ 1- \\text{e}^{-R_{1}\\text{TR}_{1}}\\right]\\cdot \\text{e}^{-R_{1}\\text{TR}_{2}}}{1-\\text{cos}\\left( \\alpha_{1} \\right)\\text{cos}\\left( \\alpha_{2} \\right) \\text{e}^{-R_{1}\\text{TR}}}\n\nwhere \\alpha_{1} is the imaging excitation flip angle, \\alpha_{2} is the excitation flip angle representing the MT saturation pulse, TR1 is the time between \\alpha_{1} to \\alpha_{2}, TR2 is the time between \\alpha_{2} and the following \\alpha_{1}, and TR = TR1 + TR2.\n\nEq. 6.9 has three unknowns: A, R1, and \\alpha_{2}. Of these three, \\alpha_{2} is expected to be the most sensitive to macromolecular density via the MT effect, and as such is the parameter that we‚Äôd like to calculate or fit using this dual-excitation SPGR model for the MT-prepared SPGR pulse sequence. Although there would be some ways to acquire additional measurements (three unknowns, so at a minimum three measurements are needed) and apply a nonlinear fit to  \n\nEq. 6.9 to extract \\alpha_{2}, this method has a long numerical processing time. To shorten the calculation of the parameter maps, \n\nHelms et al., 2008\n\nHelms et al., 2010 (Helms et al. 2008, 2010) proposed some reasonable assumptions that can be made to simplify  \n\nEq. 6.9. The first proposed assumption is that R1TR << 1, which is true when using typical MT-weighted SPGR protocol parameters (TR ~ 0.01-0.05 s) and in the brain at clinical field strengths (T1 ~ 1 s, thus R1 ~ 1 s-1). The same approximation applies to TR1 and TR2, which are shorter than TR. This leads to the removal of all exponential functions in  \n\nEq. 6.9, as via the Taylor expansion of the exponential function, exp(x) ~ 1 + x when abs(x) << 1, and the removal of another term via R1TR1R1TR2 ~ 0 when R1TR1 and R1TR2 are both << 1. The simplifications result inS\\left( \\alpha_{1},\\text{TR}_{1},\\alpha_{2},\\text{TR}_{2} \\right)=A\\text{sin}\\left( \\alpha _{1}\\right)\\frac{R_{1}\\text{TR}-\\left( 1-\\text{cos}\\left( \\alpha_{2} \\right) \\right)\\cdot R_{1}\\cdot \\text{TR}_{1}}{1-\\text{cos}\\left( \\alpha_{1} \\right)\\text{cos}\\left( \\alpha_{2} \\right)R_{1}\\cdot \\text{TR}_{1}}\n\nThe second approximation is that \\alpha_{2} is small (less than 30 degrees), which is to say that the MT saturation is relatively small. This is expected to be true for the tissue properties of the brain (mostly, myelin), but care must be taken with the planned MT pulse parameters as the MT saturation increases with smaller offset frequency and high peak pulse amplitude. Later, we‚Äôll calculate if this is a reasonable assumption for the calculated \\alpha_{2}. This assumption is integrated into \n\nEq. 6.9 via the Taylor series expansion of the \\text{cos} \\left( \\alpha_{2} \\right), where \\text{cos} \\left( x \\right) \\approx 1-x^{2}/2 for small x (this relationship is true for x < 30 degrees or 0.5 radians). Introducing this approximation in [3] and with the additional simplifications \\alpha_{2}^{2}R1TR ~ 0 (from the assumptions above), this results inS\\left( \\alpha_{1},\\alpha_{2},\\text{TR} \\right)=A\\text{sin}\\left( \\alpha _{1}\\right)\\frac{R_{1}\\text{TR}}{1-\\text{cos}\\left( \\alpha_{1} \\right)+\\text{cos}\\left( \\alpha_{1} \\right) \\left(\\frac{\\alpha^{2}_{2}}{2} R_{1}\\cdot \\text{TR}_{1} \\right)}\n\nNote how the signal no longer has a dependency on the individual TR1 and TR2 values, but only on the full TR. The final approximation is isomorphic to the previous one, but for the imaging excitation RF pulse, that is to say, that \\alpha_{1} is small (less than 30 degrees). This is a controllable approximation, as it is a controllable protocol parameter at the scanner. From this assumption,  \\text{cos}\\left( \\alpha_{1} \\right) \\approx 1-\\alpha_{1}^{2}/2  and \\text{sin}\\left( \\alpha_{1} \\right) \\approx \\alpha_{1} (from the Taylor series expansion), so introducing both of these into \n\nEq. 6.11 and simplifying  \\approx \\alpha_{1}^{2} \\cdot R_{1} \\cdot \\text{TR} \\approx 0 and   \\approx \\alpha_{1}^{2} \\cdot \\alpha_{2}^{2} \\approx 0 leads toS\\left( \\alpha_{1},\\alpha_{2},\\text{TR} \\right)=A \\alpha _{1}\\frac{R_{1}\\text{TR}}{\\frac{\\alpha^{2}_{1}}{2}+\\frac{\\alpha^{2}_{2}}{2} +R_{1}\\cdot \\text{TR}_{1} }\n\nThe term \\alpha_{2}^{2}/2 is the only term that includes an MT effect in \n\nEq. 6.5, and thus will be defined as \\delta \\equiv \\alpha_{2}^{2}/2.S\\left( \\alpha_{1},\\alpha_{2},\\text{TR} \\right)=A \\alpha _{1}\\frac{R_{1}\\text{TR}}{\\frac{\\alpha^{2}_{1}}{2}+\\delta +R_{1}\\cdot \\text{TR}_{1} }\n\nFigure 6.16 demonstrates how Œ¥, which represents MTsat as was defined in \n\nHelms et al., 2008, is the fractional reduction in longitudinal magnetization after the MT pulse in the MTsat model illustrated in \n\nFigure 6.15   relative to the Mz prior to the pulse. Conventionally, MTsat (Œ¥) is reported in percentage, so \\text{MTsat} = \\delta \\cdot 100 .\n\n\n\nFigure¬†6.16:Demonstration through trigonometry of how following a small flip angle \\alpha_{2} (eg MT saturation), the value \\delta \\equiv \\alpha_{2}^{2}/2 represents the fraction of the reduction in longitudinal magnetization due to the pulse (bigDelta) relative to the value prior to the pulse (Mzbefore).\n\nBefore jumping into how to measure MTsat, let‚Äôs demonstrate some expected properties and values using known values from a simpler MTR experiment. From the MTR protocol in \n\nBrown et al., 2013 of the MTR section, \\alpha_{1}=15 deg and TR = 0.03 s, so assuming a T1 at 1.5T (field strength that Brown used) of 0.55 s in healthy WM, so R1 = 1.8. First off, \n\nFigure 6.16 with no MT pulse (thus Œ¥ = 0) should converge close to the well-known SPGR equation (\n\nEq. 6.8). Inputting the values in each equations, we get 0.0816A for [1], and 0.0815A, thus they are in close agreement. Next, we can get an estimated value of MTsat, using a known MTR value, the calculated S0 value (which we just did), and then solving [5] for Œ¥ using the MTR equation to bring everything together. Doing so is shown in \n\nAppendix A, from there and using our simulations in the MTR post with \n\nBrown et al., 2013 for healthier WM (MTR = 46%), we get an MTsat value of 4.92% (Œ¥ = 0.0492), which is close to some reported MTsat values in the literature (Karakuzu et al. 2022). From there, and by definition of Œ¥, the modeled \\alpha_{2} in \n\nFigure 6.15   for this example is 18 degrees, confirming that earlier assumption that \\alpha_{2} < 30 degrees for that approximation.\n\nIn that example, we used a known T1 value to extract MTsat using a two-measurement MTR experiment, but in practice this value is not known and varies per-pixel across tissues. Although we could use an additionally measured T1 map to do this, this can be time consuming depending on the method used. (Helms et al. 2008, 2010) thus demonstrated that with one additional T1w measurement that uses no MT preparation pulse but has different \\alpha_{1}/TR than the MTon (MTw) and MToff (PDw) measurements used for MTR, that MTsat can be calculated analytically, and as a bonus a T1 map is also calculated in the process. (This makes sense, as the VFA T1 mapping sequence is often just two SPGR measurements with different Œ± values). Thus, using this three measurement protocol (MTw/PDw/T1w, which we‚Äôll call the MTsat protocol), MTsat and T1 (1/R1) can be calculated analytically pixelwise using the following set of equations (derived from \n\nEq. 6.5):MTsat=\\left( A_{app}\\cdot \\frac{\\alpha_{MT}}{S_{MT}}-1 \\right)\\cdot R_{1}\\text{TR}_{\\text{MT}}-\\frac{\\alpha_{MT}^{2}}{2}A_{app}=S_{PD}S_{T_{1}}\\frac{\\text{TR}_{\\text{PD}}\\frac{\\alpha_{T_{1}}}{\\alpha_{PD}}-\\text{TR}_{T_{1}}\\frac{\\alpha_{PD}}{\\alpha_{T_{1}}}}{\\text{TR}_{\\text{PD}}S_{T_{1}}\\alpha_{T_{1}}-\\text{TR}_{T_{1}}S_{PD}\\alpha_{PD}}R_{1}=\\frac{1}{2}\\cdot \\frac{\\frac{S_{T_{1}}\\alpha_{T_{1}}}{\\text{TR}_{T_{1}}}-\\frac{S_{PD}\\alpha_{PD}}{\\text{TR}_{PD}}}{\\frac{S_{PD}}{\\alpha_{PD}}-\\frac{S_{T_{1}}}{\\alpha_{T_{1}}}}\n\nRemember, like MTR, MTsat is calculated from the equations above following the acquisition of the protocol images; no numerical fitting to a model is required. So effectively, the processing time to produce MTsat maps is the same as MTR, which is nearly instantaneous. Also, unlike MTR, which represents the steady-state signal difference due to the MT effect, MTsat represents the fraction of the longitudinal magnetization saturation caused by a single MT pulse within a TR, after a steady-state is achieved. Conventionally, it is represented as a percentage %, so MTsat is typically reported as \\delta \\cdot 100. Note that MTR and MTsat are not expected to have the same values in magnitude despite both being represented as %, as they represent different changes. A major benefit of MTsat is that it‚Äôs expected to have less T1-dependency than MTR, as T1 (1/R1) is separately calculated and accounted for in the calculation of MTsat using the equations above. Although the MTsat metric is more robust against T1 changes, it is inherently sensitive to the MT preparation pulse properties (due to what MTsat physically represents, which is the saturation due to the MT pulse), and thus MTsat is not truly considered a fully quantitative metric as its value will change depending on the chosen protocol parameters and is not solely specific to the tissue properties or the field properties. \n\nTable¬†6.4 lists some MTsat protocol parameters that have been reported in the literature.\n\nTable¬†6.4 :Some reported MTsat protocol parameters in the scientific literature (sources: \n\nHelms et al., 2008\n\nWeiskopf et al., 2013\n\nCampbell et al., 2018\n\nKarakuzu et al., 2022\n\nYork et al., 2022)\n\n\n\nHelms 2008\n\nWeiskopf 2013\n\nCampbell 2018\n\nKarakuzu 2022\n\nYork 2022\n\n\n\nSiemens\n\nSiemens\n\nSiemens\n\nGE\n\nSiemens\n\nSiemens\n\nT1w\n\nFA\n\n15\n\n20\n\n15\n\n20\n\n20\n\n18\n\nTR (ms)\n\n11\n\n18.7\n\n11\n\n18\n\n18\n\n15\n\nTE (ms)\n\n4.92\n\n2.2‚Äì14.7\n\n-\n\n4\n\n4\n\n1.54/4.55/8.49\n\nPDw\n\nFA\n\n5\n\n6\n\n5\n\n6\n\n6\n\n5\n\nTR (ms)\n\n25\n\n23.7\n\n30\n\n32\n\n32\n\n30\n\nTE (ms)\n\n4.92\n\n2.2‚Äì14.7\n\n-\n\n4\n\n4\n\n1.54/4.55/8.49\n\nMTw\n\nFA\n\n5\n\n6\n\n5\n\n6\n\n6\n\n5\n\nTR (ms)\n\n25\n\n23.7\n\n30\n\n32\n\n32\n\n30\n\nTE (ms)\n\n4.92\n\n2.2‚Äì14.7\n\n-\n\n4\n\n4\n\n1.54/4.55/8.49\n\nOffset (Hz)\n\n2200\n\n2000\n\n2200\n\n1200\n\n1200\n\n1200\n\nMT pulse shape\n\nGaussian\n\nGaussian\n\n-\n\nFermi\n\nGaussian\n\nGaussian\n\nMT pulse length (ms)\n\n12.8\n\n4\n\n-\n\n8\n\n10\n\n9.984\n\nMT pulse angle (deg)\n\n540\n\n220\n\n540\n\n540\n\n540\n\n500","type":"content","url":"/magnetization-transfer-imaging#theory","position":21},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Simulations","lvl2":"Magnetization Transfer Saturation"},"type":"lvl3","url":"/magnetization-transfer-imaging#simulations","position":22},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Simulations","lvl2":"Magnetization Transfer Saturation"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nIn line with our previous MTR blog post, we employ the qMRLab qMT simulations to model MTsat measurements and subsequently calculate MTsat values from \n\nEq. 6.7, \n\nEq. 6.8, and \n\nEq. 6.9. \n\nTable¬†6.5 lists the essential tissue parameters used for the simulations. \n\nFigure 6.17 plots the MTsat values that have been calculated for each protocol outlined in \n\nTable¬†6.4 , while also incorporating the relevant tissue parameters found in \n\nTable¬†6.5.\n\nTable¬†6.5:Quantitative MT parameters in healthy and diseased human tissue reported for a study at 1.5 T \n\nSled & Pike, 2001.\n\n\n\nHealthy cortical GM\n\nHealthy WM\n\nNAWM\n\nEarly WM MS lesion\n\nLate WM MS lesion\n\nF\n\n0.072 ¬± 0.013\n\n0.161 ¬± 0.025\n\n0.15 ¬± 0.02\n\n0.12 ¬± 0.02\n\n0.094 ¬± 0.015\n\nkf\n\n2.4 ¬± 0.013\n\n4.3 ¬± 1.0\n\n4.9 ¬± 1.3\n\n3.6 ¬± 0.8\n\n2.7 ¬± 0.7\n\nR1,f (s-1)\n\n0.93 ¬± 0.2\n\n1.8 ¬± 0.3\n\n1.78 ¬± 0.4\n\n1.52 ¬± 0.2\n\n1.26 ¬± 0.3\n\nR1,r (s-1)\n\n1\n\n1\n\n1\n\n1\n\n1\n\nT2,f (ms)\n\n56 ¬± 8\n\n37 ¬± 8\n\n38 ¬± 7\n\n43 ¬± 6\n\n52 ¬± 9\n\nT2,r (Œºs)\n\n11.1 ¬± 8\n\n12.3 ¬± 1.6\n\n11.4 ¬± 1.4\n\n10.3 ¬± 1.1\n\n10.9 ¬± 1.4\n\n\n\nFigure¬†6.17:MTsat values calculated from fundamental qMT tissue parameters for four different MTR imaging protocols.\n\nIt‚Äôs worth noting that MTsat values show a relatively wider range in values across protocols and tissue types (1% to 7%) when compared against our similar simulations for MTR (30%-60%). Additionally, note the change in order of magnitude of the values between MTsat (~5%) and MTR (~50%). As is demonstrated in the simulations above, MTsat values can be quite similar in both healthy and diseased tissues if different imaging protocols are used. So, for practical purposes, it‚Äôs recommended to use and compare MTsat values that were measured using a consistent imaging protocol (which, due to some proprietary pulse sequence designs, means that consistency will be best when using the same MRI vendor and version for the study). Nevertheless, some normalization techniques have been developed to make MTsat more useful in broader contexts.\n\nTo assess the relationship between MTsat and T1, we conducted simulations by varying T1 values as inputs for a specific protocol. In \n\nFigure 6.18, we present the resulting data, which includes calculated MTR (based on MT-on and PDw measurements), MTsat, and T1,meas values. As observed previously, MTR exhibits a high sensitivity to alterations in the tissue T1 values. Notably, the calculated T1 values closely mirror the input T1 values, evident in the identity line on the graph. MTsat shows minimal sensitivity to changes in T1, as even a ¬±30% variation in T1 values corresponds to only around a ¬±2% fluctuation in MTsat values.\n\n\n\nFigure¬†6.18:MTR/T1,meas/MTsat vs T1 values\n\nSimilarly, we can investigate the sensitivity of MTsat to B1, which varies substantially in the scanner at magnetic field strengths of 3T and above. In the human brain, B1 typically fluctuates the nominal flip angles within a range of -30% to 10% (Boudreau et al. 2017). \n\nFigure 6.19 displays the calculated MTR, MTsat, and T1 values using a range of B1 values +-30% to both the excitation and MT pulses. All three parameters demonstrate high sensitivity to changes in B1. Notably, while T1 is relatively insensitive to minor magnetic field variations, the calculated T1 values may deviate from accuracy. In contrast, the calculated MTsat inherently reflects the actual saturation induced by the MT pulse, which is directly proportional to B1. This relationship is expected since lower B1 values result in lower true MTsat values, which is particularly relevant when attempting to use MTsat as a biomarker for myelin content. To address this issue, an empirical equation \n\nWeiskopf et al., 2013 has been introduced to estimate the MTsat value that would have been measured if B1 values had been uniform across the brain, although it‚Äôs essential to emphasize that this is not a representation of the actual MTsat values the tissue experiences, but a means to standardize MTsat even in the presence of inhomogeneous B1 maps if/when RF transmit shimming isn‚Äôt done.\n\n\n\nFigure¬†6.19:MTR/T1,meas/MTsat vs B1 values. Click button to compare values with or without B1-correction","type":"content","url":"/magnetization-transfer-imaging#simulations","position":23},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Appendix A"},"type":"lvl2","url":"/magnetization-transfer-imaging#mtrappendixa","position":24},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Appendix A"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nIn reality, what is conserved and transferred during an MT experiment, is energy, and this energy is exhibited as non-zero magnetization under the correct conditions. \n\nFigure 6A-1   illustrates this. As is known from MR theory, the net magnetization of a population of spins at thermal equilibrium is a result of an excess (on the order of 10 ppm at 3T) of spins in the low energy level (spins aligned with the magnetic field) relative to the high energy level (spins anti-parallel to the magnetic field), with the energy level splitting (a) being due the nuclear Zeeman effect and for the free pool, has an difference E of \\gamma h B_{0} (i.e. the energy corresponding to the resonance frequency, h being the Planck constant). By applying an off-resonance frequency RF pulse (Œî), we can selectively transfer energy from the electromagnetic field to the restricted pool system such that some spins will jump from the low energy level to the high energy level (RF pumping, b), leaving the free pool undisturbed. This excess in energy that is now in the restricted pool spin population will then redistribute itself through several physical processes to reach a new system-wide equilibrium, such as energy transfer into heat through collisions, or spin exchange free pool spins through dipolar coupling or chemical exchange (\n\nFigure 6A-1a). This energy transferred to the free pool is represented by a slight reduction in the net magnetization of the free pool, which manifests as a decrease in the observed MR signal. This signal reduction occurs because the energy absorbed by the restricted pool (via the off-resonance RF pulse) results in fewer spins in the low-energy state in the free pool, thus reducing its longitudinal magnetization. Over time, the system will reach a new equilibrium state, where the magnetization of both the restricted and free pools reflects this redistributed energy.\n\nIn \n\nFigure 6A-1c (right), the new equilibrium state of the magnetization is shown, highlighting how the energy transfer process affects the magnetization of the free pool and, consequently, the overall MR signal. This phenomenon is central to magnetization transfer (MT) imaging, where the contrast in images is derived from the differences in energy transfer between different tissue types. The degree of MT contrast is influenced by factors such as the efficiency of energy transfer processes and the specific properties of the tissue, including the concentration and exchange rates of the restricted pool.\n\nUltimately, the conservation of energy and its transfer between different spin populations is what underlies the observable effects in MT imaging, allowing it to be used as a tool to probe tissue microstructure and composition.\n\n\n\nFigure¬†6A-1  :Thesis figure","type":"content","url":"/magnetization-transfer-imaging#mtrappendixa","position":25},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Appendix B"},"type":"lvl2","url":"/magnetization-transfer-imaging#mtsatappendixa","position":26},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Appendix B"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.","type":"content","url":"/magnetization-transfer-imaging#mtsatappendixa","position":27},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Derivation","lvl2":"Appendix B"},"type":"lvl3","url":"/magnetization-transfer-imaging#derivation","position":28},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Derivation","lvl2":"Appendix B"},"content":"From the MTR protocol in \n\nBrown et al., 2013 of the MTR section, \\alpha_{1}=15 deg and TR = 0.03 s, so assuming a T1 at 1.5T (field strength that Brown used) of 0.55 s in healthy WM, so R1 = 1.8, we can calculate the signal from \n\nEq. 6.6 of an experiment with no MT pulse (\\alpha_{2} = 0).\\\\\nS_{0}=0.087\\frac{\\left(1.8\\cdot 0.03\\right)}{\\frac{0.087^{2}}{2}+0+1.8\\cdot 0.03}AS_{0}=0.0815A\n\nFor an MT-weighted image, we get an equation as we don‚Äôt know \\alpha_{2},S_{MT}=0.087\\frac{\\left(1.8\\cdot 0.03\\right)}{\\frac{0.087^{2}}{2}+\\frac{\\alpha_{2}^{2}}{2}+1.8\\cdot 0.03}AS_{MT}=\\frac{0.0047}{0.0578+\\frac{\\alpha_{2}^{2}}{2}}A\n\nTo simplify (and for reasons seen later), let‚Äôs define \\delta=\\alpha_{2}^{2}/2,S_{MT}=\\frac{0.0047}{0.0578+\\delta}A\n\nWe‚Äôd like to calculate the contribution from the MT pulse, Œ¥. We can do this by using the measured MTR value for this protocol, which we simulated for in the previous blog post and found to be ~0.46. We can now use the MTR equation and substitute the S0 and SMT, and the solve for Œ¥.\\text{MTR}=\\frac{\\left(S_{0}-S_{MT}\\right)}{S_{0}}\\cdot 10046=\\frac{\\left(0.0815A-S_{MT}\\right)}{0.0815A}\\cdot 100 \\text{, (from 6A1)}S_{MT}=0.044A\\text{, (refactor)} \\\\\\left(\\frac{0.0047}{0.0578+\\delta}\\right)A=0.044A\\text{, (from 6A3)}\\frac{\\left(0.0047\\right)}{\\left(0.0578+\\delta\\right)}=0.044\\text{, (A cancels out)}\\delta=\\left(\\frac{0.0047}{0.044}\\right)-0.0578\\text{, (refactor)}\\delta=0.049","type":"content","url":"/magnetization-transfer-imaging#derivation","position":29},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Appendix C"},"type":"lvl2","url":"/magnetization-transfer-imaging#appendix-c","position":30},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Appendix C"},"content":"Attention\n\nThis content of this section is still a work-in-progress and has not been proofread and/or reviewed.\n\nSo far we‚Äôve explored a lot of the practical properties of MTsat, but have yet to explore what this parameter represents in reality. We begin this discussion by looking at how \n\nHelms et al., 2008 interpreted MTsat:\n\n(figure or quote)\n\nThus, MTsat is interpreted as being the saturation (i.e. reduction in longitudinal magnetization) occurring from the pulse substituting the MT pulse (\n\nFigure 6.15  ) occurring within a single TR, after steady-state has been reached. A reminder: MTR, in contrast, is a steady-state image difference metric (not ‚Äúwithin‚Äù a TR).","type":"content","url":"/magnetization-transfer-imaging#appendix-c","position":31},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl3","url":"/magnetization-transfer-imaging#simulating-mtsat-through-qmrlab","position":32},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"To assess the validity of this MTsat interpretation, we employ Bloch simulations via qMRLab. These simulations should allow us to visualize the ‚ÄúMTSat value‚Äù both as it approaches and after reaching steady-state by quantifying the difference in longitudinal magnetization before and after the MT pulse. The main question we have is: can we find the MT saturation (Œ¥) value directly using Bloch simulations, and how close does it approach the calculated MT saturation value from a three-measurement experiment (equations 7-9)?\n\nUsing some high-school geometry, we see how we can calculate MTsat (delta) from this difference, assuming (as Helms did) that the MT saturation causes a flip of a specific angle.\n\n\n\nFigure¬†6A.1:Demonstration through trigonometry of how following a small flip angle alpha2 (eg MT saturation), the value \\delta \\equiv \\alpha_{2}^{2}/2 represents the fraction of the reduction in longitudinal magnetization due to the pulse (bigDelta) relative to the value prior to the pulse (Mzbefore).","type":"content","url":"/magnetization-transfer-imaging#simulating-mtsat-through-qmrlab","position":33},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 1: Revisiting MTsat Theory","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl4","url":"/magnetization-transfer-imaging#simulation-1-revisiting-mtsat-theory","position":34},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 1: Revisiting MTsat Theory","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"In our first simulation, we use the qMRLab qMT-SPGR module to simulate steady-state signals from an MTsat experiment on healthy white matter tissues. We utilize tissue parameters from \n\nSled & Pike, 2001 and an MTsat protocol derived from \n\nKarakuzu et al., 2022.\n\nCode\nclear all, close all, clc\n \n%% Load protocol\n \nfname = 'configs/mtsat-protocols.json';\nfid = fopen(fname);\nraw = fread(fid,inf);\nstr = char(raw');\nfclose(fid);\nval = loadjson(str);\n \nprotocols = val.karakuzu2022.siemens1\n \n%% Load tissues\n \nfname = 'configs/tissues.json';\nfid = fopen(fname);\nraw = fread(fid,inf);\nstr = char(raw');\nfclose(fid);\nval = loadjson(str);\n \ntissue = val.sled2001.healthywhitematter;\n \n%% T1 range\n \nT1_true = 1\n \n%% qMT-SPGR experiment\n \nMTsats = zeros(1,length(T1_true))\nMTRs = zeros(1,length(T1_true))\nT1s = zeros(1,length(T1_true))\n \n \nprotocol = protocols.pdw\n \nfa = protocol.fa\ntr = protocol.tr/1000\nte = protocol.te/1000\noffset = protocol.offset\nmt_shape = protocol.mtshape\nmt_duration = protocol.mtduration/1000\nmt_angle = protocol.mtangle\n \nModel = qmt_spgr;\nModel.Prot.MTdata.Mat = [mt_angle, offset];\nModel.Prot.TimingTable.Mat(5) = tr ;\nModel.Prot.TimingTable.Mat(1) = mt_duration;\nModel.Prot.TimingTable.Mat(4) = Model.Prot.TimingTable.Mat(5) - (Model.Prot.TimingTable.Mat(1) + Model.Prot.TimingTable.Mat(2) + Model.Prot.TimingTable.Mat(3)) ;\nModel.options.Readpulsealpha = fa;\nModel.options.MT_Pulse_Shape = mt_shape\n \nparams = tissue{1}\nx = struct;\nx.F = params.F.mean;\nx.kr = params.kf.mean / x.F;\nx.R1f = 1/T1_true;\nx.R1r = 1;\nx.T2f = params.T2f.mean/1000;\nx.T2r = params.T2r.mean/(10^6);\n \nOpt.SNR = 1000;\nOpt.Method = 'Bloch sim';\nOpt.ResetMz = false;\n \n[FitResult, Smodel] = Model.Sim_Single_Voxel_Curve(x,Opt); % NOTE: this uses a modified version of the qmt_spgr.m file where the additional output is included. Not all version of qMRLab has this; if yours doesn't, go to the file and add the additional function output accordingly.\n \n%% Cleanup\n \n%Smodel is the normalized MT-SPGR value, that is, the signal with the MT\n%pulse on divided by the signal from the same sequence with the MT pulse\n%off. Since in the MTsat experiment, the PD-weighted pulse sequence is the\n%latter case above, we then define:\n \nSignal_MT = Smodel;\nSignal_PDw = 1;\n \n%% Find scaling value for T1w signal\n \n \n% Get PDw/T1w ratio from analytical\n \nPDw_Model = vfa_t1;\n \nparams.EXC_FA = protocols.pdw.fa;\nparams.T1 = T1_true; % Could improve by caclulating T1meas from qMT values\nparams.TR = protocols.pdw.tr/1000; % ms\n \nPDw_anal = vfa_t1.analytical_solution(params);\n \nT1w_Model = vfa_t1;\n \nparamsT1w.EXC_FA = protocols.t1w.fa;\nparamsT1w.T1 = T1_true; % ms\nparamsT1w.TR = protocols.t1w.tr/1000; % ms\n \nT1w_anal = vfa_t1.analytical_solution(paramsT1w);\n \nT1wPDw_ratio = T1w_anal/PDw_anal\n \n%% Cleanup\n \n% Since Signal_PDw = 1, then it's clear that \n \nSignal_T1w = T1wPDw_ratio\n \n%% Calculate MTsat from signals\n \nModel = mt_sat;\nFlipAngle =  protocols.pdw.fa;\nTR =  protocols.pdw.tr/1000;\nModel.Prot.MTw.Mat = [ FlipAngle TR ];\nFlipAngle = protocols.t1w.fa;\nTR =  protocols.t1w.tr/1000;\nModel.Prot.T1w.Mat = [ FlipAngle TR];\nFlipAngle =  protocols.pdw.fa;\nTR =  protocols.pdw.tr/1000;\nModel.Prot.PDw.Mat = [ FlipAngle TR];\n \ndata = struct();\ndata.MTw=Signal_MT;\ndata.T1w=Signal_T1w;\ndata.PDw=Signal_PDw;\nFitResults = FitData(data,Model,0);\nMTsats = FitResults.MTSAT\nMTRs = FitResults.MTR\nT1s = FitResults.T1\n\n\nOutput\nMTsats =\n\n    5.3428\n\n\nMTRs =\n\n   58.9758\n\n\nT1s =\n\n    1.0100\n\n\n\nOur results closely align with expectations (T1 fitted ~= T1 input, MTR ~58, MTsat ~5%). Converting the MTsat value to …ë2 (see [#mtsatFig3]), we find that the MTSat value corresponds to an equivalent excitation pulse of approximately 18.7 degrees. Through Helms‚Äô interpretation, we infer that the MT pulse should be reducing the longitudinal magnetization by roughly 0.05 (ie Mz_after pulse - Mz_before pulse = 0.05).","type":"content","url":"/magnetization-transfer-imaging#simulation-1-revisiting-mtsat-theory","position":35},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 2: Challenging MTSat Model Assumptions","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl4","url":"/magnetization-transfer-imaging#simulation-2-challenging-mtsat-model-assumptions","position":36},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 2: Challenging MTSat Model Assumptions","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"Using the qMRLab Bloch simulations, we can calculate the difference in longitudinal magnetization before and after the MT pulse, and see if this corresponds to the MTsat value calculated above.\n\nLet‚Äôs do that.\n\nCode\n\nSome modifications of the qMRLab code are needed to output the before/after magnetizations into a file.\nclear all, close all, clc\n \n%% Load Mz before and after for each TR\n \nload('sim2.mat')\n \n%% Plot Mz before and after for each TR\n \nfigure()\nplot(Mz_before, 'r')\nhold on\nplot(Mz_after, 'b')\nlegend('Mz_{before}', 'Mz_{after}')\n \nfigure()\nplot(Mz_before(end-10+1:end), 'r')\nhold on\nplot(Mz_after(end-10+1:end), 'b')\nlegend('Mz_{before}', 'Mz_{after}')\n \nfigure()\nplot(1-Mz_after./Mz_before)\nlegend('1-Mz_{after}/Mz_{before}')\n \nfigure()\nplot((1-Mz_after./Mz_before)*100)\nlegend('1-Mz_{after}/Mz_{before}')\n\n\n\n\nFrom these simulations, we find that there is a 0.314% reduction in longitudinal magnetization before/after the MT pulse after a steady state is achieved, which is an order of magnitude smaller than the MTsat value we calculated earlier for this protocol and tissue parameters (~5%). Either the MTsat theory is wrong, or we‚Äôre missing something. Revisiting the pulse sequence ([#mtsatFig1]) and the MTsat model ([#mtsatFig2]), we notice that while the MTsat model assumes instant excitation for both pulses, in reality the MT pulse is relatively long (~10 ms, [#mtsatProtocolTable]). So, while there is a decoupling between MT saturation and relaxation in the MTsat model ([#mtsatFig2]), in reality (and in our simulations) there is relaxation occurring during the MT pulse, and we didn‚Äôt account for that in the above simulation.","type":"content","url":"/magnetization-transfer-imaging#simulation-2-challenging-mtsat-model-assumptions","position":37},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 3: T1 Correction During MT Pulse","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl4","url":"/magnetization-transfer-imaging#simulation-3-t1-correction-during-mt-pulse","position":38},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 3: T1 Correction During MT Pulse","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"In our third simulation, we account for the T1 relaxation during the MT pulse. To simplify the calculations, and like Helms did, we‚Äôll assume a decoupling between the MTsaturation and relaxation and calculate the T1 relaxation recovery independently for the duration of the MT pulse. We‚Äôll then remove this contribution from the Mzafter-Mzbefore we calculated earlier (0.314%).\n\nCode\n\nSome modifications of the qMRLab code are needed to output the before/after magnetizations into a file.\n\nclear all, close all, clc\n \n%% Load Mz before and after for each TR\n \nload('sim2.mat')\n \n%% Plot Mz before and after for each TR\n \nfigure()\n \nfigure()\nplot((1-Mz_after./Mz_before)*100)\nhold on\nplot((1-(Mz_after-delta_Mz_T1relax)./Mz_before)*100)\n \nlegend('MTsat before T1 correction', 'MTsat after T1 correction')\n \nfigure()\nplot((1-(Mz_after-delta_Mz_T1relax)./Mz_before)*100)\nlegend('1-Mz_{after}/Mz_{before}')\n\n\n\n\nUpon excluding the T1 contribution, the disparity Œî in Mz values prior to and following the MT pulse increased to 2.1%, which is to say, that the MT contribution of this pulse leads to a reduction of Mz by 2.1%. This outcome aligns with the expected behavior, as T1 relaxation perpetually seeks to increase longitudinal magnetization towards its equilibrium value, which inversely impacts Œî. Consequently, the Œî we just calculated within a given TR is now closer to the initial MTsat calculation based on simulated measurements (2.1% compared to 5.34%). Nevertheless, it is apparent that some critical element eludes our simulations since we‚Äôve only calculated only half of the anticipated value using our Bloch simulations.","type":"content","url":"/magnetization-transfer-imaging#simulation-3-t1-correction-during-mt-pulse","position":39},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Considering Exchange and Relaxation after the MT Pulse","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl4","url":"/magnetization-transfer-imaging#considering-exchange-and-relaxation-after-the-mt-pulse","position":40},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Considering Exchange and Relaxation after the MT Pulse","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"Once again, let‚Äôs compare the actual pulse sequence (\n\nFigure 6.14) and the Helms model (\n\nFigure 6.15  . In the MTsat model, all of the magnetization exchange contribution is concentrated into the second instantaneous excitation-saturation pulse \\alpha^{2}. In the actual pulse sequence and in our Bloch simulations (\n\nFigure 6.14), there is exchange during the MT pulse (which we‚Äôve calculated above), but also when the MT pulse is off (because the longitudinal free and restricted magnetizations are not at equilibrium - see Bloch-McConnell equations in our qMT blog post). So, it‚Äôs likely that the contribution of MT when the off-resonance pulse is off also needs to be accounted for, if we want to calculate the MTsat value directly within a TR in Bloch simulations. This additional MT exchange between the restricted and free pool likely causes a reduction in longitudinal free relaxation which is encapsulated in the MTsat value (which makes sense, from the diagrams of the two-pool model of MT).","type":"content","url":"/magnetization-transfer-imaging#considering-exchange-and-relaxation-after-the-mt-pulse","position":41},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 3: MT contribution after the off-resonance pulse","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl4","url":"/magnetization-transfer-imaging#simulation-3-mt-contribution-after-the-off-resonance-pulse","position":42},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Simulation 3: MT contribution after the off-resonance pulse","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"To calculate this second contribution, we will calculate the difference in Mz between the end of the MT pulse and the end of TR (just prior to the next MT pulse), and just like we did earlier, we‚Äôll also subtract the T1 component (assuming that MT and T1 are decoupled during this time). Note that MTsat is the reduction in magnetization relative to its value prior to the MT pulse, so we need to normalize this contribution by the initial Mz (the same one we used for the MT pulse contribution, at the start of TR). Appendix C extends the diagram from Figure 8 to include the MT contribution after the MT pulse, and although more complex, it demonstrates the need for the note in the previous sentence.\n\nCode\n\nSome modifications of the qMRLab code are needed to output the before/after magnetizations into a file.\nclear all, close all, clc\n \n%% Load Mz before and after for each TR\n \nload('sim2.mat')\n \n%% Plot Mz before and after for each TR\n \nfigure()\n \nfigure()\nplot((1-(Mz_after-delta_Mz_T1relax)./Mz_before)*100)\n \nhold on\nplot((1-(M0_remainingTR_free-delta_Mz_T1relax_remaining)./Mz_before)*100)\nplot((1-(Mz_after-delta_Mz_T1relax)./Mz_before)*100+(1-(M0_remainingTR_free-delta_Mz_T1relax_remaining)./Mz_before)*100)\n \nlegend('MTsat contribution from MT pulse event', 'MTsat contribution from cross-relaxation event', 'Total MTsat for TR')\n\n\n\n\nThese simulations show through Bloch simulations that the sum of the MT contribution during and after the off-resonance pulse (with the T1 relaxation component removed) leads to a reduction in longitudinal magnetization of 5.49%, very close to the 5.34% that was calculated using the Helms model of MTsat in \n\nEq. 6.7, \n\nEq. 6.8, and \n\nEq. 6.9. A slight overestimate still remains, but this difference is likely impossible to consolidate, as there will always be a difference between the actual MT exchange (where both MT and T1 are counteracting each other at all times) and the modeled MTsat exchange (where instantaneous pulses are assumed, so the MT and T1 contribution are completely separated in this theory).These simulations should however show that the MTsat contribution is not restricted to only the difference in Mz resulting after the effects of the MT pulse, but also to the cross-relaxation occurring between pools in the absence of the MT pulse.","type":"content","url":"/magnetization-transfer-imaging#simulation-3-mt-contribution-after-the-off-resonance-pulse","position":43},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Interpreting MTSat","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"type":"lvl4","url":"/magnetization-transfer-imaging#interpreting-mtsat","position":44},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl4":"Interpreting MTSat","lvl3":"Simulating MTSat through qMRLab","lvl2":"Appendix C"},"content":"In conclusion, our reevaluation of MTSat suggests that it does not model solely the fractional saturation due to the MT pulse within a single TR, as conventionally understood. Instead, MTsat appears to represent the fractional saturation arising from the entire MT contribution during a TR, that is to say, both the MT pulse and the subsequent MT exchange between the two pools that takes place after following the off-resonance pulse. This subtle reinterpretation may challenge existing interpretations, as a greater contribution results from the exchange after the MT preparation pulse due to cross-relaxation caused by the perturbing MT pulse. This analysis highlights the power of open-source qMRI tools like qMRLab in fostering deeper understanding within the field.\n\nThrough a meticulous examination of MTSat, we encourage the scientific community to engage in further discussions and research, potentially leading to more refined models and insights into this crucial aspect of MRI physics in modelling tissue components that are difficult to measure directly, such as the semi-solid myelin sheets.","type":"content","url":"/magnetization-transfer-imaging#interpreting-mtsat","position":45},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Exercises"},"type":"lvl2","url":"/magnetization-transfer-imaging#exercises","position":46},{"hierarchy":{"lvl1":"Magnetization Transfer","lvl2":"Exercises"},"content":"Using \n\nFigure 4.4, calculate the MTR values for each measurement of the z-spectrum.\n\nUsing qMRlab, compute the MTR values (using the Brown 2013 Siemens protocol) for the following tissue parameters:\n\nF = 0.0\n\nkf = 5.0\n\nT1,f = 1200 ms\n\nR1,r = 1 s\n\nT2,f = 100 ms\n\nT2,r = 10 microseconds\n\nUsing qMRlab, compute the MTR values (using the Brown 2013 Siemens protocol) for the following tissue parameters:\n\nF = 10.0\n\nkf = 5.0\n\nT1,f = 1200 ms\n\nR1,r = 1 s\n\nT2,f = 100 ms\n\nT2,r = 10 microseconds\n\nUsing qMRlab, compute the MTR values (using the Brown 2013 Siemens protocol) for the following tissue parameters:\n\nF = 20.0\n\nkf = 5.0\n\nT1,f = 1200 ms\n\nR1,r = 1 s\n\nT2,f = 100 ms\n\nT2,r = 10 microseconds\n\nUsing qMRlab, compute the MTR values (using the Brown 2013 Siemens protocol) for the following tissue parameters:\n\nF = 20.0\n\nkf = 2.50\n\nT1,f = 1200 ms\n\nR1,r = 1 s\n\nT2,f = 100 ms\n\nT2,r = 10 microseconds\n\nUsing qMRlab, compute the MTR values (using the Brown 2013 Siemens protocol) for the following tissue parameters:\n\nF = 20.0\n\nkf = 0\n\nT1,f = 1200 ms\n\nR1,r = 1 s\n\nT2,f = 100 ms\n\nT2,r = 10 microseconds\n\nReflect and provide observations on the previous 5 exercises.","type":"content","url":"/magnetization-transfer-imaging#exercises","position":47},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-1-1","position":0},{"hierarchy":{"lvl1":""},"content":"import matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\nimport os\nimport markdown\nimport random\nfrom scipy.integrate import quad\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef integrand(x, delta, t_2r):\n\n    return (1/abs(3*x**2 - 1))*np.exp(-2*((2*np.pi*delta*t_2r)/(3*x**2 - 1))**2)\n\ninit_notebook_mode(connected=True)\n\ndelta = np.arange(-8000,8100,100) # in Hz\nt_2r = np.arange(6e-6,24e-6,2e-6) # in s\nG_gaussian = np.zeros((len(delta),len(t_2r)+1))\nG_lor = np.zeros((len(delta),len(t_2r)+1))\nG_superlor = np.zeros((len(delta),len(t_2r)+1))\n\nG_gaussian[:,0] = delta\nG_lor[:,0] = delta\nG_superlor[:,0] = delta\n\nfor ii in range(len(t_2r)):\n    for jj in range(len(delta)):\n        G_gaussian[jj,ii+1] = (t_2r[ii]/np.sqrt(2*np.pi))*np.exp(-(2*np.pi*delta[jj]*t_2r[ii])**2/2)\n        \n        G_lor[jj,ii+1] = (t_2r[ii]/np.pi)*1/(1+((2*np.pi*delta[jj]*t_2r[ii])**2))\n        \n        integral = quad(integrand, 0, 1, args=(delta[jj],t_2r[ii]))\n        G_superlor[jj,ii+1] = (t_2r[ii])*(np.sqrt(2/np.pi))*integral[0]\n\n\ninit_notebook_mode(connected=True)\n\nlineshape1 = [dict(\n        visible = False,\n        x = G_gaussian[:,0],\n        y = G_gaussian[:,ii+1],\n        line = dict(color = \"firebrick\"),\n        name = 'Gaussian',\n        hovertemplate = 'Gaussian, G(\\u0394,T<sub>2r</sub>) = %{y}<br>Frequency offset = %{x} Hz<extra></extra>') for ii in range(len(t_2r))]\n\nlineshape1[4]['visible'] = True\n\nlineshape2 = [dict(\n        visible = False,\n        x = G_lor[:,0],\n        y = G_lor[:,ii+1],\n        line = dict(color = \"royalblue\"),\n        name = 'Lorentzian',\n        hovertemplate = 'Lorentzian, G(\\u0394,T<sub>2r</sub>) = %{y}<br>Frequency offset = %{x} Hz<extra></extra>') for ii in range(len(t_2r))]\n\nlineshape2[4]['visible'] = True\n\nlineshape3 = [dict(\n        visible = False,\n        x = G_superlor[:,0],\n        y = G_superlor[:,ii+1],\n        line = dict(color = \"orange\"),\n        name = 'Super Lorentzian',\n        hovertemplate = 'Super Lorentzian, G(\\u0394,T<sub>2r</sub>) = %{y}<br>Frequency offset = %{x} Hz<extra></extra>') for ii in range(len(t_2r))]\n\nlineshape3[4]['visible'] = True\n\ndata = lineshape1 + lineshape2 + lineshape3\n\nsteps = []\nfor i in range(len(t_2r)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(lineshape1)],\n        label = str(round(t_2r[i], 7))\n    )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.0,\n    active = 3,\n    currentvalue = {\"prefix\": \"T<sub>2r</sub>: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    plot_bgcolor='rgba(0,0,0,0)',\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=120,\n        r=80,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.2,\n            showarrow=False,\n            text='Frequency offset \\u0394 (Hz)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.2,\n            y=0.5,\n            showarrow=False,\n            text='Absorption lineshape G(\\u0394,T<sub>2r</sub>)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        range=[-8000, 8000],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=True,\n        type=\"log\",\n        dtick=1,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.7,\n        y=0.85,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)","type":"content","url":"/figure-6-1-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-1-2","position":0},{"hierarchy":{"lvl1":""},"content":"import scipy\nimport scipy.io as sio\nfrom pathlib import Path\nimport numpy as np\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-01-qMT\"\n\n# Simulations have been performed and the results have been saved in the folder results.\ndataSim_lineshape_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/dataSim_lineshape.mat')\ndataRaw_lineshape_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/dataRaw_lineshape.mat')\ndataSim_lineshape = np.array(dataSim_lineshape_mat[\"dataSim_lineshape\"])\ndataRaw_lineshape = np.array(dataRaw_lineshape_mat[\"dataRaw_lineshape\"])\n\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\nabsorption_lineshape = [\"Super-Lorentzian\", \"Lorentzian\", \"Gaussian\"]\n\nfig = go.Figure()\n\n#Add traces (three traces per fitting model)\nfor ii in range(len(absorption_lineshape)):\n    if ii==0:\n        vis = True\n    else:\n        vis = False\n        \n    fig.add_trace(go.Scatter(x=dataSim_lineshape[:,0,0], y=dataSim_lineshape[:,1,ii],\n                             name=\"Fitted curve (angle = 142)\", mode='lines', line=dict(color=\"firebrick\"), visible = vis,\n                             hovertemplate=\"Fitted curve (angle = 142)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>\"))\n    \n    fig.add_trace(go.Scatter(x=dataSim_lineshape[:,0,0], y=dataSim_lineshape[:,2,ii],\n                             name=\"Fitted curve (angle = 426)\", mode='lines', line=dict(color=\"royalblue\"), visible = vis,\n                             hovertemplate=\"Fitted curve (angle = 426)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>\"))\n    \n    fig.add_trace(go.Scatter(x=dataRaw_lineshape[:,0,0], y=dataRaw_lineshape[:,1,ii],\n                             name=\"Raw data\", mode='markers', line=dict(color=\"darkslategray\"), visible = vis,\n                             hovertemplate=\"Raw data<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>\"))\n\nbuttons = []\nfor i, label in enumerate(absorption_lineshape):\n    visibility = [False] * 9\n    for j in range(3):\n        visibility[3*i+j] = True\n    button = dict(\n                label =  label,\n                method = 'update',\n                args = [{'visible': visibility}])\n    buttons.append(button)\n        \nupdatemenus = list([\n    dict(active=0,\n         x=0.98,\n         y=1.1,\n         buttons=buttons\n    )\n])\n\nfig['layout']['updatemenus'] = updatemenus\n\nfig.update_layout(height=450, width=580, plot_bgcolor='rgba(0,0,0,0)',\n                 margin=go.layout.Margin(\n                     l=120,\n                     r=80,\n                     b=80,\n                     t=40,\n                     )\n                 )\nfig.update_layout(legend=dict(\n        x=0.55,\n        y=0.1,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2),\n    annotations=[\n        dict(\n            x=0.35,\n            y=1.1,\n            showarrow=False,\n            text='Absorption lineshape: ',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5004254919715793,\n            y=-0.2,\n            showarrow=False,\n            text='Frequency offset \\u0394 (Hz)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.2,\n            y=0.5,\n            showarrow=False,\n            text='Magnetization |M<sub>z</sub>|',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ])\n\nfig.update_xaxes(type=\"log\", range=[2,5], showline=True, linewidth=2, linecolor='black', dtick=1, tickvals=[100,1000,10000,100000], ticktext=[\"10<sup>2</sup>\",\"10<sup>3</sup>\",\"10<sup>4</sup>\",\"10<sup>5</sup>\"])\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black')\n\niplot(fig, filename='dropdown', config=config)","type":"content","url":"/figure-6-1-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-1-3","position":0},{"hierarchy":{"lvl1":""},"content":"import scipy\nimport scipy.io as sio\nfrom pathlib import Path\nimport numpy as np\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-01-qMT\"\n\n\nnumPulses = np.append(np.arange(10,100,10),np.arange(100,700,100))\nnumPulses = np.append(np.arange(1,6,1),numPulses)\n\ndataSim_Pulses_mat =  scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/blochSim/dataSim_Pulses.mat')\ndatablochSim_Pulses_mat =  scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/blochSim/datablochSim_Pulses.mat')\ndataRaw_Pulses_mat =  scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/blochSim/dataRaw_Pulses.mat')\ndatablochSimResetMz_Pulses_mat =  scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/blochSim/datablochSimResetMz_Pulses.mat')\ndataRawResetMz_Pulses_mat =  scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/blochSim/dataRawResetMz_Pulses.mat')\n\ndataSimAnalytical_Pulses = np.array(dataSim_Pulses_mat[\"dataSim_Pulses\"])\ndataBlochSim_Pulses = np.array(datablochSim_Pulses_mat[\"datablochSim_Pulses\"])\ndataRaw_Pulses = np.array(dataRaw_Pulses_mat[\"dataRaw_Pulses\"])\ndataBlochSimResetMz_Pulses = np.array(datablochSimResetMz_Pulses_mat[\"datablochSimResetMz_Pulses\"])\ndataRawResetMz_Pulses = np.array(dataRawResetMz_Pulses_mat[\"dataRawResetMz_Pulses\"])\n\n\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\ndataSimAnalyticalPulses1 = [dict(\n        visible = False,\n        x = dataSimAnalytical_Pulses[:,0,0],\n        y = dataSimAnalytical_Pulses[:,1,ii],\n        line = dict(color = \"firebrick\"),\n        name = 'Analytical Solution (angle = 142)',\n        hovertemplate = 'Analytical Solution (angle = 142)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>') for ii in range(len(numPulses))]\n\ndataSimAnalyticalPulses1[4]['visible'] = True\n\ndataSimAnalyticalPulses2 = [dict(\n        visible = False,\n        x = dataSimAnalytical_Pulses[:,0,0],\n        y = dataSimAnalytical_Pulses[:,2,ii],\n        line = dict(color = \"royalblue\"),\n        name = 'Analytical Solution (angle = 426)',\n        hovertemplate = 'Analytical Solution (angle = 426)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>') for ii in range(len(numPulses))]\n\ndataSimAnalyticalPulses2[4]['visible'] = True\n\ndataBlochSimPulses1 = [dict(\n        visible = False,\n        x = dataBlochSim_Pulses[:,0,0],\n        y = dataBlochSim_Pulses[:,1,ii],\n        line = dict(\n            color = \"firebrick\",\n            dash = 'dash'),\n        name = 'Bloch Simulation (angle = 142)',\n        text = 'Bloch Simulation (angle = 142)',\n        hovertemplate = 'Bloch Simulation (angle = 142)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>') for ii in range(len(numPulses))]\n\ndataBlochSimPulses1[4]['visible'] = True\n\ndataBlochSimPulses2 = [dict(\n        visible = False,\n        x = dataBlochSim_Pulses[:,0,0],\n        y = dataBlochSim_Pulses[:,2,ii],\n        line = dict(\n            color = \"royalblue\",\n            dash = 'dash'),\n        name = 'Bloch Simulation (angle = 426)',\n        hovertemplate = 'Bloch Simulation (angle = 426)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>') for ii in range(len(numPulses))]\n\ndataBlochSimPulses2[4]['visible'] = True\n\ndataRawPulses = [dict(\n        visible = False,\n        mode = 'markers',\n        marker = dict(color = \"darkslategray\"),\n        x = dataRaw_Pulses[:,0,0],\n        y = dataRaw_Pulses[:,1,ii],\n        name = 'Raw data',\n        hovertemplate = 'Raw data<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>') for ii in range(len(numPulses))]\n\ndataRawPulses[4]['visible'] = True\n\ndata = dataSimAnalyticalPulses1 + dataSimAnalyticalPulses2 + dataBlochSimPulses1 + dataBlochSimPulses2 + dataRawPulses\n\nsteps = []\nfor i in range(len(numPulses)):\n    step = dict(\n        method = 'restyle',  \n        args = ['visible', [False] * len(dataSimAnalyticalPulses1)],\n        label = str(numPulses[i])\n    )\n    step['args'][1][i] = True # Toggle i'th trace to \"visible\"\n    steps.append(step)\n\nsliders = [dict(\n    x = 0,\n    y = -0.0,\n    active = 7,\n    currentvalue = {\"prefix\": \"# of Pulses: <b>\"},\n    pad = {\"t\": 50, \"b\": 10},\n    steps = steps\n)]\n\nlayout = go.Layout(\n    plot_bgcolor='rgba(0,0,0,0)',\n    width=580,\n    height=450,\n    margin=go.layout.Margin(\n        l=80,\n        r=40,\n        b=60,\n        t=10,\n    ),\n    annotations=[\n        dict(\n            x=0.5004254919715793,\n            y=-0.2,\n            showarrow=False,\n            text='Frequency offset \\u0394 (Hz)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.14,\n            y=0.5,\n            showarrow=False,\n            text='Magnetization |M<sub>z</sub>|',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        autorange=False,\n        type=\"log\",\n        range=[2, 5],\n        dtick=1,\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        autorange=False,\n        range=[0, 1.1],\n        showgrid=False,\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.5,\n        y=0.05,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    ), \n    sliders=sliders\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'basic-line', config = config)","type":"content","url":"/figure-6-1-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-1-4","position":0},{"hierarchy":{"lvl1":""},"content":"import scipy\nimport scipy.io as sio\nfrom pathlib import Path\nimport numpy as np\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-01-qMT\"\n\n\n# Simulations have been performed and the results have been saved in the folder results.\ndataSim_model_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/dataSim_model.mat')\ndataRaw_model_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/dataRaw_model.mat')\ndataSim_model = np.array(dataSim_model_mat[\"dataSim_modelFit\"])\ndataRaw_model = np.array(dataRaw_model_mat[\"dataRaw_modelFit\"])\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\n# PYTHON CODE\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n\nfitModel = [\"Sled Pike RP\", \"Sled Pike CW\", \"Yarnykh\", \"Ramani\"]\n\nfig = go.Figure()\n\n#Add traces (three traces per fitting model)\nfor ii in range(len(fitModel)):\n    if ii==0:\n        vis = True\n    else:\n        vis = False\n    fig.add_trace(go.Scatter(x=dataSim_model[:,0,0], y=dataSim_model[:,1,ii],\n                             name=\"Fitted curve (angle = 142)\", mode='lines', line=dict(color=\"firebrick\"), visible = vis,\n                             hovertemplate=\"Fitted curve (angle = 142)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>\"))\n    \n    fig.add_trace(go.Scatter(x=dataSim_model[:,0,0], y=dataSim_model[:,2,ii],\n                             name=\"Fitted curve (angle = 426)\", mode='lines', line=dict(color=\"royalblue\"), visible = vis,\n                             hovertemplate=\"Fitted curve (angle = 426)<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>\"))\n    \n    fig.add_trace(go.Scatter(x=dataRaw_model[:,0,0], y=dataRaw_model[:,1,ii],\n                             name=\"Raw data\", mode='markers', line=dict(color=\"darkslategray\"), visible = vis,\n                             hovertemplate=\"Raw data<br>M<sub>z</sub> = %{y}<br>Offset = %{x} Hz<extra></extra>\"))\n\n\nbuttons = []\nfor i, label in enumerate(fitModel):\n    visibility = [False] * 12\n    for j in range(3):\n        visibility[3*i+j] = True\n    button = dict(\n                label =  label,\n                method = 'update',\n                args = [{'visible': visibility}])\n    buttons.append(button)\n        \nupdatemenus = list([\n    dict(active=0,\n         x=0.88,\n         y=1.1,\n         buttons=buttons\n    )\n])\n\nfig['layout']['updatemenus'] = updatemenus\n\nfig.update_layout(height=450, width=580, plot_bgcolor='rgba(0,0,0,0)')\nfig.update_layout(legend=dict(\n        x=0.55,\n        y=0.1,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2),\n    annotations=[\n        dict(\n            x=0.35,\n            y=1.1,\n            showarrow=False,\n            text='Fitting method: ',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5004254919715793,\n            y=-0.2,\n            showarrow=False,\n            text='Frequency offset \\u0394 (Hz)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.14,\n            y=0.5,\n            showarrow=False,\n            text='Magnetization |M<sub>z</sub>|',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ])\n\nfig.update_xaxes(type=\"log\", range=[2,5], showline=True, linewidth=2, linecolor='black', dtick=1, tickvals=[100,1000,10000,100000], ticktext=[\"10<sup>2</sup>\",\"10<sup>3</sup>\",\"10<sup>4</sup>\",\"10<sup>5</sup>\"])\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black')\n\niplot(fig, filename='dropdown')","type":"content","url":"/figure-6-1-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-1-5","position":0},{"hierarchy":{"lvl1":""},"content":"import scipy\nimport scipy.io as sio\nfrom pathlib import Path\nimport numpy as np\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-01-qMT\"\n\n\n#Percentage error\n\nb1NormFittedData_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/fitSyntheticData/b1NormFittedResults.mat')\nb1NormFittedData = np.array(b1NormFittedData_mat[\"b1NormFittedResults\"])\n\nb0NormFittedData_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/fitSyntheticData/b0NormFittedResults.mat')\nb0NormFittedData = np.array(b0NormFittedData_mat[\"b0NormFittedResults\"])\n\nt1NormFittedData_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/fitSyntheticData/t1NormFittedResults.mat')\nt1NormFittedData = np.array(t1NormFittedData_mat[\"t1NormFittedResults\"])\n\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\n# PYTHON CODE\ninit_notebook_mode(connected=True)\n\nlabels = [\"B1 map\", \"B0 map\", \"T1 map\"]\nFittedParams = [\"F\", \"kf (s<sup>-1</sup>)\", \"T2,f (s)\", \"T2,r\"]\n\nfig = make_subplots(rows=2, cols=2)\n\n#F\ntrace1_b1 = go.Scatter(x=b1NormFittedData[:,0], y=b1NormFittedData[:,1],\n                       name=\"F\", mode='lines', line=dict(color=\"royalblue\"), visible=True,\n                       hovertemplate=\"Error (%) = %{y}<br>B1 value = %{x} <extra></extra>\")\ntrace1_b0 = go.Scatter(x=b0NormFittedData[:,0], y=b0NormFittedData[:,1],\n                       name=\"F\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>B0 value = %{x} Hz<extra></extra>\")\ntrace1_t1 = go.Scatter(x=t1NormFittedData[:,0], y=t1NormFittedData[:,1],\n                       name=\"F\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>T1 value = %{x} s<extra></extra>\")\n\nfig.append_trace(trace1_b1, 1, 1)\nfig.append_trace(trace1_b0, 1, 1)\nfig.append_trace(trace1_t1, 1, 1)\n\n#kf\ntrace2_b1 = go.Scatter(x=b1NormFittedData[:,0], y=b1NormFittedData[:,2],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=True,\n                       hovertemplate=\"Error (%) = %{y}<br>B1 value = %{x} <extra></extra>\")\ntrace2_b0 = go.Scatter(x=b0NormFittedData[:,0], y=b0NormFittedData[:,2],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>B0 value = %{x} Hz<extra></extra>\")\ntrace2_t1 = go.Scatter(x=t1NormFittedData[:,0], y=t1NormFittedData[:,2],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>T1 value = %{x} s<extra></extra>\")\n\nfig.append_trace(trace2_b1, 1, 2)\nfig.append_trace(trace2_b0, 1, 2)\nfig.append_trace(trace2_t1, 1, 2)\n\n#T2f\ntrace3_b1 = go.Scatter(x=b1NormFittedData[:,0], y=b1NormFittedData[:,3],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=True,\n                       hovertemplate=\"Error (%) = %{y}<br>B1 value = %{x} <extra></extra>\")\ntrace3_b0 = go.Scatter(x=b0NormFittedData[:,0], y=b0NormFittedData[:,3],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>B0 value = %{x} Hz<extra></extra>\")\ntrace3_t1 = go.Scatter(x=t1NormFittedData[:,0], y=t1NormFittedData[:,3],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>T1 value = %{x} s<extra></extra>\")\n\nfig.append_trace(trace3_b1, 2, 1)\nfig.append_trace(trace3_b0, 2, 1)\nfig.append_trace(trace3_t1, 2, 1)\n\n#T2r\ntrace4_b1 = go.Scatter(x=b1NormFittedData[:,0], y=b1NormFittedData[:,4],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=True,\n                       hovertemplate=\"Error (%) = %{y}<br>B1 value = %{x} <extra></extra>\")\ntrace4_b0 = go.Scatter(x=b0NormFittedData[:,0], y=b0NormFittedData[:,4],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>B0 value = %{x} Hz<extra></extra>\")\ntrace4_t1 = go.Scatter(x=t1NormFittedData[:,0], y=t1NormFittedData[:,4],\n                       name=\"kf\", mode='lines', line=dict(color=\"royalblue\"), visible=False,\n                       hovertemplate=\"Error (%) = %{y}<br>T1 value = %{x} s<extra></extra>\")\n\nfig.append_trace(trace4_b1, 2, 2)\nfig.append_trace(trace4_b0, 2, 2)\nfig.append_trace(trace4_t1, 2, 2)\n\nbuttons = []\nfor i, label in enumerate(labels):\n    visibility = [i==j for j in range(len(labels))]\n    button = dict(\n                label =  label,\n                method = 'update',\n                args = [{'visible': visibility}])\n    buttons.append(button)\n        \nupdatemenus = list([\n    dict(active=0,\n         x=0.65,\n         y=1.1,\n         buttons=buttons\n    )\n])\n\nfig['layout']['showlegend'] = False\nfig['layout']['updatemenus'] = updatemenus\n\nfig.update_xaxes(title_text='Input map', title_font=dict(family='Times New Roman', size=18),\n                 row=1, col=1, showline=True, linewidth=2, linecolor='black')\nfig.update_xaxes(title_text='Input map', title_font=dict(family='Times New Roman', size=18),\n                 row=1, col=2, showline=True, linewidth=2, linecolor='black')\nfig.update_xaxes(title_text='Input map', title_font=dict(family='Times New Roman', size=18),\n                 row=2, col=1, showline=True, linewidth=2, linecolor='black')\nfig.update_xaxes(title_text='Input map', title_font=dict(family='Times New Roman', size=18),\n                 row=2, col=2, showline=True, linewidth=2, linecolor='black')\nfig.update_yaxes(range=[-100,100], row=1, col=1, showline=True, linewidth=2, linecolor='black')\nfig.update_yaxes(range=[-100,100], row=1, col=2, showline=True, linewidth=2, linecolor='black')\nfig.update_yaxes(range=[-100,100], row=2, col=1, showline=True, linewidth=2, linecolor='black')\nfig.update_yaxes(range=[-100,100], row=2, col=2, showline=True, linewidth=2, linecolor='black')\n\nfig.update_layout(height=500, width=600, plot_bgcolor='rgba(0,0,0,0)')\nfig.update_layout(annotations=[\n    dict(\n        x=0.20,\n        y=1.1,\n        showarrow=False,\n        text='Input map: ',\n        font=dict(\n            family='Times New Roman',\n            size=22\n            ),\n        xref='paper',\n        yref='paper'\n        ),\n    dict(\n        x=-0.1,\n        y=0.90,\n        showarrow=False,\n        text='% Error in ' + FittedParams[0],\n        font=dict(\n            family='Times New Roman',\n            size=18\n            ),\n        textangle=-90,\n        xref='paper',\n        yref='paper'\n        ),\n    dict(\n        x=0.48,\n        y=0.98,\n        showarrow=False,\n        text='% Error in ' + FittedParams[1],\n        font=dict(\n            family='Times New Roman',\n            size=18\n            ),\n        textangle=-90,\n        xref='paper',\n        yref='paper'\n        ),\n    dict(\n        x=-0.1,\n        y=0.03,\n        showarrow=False,\n        text='% Error in ' + FittedParams[2],\n        font=dict(\n            family='Times New Roman',\n            size=18\n            ),\n        textangle=-90,\n        xref='paper',\n        yref='paper'\n        ),\n    dict(\n        x=0.48,\n        y=0.07,\n        showarrow=False,\n        text='% Error in ' + FittedParams[3],\n        font=dict(\n            family='Times New Roman',\n            size=18\n            ),\n        textangle=-90,\n        xref='paper',\n        yref='paper'\n        )\n])\nfig.update_layout(plot_bgcolor='rgba(0,0,0,0)',\n                 margin=go.layout.Margin(\n                     l=120,\n                     r=40,\n                     b=60,\n                     t=50,\n                     )\n                 )\nfig.update_layout()\n\niplot(fig, filename='basic-line', config=config)","type":"content","url":"/figure-6-1-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-1-6","position":0},{"hierarchy":{"lvl1":""},"content":"import scipy\nimport scipy.io as sio\nfrom pathlib import Path\nimport numpy as np\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-01-qMT\"\n\n\nb0map_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/b0mapMAT.mat')\nb0map = np.array(b0map_mat[\"b0mapMAT\"])\nb1map_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/b1mapMAT.mat')\nb1map = np.array(b1map_mat[\"b1mapMAT\"])\nr1map_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/r1mapMAT.mat')\nr1map = np.array(r1map_mat[\"r1mapMAT\"])\nmtdata_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/mtdataMAT.mat')\nmtdata = np.array(mtdata_mat[\"mtdataMAT\"])\nmask_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/maskMAT.mat')\nmask = np.array(mask_mat[\"maskMAT\"])\n\nFmap_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/FmapMAT.mat')\nFmap = np.array(Fmap_mat[\"FmapMAT\"])\nkfmap_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/kfmapMAT.mat')\nkfmap = np.array(kfmap_mat[\"kfmapMAT\"])\nT2fmap_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/T2fmapMAT.mat')\nT2fmap = np.array(T2fmap_mat[\"T2f\"])\nT2rmap_mat = scipy.io.loadmat(data_dir / 'qMT_tutorial-ISMRM2022-main' / 'results/realData/T2rmapMAT.mat')\nT2rmap = np.array(T2rmap_mat[\"T2r\"])\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom matplotlib.image import imread\nimport scipy.io\nimport plotly\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\n# PYTHON CODE\nfrom plotly import tools\n\nxAxis = np.arange(0,88)\nyAxis = np.arange(0,128)\n\nb0map = np.multiply(b0map,mask)\nb1map = np.multiply(b1map,mask)\nr1map = np.multiply(r1map,mask)\nmtdata_angle = np.multiply(mtdata[:,:,:,0].reshape((88,128)),mask)\nFmap = np.multiply(Fmap,mask)\nkfmap = np.multiply(kfmap,mask)\nT2fmap = np.multiply(T2fmap,mask)\nT2rmap = np.multiply(T2rmap,mask)\n\ntrace1 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(b0map,3),\n                   zmin=-30,\n                   zmax=30,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"B<sub>0</sub> (Hz)\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15), ypad=1),\n                   visible=True,\n                   name = 'B<sub>0</sub> (Hz)')\ntrace2 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(b1map,3),\n                   zmin=0.7,\n                   zmax=1.3,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"B<sub>1</sub>\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15), ypad=1),\n                   visible=False,\n                   name = 'B<sub>1</sub> values')\ntrace3 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(r1map,3),\n                   zmin=0.5,\n                   zmax=1.2,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"R<sub>1</sub> (s<sup>-1</sup>)\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15), ypad=1),\n                   visible=False,\n                   name = 'R<sub>1</sub> (s<sup>-1</sup>)')\ntrace4 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(mtdata_angle,3),\n                   zmin=0.5,\n                   zmax=1,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"MT\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15), ypad=1),\n                   visible=False,\n                   name = 'MT (angle 142)')\ntrace5 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(Fmap,3),\n                   zmin=0.05,\n                   zmax=0.3,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"F\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15), ypad=1),\n                   visible=True,\n                   name = 'F')\ntrace6 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(kfmap,3),\n                   colorscale='Portland',\n                   colorbar=dict(title = \"k<sub>f</sub> (s<sup>-1</sup>)\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15), ypad=1),\n                   visible=False,\n                   name = 'k<sub>f</sub> (s<sup>-1</sup>)')\ntrace7 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(T2fmap,3),\n                   zmin=0,\n                   zmax=0.05,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"T<sub>2f</sub> (ms)\", thickness=35,\n                           tickfont=dict(family='Times New Roman', size=15)),\n                   visible=False,\n                   name = 'T<sub>2f</sub> (ms)')\ntrace8 = go.Heatmap(x = xAxis,\n                   y = yAxis,\n                   z=np.rot90(T2rmap,3),\n                   zmin=5e-6,\n                   zmax=25e-6,\n                   colorscale='Portland',\n                   colorbar=dict(title = \"T<sub>2r</sub> (s)\", thickness=35, ticklen=7,\n                           tickfont=dict(family='Times New Roman', size=15)),\n                   visible=False,\n                   name = 'T<sub>2r</sub> (Œºs)')\n\ndata1=[trace1, trace2, trace3, trace4]\ndata2=[trace5, trace6, trace7, trace8]\n\nupdatemenus = list([\n    dict(active=0,\n         x = 0.2,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16\n            ),\n         buttons=list([   \n            dict(label = 'B0 map',\n                 method = 'update',\n                 args = [{'visible': [True, False, False, False]},\n                         ]),\n            dict(label = 'B1 map',\n                 method = 'update',\n                 args = [{'visible': [False, True, False, False]},\n                         ]),\n            dict(label = 'R1 map',\n                 method = 'update',\n                 args = [{'visible': [False, False, True, False]},\n                         ]),\n            dict(label = 'MT data',\n                 method = 'update',\n                 args = [{'visible': [False, False, False, True]},\n                         ])\n        ]),\n    )\n])\n\nlayout1 = dict(\n    width=345,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.5,\n            y=1.15,\n            showarrow=False,\n            text='Input maps',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        )\n    ],\n    xaxis = dict(range = [0,85], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    yaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus\n)\n\nfig = dict(data=data1,layout=layout1)\n\niplot(fig, filename = 'basic-heatmap', config = config)\n\nupdatemenus = list([    \n    dict(active=0,\n         x = 0.2,\n         xanchor = 'left',\n         y = -0.15,\n         yanchor = 'bottom',\n         direction = 'up',\n         font=dict(\n                family='Times New Roman',\n                size=16),\n         buttons=list([   \n            dict(label = 'F map',\n                 method = 'update',\n                 args = [{'visible': [True, False, False, False]},\n                         ]),\n            dict(label = 'kf map',\n                 method = 'update',\n                 args = [{'visible': [False, True, False, False]},\n                         ]),\n            dict(label = 'T2f map',\n                 method = 'update',\n                 args = [{'visible': [False, False, True, False]},\n                         ]),\n             dict(label = 'T2r map',\n                 method = 'update',\n                 args = [{'visible': [False, False, False, True]},\n                         ])\n        ]),\n    )\n])\n\nlayout2 = dict(\n    width=345,\n    height=345,\n    margin = dict(\n                t=40,\n                r=50,\n                b=10,\n                l=50),\n    annotations=[\n        dict(\n            x=0.5,\n            y=1.15,\n            showarrow=False,\n            text='Fitted maps',\n            font=dict(\n                family='Times New Roman',\n                size=26\n            ),\n            xref='paper',\n            yref='paper'\n        )\n    ],\n    xaxis = dict(range = [0,85], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    yaxis = dict(range = [0,127], autorange = False,\n             showgrid = False, zeroline = False, showticklabels = False,\n             ticks = '', domain=[0, 1]),\n    showlegend = False,\n    autosize = False,\n    updatemenus=updatemenus\n)\n\nfig = dict(data=data2,layout=layout2)\n\niplot(fig, filename = 'basic-heatmap', config = config)","type":"content","url":"/figure-6-1-6","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-2-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-02-MTR\"\ndata_file = \"fig_1.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n## Plot\n\n# Module imports\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n\n# Prepare Python environment\n\ntissue_names = mat_contents['tissue_names'].tolist()\ntissues = [\n    tissue_names[0][0][0],\n    tissue_names[0][1][0],\n    tissue_names[0][2][0],\n    tissue_names[0][3][0],\n    tissue_names[0][4][0]\n    ]\n    \nprotocol_names = mat_contents['protocol_names'].tolist()\nprotocols = [\n    protocol_names[0][0][0],\n    protocol_names[0][1][0],\n    protocol_names[0][2][0],\n    protocol_names[0][3][0],\n    ]\n    \nsignal_brownSiemens = mat_contents[\"MTRs\"][0]\nsignal_brownPhilips = mat_contents[\"MTRs\"][1]\nsignal_karakuzuSiemens = mat_contents[\"MTRs\"][2]\nsignal_karakuzuGE = mat_contents[\"MTRs\"][3]\n\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n\nbrown_siemens = go.Scatter(\n    x = tissues,\n    y = signal_brownSiemens,\n    name = protocols[0],\n    text = 'N/A',\n    hoverinfo = 'y'\n)\n\n\nbrown_philips = go.Scatter(\n    x = tissues,\n    y = signal_brownPhilips,\n    name = protocols[1],\n    hoverinfo = 'y'\n)\n\n\nkarakuzu_siemens = go.Scatter(\n    x = tissues,\n    y = signal_karakuzuSiemens,\n    name = protocols[2],\n    hoverinfo = 'y'\n)\n\n\nkarakuzu_ge = go.Scatter(\n    x = tissues,\n    y = signal_karakuzuGE,\n    name = protocols[3],\n    hoverinfo = 'y'\n)\n\n\ndata = [brown_siemens, brown_philips, karakuzu_siemens, karakuzu_ge]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='MTR',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig1.html', config = config)\n","type":"content","url":"/figure-6-2-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-2-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-02-MTR\"\ndata_file = \"fig4.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMTRs = mat_contents[\"MTRs\"][0]\nT1f = mat_contents[\"T1_range\"][0]\nT1_true = mat_contents[\"T1_true\"][0]\n\nx_T1_true = np.ones(len(MTRs))*T1_true[0]\ny_T1_true = np.linspace(MTRs[0]*0.95, MTRs[-1]*1.05, num=len(MTRs))\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n\ndata = [\n    go.Scatter(\n        x=T1f,\n        y=MTRs,\n        name = \"Protocol: Brown 2013 (Philips)\",\n        text = 'N/A',\n        hoverinfo = 'y'\n        ),\n    go.Scatter(\n        x=x_T1_true,\n        y=y_T1_true,\n        name = \"True T1f\",\n        text = 'N/A',\n        hoverinfo = 'y',\n        line = dict(shape = 'linear', color = 'rgb(0, 0, 0)', width = 2, dash = 'dash'),\n        ),\n        \n]\n\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='MTR',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5,\n            y=-0.15,\n            showarrow=False,\n            text='T1f (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0.36, 0.5]\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.2,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n)\n\nfig = dict(data=data, layout=layout)\n\n\niplot(fig, filename = 'fig4.html', config = config)\n","type":"content","url":"/figure-6-2-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-2-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-02-MTR\"\ndata_file = \"fig5.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMTRs = mat_contents[\"MTRs\"][0]\nB1 = mat_contents[\"B1_range\"][0]\nB1_true = 1\n\nx_B1_true = np.ones(len(MTRs))*B1_true\ny_B1_true = np.linspace(MTRs[0]*0.95, MTRs[-1]*1.1, num=len(MTRs))\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n\ndata = [\n    go.Scatter(\n        x=B1,\n        y=MTRs,\n        name = \"Protocol: Brown 2013 (Philips)\",\n        text = 'N/A',\n        hoverinfo = 'y'\n        ),\n    go.Scatter(\n        x=x_B1_true,\n        y=y_B1_true,\n        name = \"True B1 (B1 = 1)\",\n        text = 'N/A',\n        hoverinfo = 'y',\n        line = dict(shape = 'linear', color = 'rgb(0, 0, 0)', width = 2, dash = 'dash'),\n        ),\n        \n]\n\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='MTR',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5,\n            y=-0.15,\n            showarrow=False,\n            text='B1',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0.36, 0.5]\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.2,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n)\n\nfig = dict(data=data, layout=layout)\n\n\niplot(fig, filename = 'fig6.html', config = config)\n","type":"content","url":"/figure-6-2-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-2-4","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\n\ndata_dir = Path(\"../../../../DATA/qmrlab-mooc/06-MT-02-MTR\")\ndata_file = \"fig6.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n\nMTRs = mat_contents[\"MTRs\"][0]\nTR = mat_contents[\"TR_range\"][0]\nTR_true = mat_contents[\"trueTR\"][0]\n\nx_TR_true = np.ones(len(MTRs))*TR_true\ny_TR_true = np.linspace(MTRs[-1]*0.95, MTRs[0]*1.05, num=len(MTRs))\n\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n\ndata = [\n    go.Scatter(\n        x=TR,\n        y=MTRs,\n        name = \"Protocol: Brown 2013 (Philips)\",\n        text = 'N/A',\n        hoverinfo = 'y'\n        ),\n    go.Scatter(\n        x=x_TR_true,\n        y=y_TR_true,\n        name = \"True TR\",\n        text = 'N/A',\n        hoverinfo = 'y',\n        line = dict(shape = 'linear', color = 'rgb(0, 0, 0)', width = 2, dash = 'dash'),\n        ),\n        \n]\n\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='MTR',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.5,\n            y=-0.15,\n            showarrow=False,\n            text='TR (ms)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range = [0.36, 0.5]\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.2,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig7.html', config = config)\n","type":"content","url":"/figure-6-2-4","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-2-5","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\n\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-02-MTR\"\n\ndata_file = \"fig7.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMTRs = mat_contents[\"MTRs\"]\nTR = mat_contents[\"TR_range\"][0]\nB1 = mat_contents[\"B1_range\"][0]\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n\ndata = [\n    go.Contour(\n        z=MTRs,\n        x = B1,\n        y = TR,\n        contours = dict(\n            coloring ='heatmap',\n            showlabels = True, # show labels on contours\n            labelfont = dict( # label font properties\n                size = 12,\n                color = 'white',\n            )\n        ),\n    )      \n]\n\n\nlayout = go.Layout(\n    width=600,\n    height=600,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.2,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n)\n\nfig = dict(data=data, layout=layout)\n\n\niplot(fig, filename = 'fig8.html', config = config)\n","type":"content","url":"/figure-6-2-5","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-3-1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-03-MTsat\"\ndata_file = \"fig0.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\n## Plot\n\n# Module imports\n# PYTHON CODE\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n\n# Prepare Python environment\n\ntissues = [\n    \"Healthy Cortical GM\",\n    \"Healthy WM\",\n    \"NAWM\",\n    \"Early WM MS Lesion\",\n    \"Late WM MS Lesion\",\n    ]\n    \nprotocols = [\n    \"Helms 2008\",\n    \"Weiskopf 2013\",\n    \"Campbell 2018\",\n    \"Karakuzu 2022 Siemens 1\",\n    \"Karakuzu 2022 GE 1\",\n    \"York 2022\",\n    ]\n    \nsignal_Helms = mat_contents[\"MTsats\"][0]\nsignal_Weiskopf = mat_contents[\"MTsats\"][1]\nsignal_Campbell = mat_contents[\"MTsats\"][2]\nsignal_KarakuzuSiemens = mat_contents[\"MTsats\"][3]\nsignal_KarakuzuGE = mat_contents[\"MTsats\"][4]\nsignal_York = mat_contents[\"MTsats\"][5]\n\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n\ndata_Helms = go.Scatter(\n    x = tissues,\n    y = signal_Helms,\n    name = protocols[0],\n    text = 'N/A',\n    hoverinfo = 'y'\n)\n\n\ndata_Weiskopf = go.Scatter(\n    x = tissues,\n    y = signal_Weiskopf,\n    name = protocols[1],\n    hoverinfo = 'y'\n)\n\n\ndata_Campbell = go.Scatter(\n    x = tissues,\n    y = signal_Campbell,\n    name = protocols[2],\n    hoverinfo = 'y'\n)\n\n\ndata_KarakuzuSiemens = go.Scatter(\n    x = tissues,\n    y = signal_KarakuzuSiemens,\n    name = protocols[3],\n    hoverinfo = 'y'\n)\n\ndata_KarakuzuGE = go.Scatter(\n    x = tissues,\n    y = signal_KarakuzuGE,\n    name = protocols[4],\n    hoverinfo = 'y'\n)\n\ndata_York = go.Scatter(\n    x = tissues,\n    y = signal_York,\n    name = protocols[5],\n    hoverinfo = 'y'\n)\n\n\ndata = [data_Helms, data_Weiskopf, data_Campbell, data_KarakuzuSiemens, data_KarakuzuGE, data_York]\n\nlayout = go.Layout(\n    width=750,\n    height=750,\n    margin=go.layout.Margin(\n        l=100,\n        r=80,\n        b=100,\n        t=130,\n    ),\n    annotations=[\n        dict(\n            x=-0.15,\n            y=0.50,\n            showarrow=False,\n            text='MTsat (%)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    legend=dict(\n        x=0.25,\n        y=1.3,\n        traceorder='normal',\n        font=dict(\n            family='Times New Roman',\n            size=12,\n            color='#000'\n        ),\n        bordercolor='#000000',\n        borderwidth=2\n    )\n)\n\nfig = dict(data=data, layout=layout)\n\niplot(fig, filename = 'fig1.html', config = config)\n","type":"content","url":"/figure-6-3-1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-3-2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-03-MTsat\"\ndata_file = \"fig1_mtsat.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMTsats = mat_contents[\"MTsats\"][0]\nMTRs = mat_contents[\"MTRs\"][0]\nT1s = mat_contents[\"T1s\"][0]\nT1f = mat_contents[\"T1_range\"][0]\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.subplots import make_subplots\n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n## Setup for plots\nfig = make_subplots(rows=1, cols=3, horizontal_spacing = 0.1)\n\n\nfig.add_trace(\n        go.Scatter(\n        x=T1f,\n        y=MTRs,\n        hoverinfo = 'y',\n        showlegend=False\n        ), row= 1, col=1\n    )\nfig.add_trace(\n        go.Scatter(\n        x=T1f,\n        y=T1s,\n        hoverinfo = 'y',\n        showlegend=False\n        ), row= 1, col=2\n    )\nfig.add_trace(\n        go.Scatter(\n        x=T1f,\n        y=MTsats,\n        hoverinfo = 'y',\n        showlegend=False\n        ), row= 1, col=3\n    )\n\n\nlayout = go.Layout(\n    width=900,\n    height=250,\n    margin=go.layout.Margin(\n        l=200,\n        r=30,\n        b=60,\n        t=00,\n    ),\n    annotations=[\n        dict(\n            x=0.51,\n            y=-0.3,\n            showarrow=False,\n            text='T1f (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.92,\n            y=-0.3,\n            showarrow=False,\n            text='T1f (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.1,\n            y=-0.3,\n            showarrow=False,\n            text='T1f (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.08,\n            y=0.5,\n            showarrow=False,\n            text='MTR',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.285,\n            y=0.5,\n            showarrow=False,\n            text='T<sub>1</sub> (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.685,\n            y=0.5,\n            showarrow=False,\n            text='MTsat (%)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[50,70]\n    ),\n    xaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    yaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.7,1.3]\n    ),\n    xaxis3=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis3=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[5,7]\n    ),\n)\n\nfig.update_layout(layout)\n\nplot(fig, filename = 'mtsatt1.html', config = config)\n","type":"content","url":"/figure-6-3-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-3-3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-03-MTsat\"\ndata_file_a = \"fig2a_mtsat.mat\"\ndata_file_b = \"fig2b_mtsat.mat\"\n\n#Load either archived or generated plot variables\nmat_contents_a = sio.loadmat(data_dir / data_file_a)\nmat_contents_b = sio.loadmat(data_dir / data_file_b)\n\nMTsats_uncorr = mat_contents_a[\"MTsats\"][0]\nMTRs_uncorr = mat_contents_a[\"MTRs\"][0]\nB1s_uncorr = mat_contents_a[\"B1_range\"][0]\nT1s_uncorr = mat_contents_a[\"T1s\"][0]\n\nMTsats_corr = mat_contents_b[\"MTsats\"][0]\nMTRs_corr = mat_contents_b[\"MTRs\"][0]\nB1s_corr = mat_contents_b[\"B1_range\"][0]\nT1s_corr = mat_contents_b[\"T1s\"][0]\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.subplots import make_subplots\n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n## Setup for plots\nfig = make_subplots(rows=1, cols=3, horizontal_spacing = 0.1)\n\n\nfig.add_trace(\n        go.Scatter(\n        x=B1s_uncorr,\n        y=MTRs_uncorr,\n        hoverinfo = 'y',\n        showlegend=False,\n        visible=True\n        ), row= 1, col=1\n    )\nfig.add_trace(\n        go.Scatter(\n        x=B1s_uncorr,\n        y=T1s_uncorr,\n        hoverinfo = 'y',\n        showlegend=False,\n        visible=True\n        ), row= 1, col=2\n    )\nfig.add_trace(\n        go.Scatter(\n        x=B1s_uncorr,\n        y=MTsats_uncorr,\n        hoverinfo = 'y',\n        showlegend=False,\n        visible=True\n        ), row= 1, col=3\n    )\n\n\nfig.add_trace(\n        go.Scatter(\n        x=B1s_uncorr,\n        y=MTRs_corr,\n        hoverinfo = 'y',\n        showlegend=False,\n        visible=False\n        ), row= 1, col=1\n    )\nfig.add_trace(\n        go.Scatter(\n        x=B1s_uncorr,\n        y=T1s_corr,\n        hoverinfo = 'y',\n        showlegend=False,\n        visible=False\n        ), row= 1, col=2\n    )\nfig.add_trace(\n        go.Scatter(\n        x=B1s_corr,\n        y=MTsats_corr,\n        hoverinfo = 'y',\n        showlegend=False,\n        visible=False\n        ), row= 1, col=3\n    )\n\nlayout = go.Layout(\n    width=900,\n    height=300,\n    margin=go.layout.Margin(\n        l=200,\n        r=30,\n        b=60,\n        t=0,\n    ),\n    annotations=[\n        dict(\n            x=0.51,\n            y=-0.3,\n            showarrow=False,\n            text='B<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.9,\n            y=-0.3,\n            showarrow=False,\n            text='B<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.12,\n            y=-0.3,\n            showarrow=False,\n            text='B<sub>1</sub>',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=0,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=-0.08,\n            y=0.5,\n            showarrow=False,\n            text='MTR',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.28,\n            y=0.5,\n            showarrow=False,\n            text='T<sub>1</sub> (s)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.69,\n            y=0.5,\n            showarrow=False,\n            text='MTsat (%)',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            textangle=-90,\n            xref='paper',\n            yref='paper'\n        ),\n        dict(\n            x=0.24,\n            y=-0.45,\n            showarrow=False,\n            text='B<sub>1</sub> correction?',\n            font=dict(\n                family='Times New Roman',\n                size=22\n            ),\n            xref='paper',\n            yref='paper'\n        ),\n    ],\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[35,55]\n    ),\n    xaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n    ),\n    yaxis2=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[0.3,0.9]\n    ),\n    xaxis3=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2\n    ),\n    yaxis3=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        range=[4,7]\n    ),\n)\n\nfig.update_layout(\n    updatemenus=[\n        dict(\n            type=\"buttons\",\n            direction=\"right\",\n            active=0,\n            x=0.57,\n            y=-0.3,\n            buttons=list([\n                dict(label=\"No\",\n                     method=\"update\",\n                     args=[{\"visible\": [True, True, True, False, False, False]},\n                           ]),\n                dict(label=\"Yes\",\n                     method=\"update\",\n                     args=[{\"visible\": [False, False, False, True, True, True]},\n                           ]),\n            ]),\n        )\n    ])\n\nfig.update_layout(layout)\n\nplot(fig, filename = 'mtsatb1.html', config = config)\n","type":"content","url":"/figure-6-3-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-3-b1","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-03-MTsat\"\ndata_file = \"sim2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMz_after = mat_contents[\"Mz_after\"][0]\ndelta_Mz_T1relax = mat_contents[\"delta_Mz_T1relax\"][0]\nMz_before = mat_contents[\"Mz_before\"][0]\nM0_remainingTR_free =  mat_contents[\"M0_remainingTR_free\"][0]\ndelta_Mz_T1relax_remaining =  mat_contents[\"delta_Mz_T1relax_remaining\"][0]\n\nx=np.arange(1,len(Mz_before)+1)\ny1 = (1-(Mz_after)/Mz_before)*100\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.subplots import make_subplots\n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n## Setup for plots\nfig = make_subplots(rows=1, cols=1, horizontal_spacing = 0.1)\n\nfig.add_trace(\n        go.Scatter(\n        x=x,\n        y=y1,\n        hoverinfo = 'y',\n        visible=True,\n        name='(1-Mz<sub>after</sub>/Mz<sub>before</sub>)*100'\n        )\n    )\n\nlayout = go.Layout(\n    width=600,\n    height=500,\n    margin=go.layout.Margin(\n        l=60,\n        r=30,\n        b=60,\n        t=60,\n    ),\n    legend={\n        \"x\": 0.3,\n        \"y\": 0.9,\n        \"xref\": \"paper\",\n        \"yref\": \"paper\",\n    },\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        title='Repetition #'\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        title=\"\\\"MTsat\\\" (%)\"\n    ),\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig4.html', config = config)\n","type":"content","url":"/figure-6-3-b1","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-3-b2","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-03-MTsat\"\ndata_file = \"sim2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMz_after = np.squeeze(mat_contents[\"Mz_after\"])\ndelta_Mz_T1relax = np.squeeze(mat_contents[\"delta_Mz_T1relax\"])\nMz_before = np.squeeze(mat_contents[\"Mz_before\"])\nM0_remainingTR_free =  np.squeeze(mat_contents[\"M0_remainingTR_free\"])\ndelta_Mz_T1relax_remaining =  np.squeeze(mat_contents[\"delta_Mz_T1relax_remaining\"])\n\nx=np.arange(1,len(Mz_before)+1)\ny1 = (1-(Mz_after)/Mz_before)*100\ny2 = (1-(Mz_after-delta_Mz_T1relax)/Mz_before)*100\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.subplots import make_subplots\n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n## Setup for plots\nfig = make_subplots(rows=1, cols=1, horizontal_spacing = 0.1)\n\nfig.add_trace(\n        go.Scatter(\n        x=x,\n        y=y1,\n        hoverinfo = 'y',\n        visible=True,\n        name='MTsat before T1 correction'\n        )\n    )\n\nfig.add_trace(\n        go.Scatter(\n        x=x,\n        y=y2,\n        hoverinfo = 'y',\n        visible=True,\n        name='MTsat after T1 correction'\n        )\n    )\n\nlayout = go.Layout(\n    width=600,\n    height=500,\n    margin=go.layout.Margin(\n        l=60,\n        r=30,\n        b=60,\n        t=60,\n    ),\n    legend={\n        \"x\": 0.3,\n        \"y\": 0.9,\n        \"xref\": \"paper\",\n        \"yref\": \"paper\",\n    },\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        title='Repetition #'\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        title=\"\\\"MTsat\\\" (%)\"\n    ),\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig4.html', config = config)\n","type":"content","url":"/figure-6-3-b2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/figure-6-3-b3","position":0},{"hierarchy":{"lvl1":""},"content":"# Prepare Python environment\n\nimport scipy.io as sio\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"06-MT-03-MTsat\"\ndata_file = \"sim2.mat\"\n\n#Load either archived or generated plot variables\nmat_contents = sio.loadmat(data_dir / data_file)\n\nMz_after = mat_contents[\"Mz_after\"][0]\ndelta_Mz_T1relax = mat_contents[\"delta_Mz_T1relax\"][0]\nMz_before = mat_contents[\"Mz_before\"][0]\nM0_remainingTR_free =  mat_contents[\"M0_remainingTR_free\"][0]\ndelta_Mz_T1relax_remaining =  mat_contents[\"delta_Mz_T1relax_remaining\"][0]\n\nx=np.arange(1,len(Mz_before)+1)\ny1 = (1-(Mz_after-delta_Mz_T1relax)/Mz_before)*100\ny2=(1-(M0_remainingTR_free-delta_Mz_T1relax_remaining)/Mz_before)*100\ny3=(1-(Mz_after-delta_Mz_T1relax)/Mz_before)*100+(1-(M0_remainingTR_free-delta_Mz_T1relax_remaining)/Mz_before)*100\n\n# Plot Figure 1\n\n# Module imports\n\nimport matplotlib.pyplot as plt\nimport plotly as py\nimport plotly.graph_objs as go\nimport numpy as np\nfrom plotly import __version__\nfrom plotly.subplots import make_subplots\n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nconfig={'showLink': False, 'displayModeBar': False}\n\ninit_notebook_mode(connected=True)\n\n# PYTHON CODE\n\ninit_notebook_mode(connected=True)\n# The polling here is to ensure that plotly.js has already been loaded before\n# setting display alignment in order to avoid a race condition.\n\n## Setup for plots\nfig = make_subplots(rows=1, cols=1, horizontal_spacing = 0.1)\n\nfig.add_trace(\n        go.Scatter(\n        x=x,\n        y=y1,\n        hoverinfo = 'y',\n        visible=True,\n        name='MTsat contribution from MT pulse event'\n        )\n    )\n\nfig.add_trace(\n        go.Scatter(\n        x=x,\n        y=y2,\n        hoverinfo = 'y',\n        visible=True,\n        name='MTsat contribution from cross-relaxation event'\n        )\n    )\n\nfig.add_trace(\n        go.Scatter(\n        x=x,\n        y=y3,\n        hoverinfo = 'y',\n        visible=True,\n        name='Total MTsat for TR'\n        )\n    )\n\nlayout = go.Layout(\n    width=600,\n    height=500,\n    margin=go.layout.Margin(\n        l=60,\n        r=30,\n        b=60,\n        t=60,\n    ),\n    legend={\n        \"x\": 0.3,\n        \"y\": 0.9,\n        \"xref\": \"paper\",\n        \"yref\": \"paper\",\n    },\n    xaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        title='Repetition #'\n    ),\n    yaxis=dict(\n        showgrid=True,\n        gridcolor='rgb(169,169,169)',\n        linecolor='black',\n        linewidth=2,\n        title=\"\\\"MTsat\\\" (%)\"\n    ),\n)\n\nfig.update_layout(layout)\n\niplot(fig, filename = 'fig4.html', config = config)\n","type":"content","url":"/figure-6-3-b3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/flair-1","position":0},{"hierarchy":{"lvl1":""},"content":"import nibabel as nib\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom repo2data.repo2data import Repo2Data\nfrom pathlib import Path\n\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:  \n            yield\n        finally:\n            sys.stdout = old_stdout\n\nwith suppress_stdout():\n    repo_path = Path(os.path.abspath('')).parents[2]\n    data_req_path = repo_path / \"binder\" / \"data_requirement.json\"\n    data_path = repo_path / '..' / \"data\"\n    dataset_path = data_path / \"qmrlab-mooc\"\n    \n    if not dataset_path.exists():\n        repo2data = Repo2Data(data_req_path)\n\ndata_dir = dataset_path / \"07-Applications\"\n# SPGR function\n\ndef spgr(constant, T1, T2, TR, TE, FA):\n    return (constant * ((1 - np.exp(-TR / T1)) / (1 - np.cos(FA) * np.exp(-TR / T1)))* np.sin(FA))*np.exp(-TE/T2)\n\ndef ir(constant, T1, T2, TR, TI, TE, FA):\n    return constant * ((1- np.cos(np.pi) * np.exp(-TR / T1)- (1 - np.cos(np.pi))* np.exp(-TI / T1))/ (1- np.cos(np.pi)* np.cos(FA)* np.exp(-TR / T1)))*np.sin(FA)*np.exp(-TE/T2)\n\nt1map = nib.load(data_dir / \"FLAIR - T1 map.nii.gz\").get_fdata()\n\n# Simulate a T2 map by dividing the T1 map by 10\nt2map = t1map / 10\n\n# Get all the (x, y) ints in a grid that fall within a circle int(5) diameter for a center at (112,163)\n#x, y = np.mgrid[:t1map.shape[0], :t1map.shape[1]]\n#mask = (x - 115)**2 + (y - 158)**2 < 2.6**2\nmask = nib.load('Mask.nii.gz').get_fdata()\nmask=np.squeeze(mask)\n# Introduce a circular lesion at 100 and 150\nt2map[mask!=0] = t2map[mask!=0]*2\nt1map[mask!=0] = t1map[mask!=0]*1.1\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 5000\nTE = 150\nFA = 90\nt2w=spgr(1, t1map, t2map, TR, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(np.rot90(t2w),cmap='grey')\nplt.clim(0, 0.7)\nplt.colorbar()\nplt.show()\n\n\n# Simulate a T1-weighted spgr image using the T1 and T2 values voxel-wise\nTR = 500\nTE = 15\nFA = 70\nt1w=spgr(1, t1map, t2map, TR, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(np.rot90(t1w),cmap='grey')\nplt.clim(0, 0.6)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 5000\nTI = 50\nTE = 15\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 1.5)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 5000\nTI = 500\nTE = 15\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 1)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 5000\nTI = 1000\nTE = 15\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 1.2)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 5000\nTI = 3000\nTE = 15\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 1.2)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 10000\nTI = 3000\nTE = 150\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 0.5)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 5000\nTI = 3000\nTE = 15\nFA = 20\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 0.4)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 1000\nTI = 3000\nTE = 120\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 0.5)\nplt.colorbar()\nplt.show()\n\n# Simulate a T2-weighted spgr image using the T1 and T2 values voxel-wise, TR = 4000 ms, TE = 100 ms, and FA = 90 degrees\nTR = 10000\nTI = 3100\nTE = 1\nFA = 90\n\nflair=ir(1, t1map, t2map, TR, TI, TE, np.deg2rad(FA))\n\n# Plot the T2-weighted spgr image in black and white\nplt.imshow(abs(np.rot90(flair)),cmap='gray')\nplt.clim(0, 1.2)\nplt.colorbar()\nplt.show()","type":"content","url":"/flair-1","position":1},{"hierarchy":{"lvl1":"Answer A"},"type":"lvl1","url":"/t1cc-1-a","position":0},{"hierarchy":{"lvl1":"Answer A"},"content":"","type":"content","url":"/t1cc-1-a","position":1},{"hierarchy":{"lvl1":"Answer A","lvl2":"(PD-weighted, T1-weighted)"},"type":"lvl2","url":"/t1cc-1-a#id-pd-weighted-t1-weighted","position":2},{"hierarchy":{"lvl1":"Answer A","lvl2":"(PD-weighted, T1-weighted)"},"content":"","type":"content","url":"/t1cc-1-a#id-pd-weighted-t1-weighted","position":3},{"hierarchy":{"lvl1":"Answer A","lvl3":"INCORRECT ANSWER","lvl2":"(PD-weighted, T1-weighted)"},"type":"lvl3","url":"/t1cc-1-a#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer A","lvl3":"INCORRECT ANSWER","lvl2":"(PD-weighted, T1-weighted)"},"content":"The correct answer was: (T1-weighted, T2-weighted)\n\n\n\nProton density weighted\n\nT1 weighted\n\nT2 weighted\n\nEcho Time (TE)\n\nMedium\n\nShort\n\nLong\n\nRepetition time (TR)\n\nMedium\n\nShort\n\nLong\n\nT1-weighted images are optimized for greater T1 contrast between tissues-of-interest, while T2-weighted images are optimized for greater T2 contrast between tissues-of-interest.\n\nRevisiting \n\nFigure 2.8 and \n\nFigure 3.3, can you explain out why the T1w parameters were chosen to be [TR = 1 s, TE = 15 ms] and not [TR = 5s, TE = 150 ms]? Why was T2w protocol parameters [TR = 5s, TE = 150 ms] instead of [TR = 1 s, TE = 15 ms]?\n\nA common trick is to remember that white-matter is white in T1-weighted images, and water is bright in T2-weighted images. Here are those images again:\n\n","type":"content","url":"/t1cc-1-a#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer A","lvl2":"Return to Case Study"},"type":"lvl2","url":"/t1cc-1-a","position":6},{"hierarchy":{"lvl1":"Answer A","lvl2":"Return to Case Study"},"content":"The radiologist expresses concern that the standard T2-weighted image does not provide sufficient contrast to clearly identify periventricular lesions, which are a hallmark of MS. Given that these lesions are expected to consist of inflamed axon fibers with higher water content, the radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nLook at \n\nFigure¬†7.2, can you easily identify these lesions?\n\nFrom the information provided above, how do you think the T1 and T2 values will differ in a lesions vs normal white matter?\n\nA - \n\n(T1 increased, T2 decreases)\n\nB - \n\n(T1 decreases, T2 increases)\n\nC - \n\n(T1 increase, T2 barely changes)\n\nD - \n\n(T1 barely changes, T2 increases)","type":"content","url":"/t1cc-1-a","position":7},{"hierarchy":{"lvl1":"Question 1 - Answer"},"type":"lvl1","url":"/t1cc-1-answer","position":0},{"hierarchy":{"lvl1":"Question 1 - Answer"},"content":"\n\nProton density weighted\n\nT1 weighted\n\nT2 weighted\n\nEcho Time (TE)\n\nMedium\n\nShort\n\nLong\n\nRepetition time (TR)\n\nMedium\n\nShort\n\nLong\n\nT1-weighted images are optimized for greater T1 contrast between tissues-of-interest, while T2-weighted images are optimized for greater T2 contrast between tissues-of-interest.\n\nRevisiting \n\nFigure 2.8 and \n\nFigure 3.3, can you explain out why the T1w parameters were chosen to be [TR = 1 s, TE = 15 ms] and not [TR = 5s, TE = 150 ms]? Why was T2w protocol parameters [TR = 5s, TE = 150 ms] instead of [TR = 1 s, TE = 15 ms]?\n\n\n\nFigure¬†2.2:Inversion recovery curves (\n\nEq. 2.2) for three different T1 values, approximating the main types of tissue in the brain.\n\n\n\nFigure¬†3.3:Transverse relaxation decay curves for T2 and T2* values in white matter and gray matter. The T2 and T2* constants were taken from \n\nSiemonsen et al., 2008.\n\nA common trick is to remember that white-matter is white in T1-weighted images, and water is bright in T2-weighted images. Here are those images again:\n\n\n\nFigure¬†7.2:Spoiled gradient echo, 2 mm^2 in-plane resolution, 5 mm slice, TR = 5 s, TE = 150 ms, FA = 90 degrees\n\n\n\nFigure¬†7.1:Spoiled gradient echo, 2 mm^2 in-plane resolution, 5 mm slice, TR = 1 s, TE = 15 ms, FA = 70 degrees","type":"content","url":"/t1cc-1-answer","position":1},{"hierarchy":{"lvl1":"Answer B"},"type":"lvl1","url":"/t1cc-1-b","position":0},{"hierarchy":{"lvl1":"Answer B"},"content":"","type":"content","url":"/t1cc-1-b","position":1},{"hierarchy":{"lvl1":"Answer B","lvl2":"(PD-weighted, T2-weighted)"},"type":"lvl2","url":"/t1cc-1-b#id-pd-weighted-t2-weighted","position":2},{"hierarchy":{"lvl1":"Answer B","lvl2":"(PD-weighted, T2-weighted)"},"content":"","type":"content","url":"/t1cc-1-b#id-pd-weighted-t2-weighted","position":3},{"hierarchy":{"lvl1":"Answer B","lvl3":"INCORRECT ANSWER","lvl2":"(PD-weighted, T2-weighted)"},"type":"lvl3","url":"/t1cc-1-b#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer B","lvl3":"INCORRECT ANSWER","lvl2":"(PD-weighted, T2-weighted)"},"content":"The correct answer was: (T1-weighted, T2-weighted)\n\n\n\nProton density weighted\n\nT1 weighted\n\nT2 weighted\n\nEcho Time (TE)\n\nMedium\n\nShort\n\nLong\n\nRepetition time (TR)\n\nMedium\n\nShort\n\nLong\n\nT1-weighted images are optimized for greater T1 contrast between tissues-of-interest, while T2-weighted images are optimized for greater T2 contrast between tissues-of-interest.\n\nRevisiting \n\nFigure 2.8 and \n\nFigure 3.3, can you explain out why the T1w parameters were chosen to be [TR = 1 s, TE = 15 ms] and not [TR = 5s, TE = 150 ms]? Why was T2w protocol parameters [TR = 5s, TE = 150 ms] instead of [TR = 1 s, TE = 15 ms]?\n\nA common trick is to remember that white-matter is white in T1-weighted images, and water is bright in T2-weighted images. Here are those images again:\n\n","type":"content","url":"/t1cc-1-b#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer B","lvl2":"Return to Case Study"},"type":"lvl2","url":"/t1cc-1-b","position":6},{"hierarchy":{"lvl1":"Answer B","lvl2":"Return to Case Study"},"content":"The radiologist expresses concern that the standard T2-weighted image does not provide sufficient contrast to clearly identify periventricular lesions, which are a hallmark of MS. Given that these lesions are expected to consist of inflamed axon fibers with higher water content, the radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nLook at \n\nFigure¬†7.2, can you easily identify these lesions?\n\nFrom the information provided above, how do you think the T1 and T2 values will differ in a lesions vs normal white matter?\n\nA - \n\n(T1 increased, T2 decreases)\n\nB - \n\n(T1 decreases, T2 increases)\n\nC - \n\n(T1 increase, T2 barely changes)\n\nD - \n\n(T1 barely changes, T2 increases)","type":"content","url":"/t1cc-1-b","position":7},{"hierarchy":{"lvl1":"Answer C"},"type":"lvl1","url":"/t1cc-1-c","position":0},{"hierarchy":{"lvl1":"Answer C"},"content":"","type":"content","url":"/t1cc-1-c","position":1},{"hierarchy":{"lvl1":"Answer C","lvl2":"(T1-weighted, T2-weighted)"},"type":"lvl2","url":"/t1cc-1-c#id-t1-weighted-t2-weighted","position":2},{"hierarchy":{"lvl1":"Answer C","lvl2":"(T1-weighted, T2-weighted)"},"content":"","type":"content","url":"/t1cc-1-c#id-t1-weighted-t2-weighted","position":3},{"hierarchy":{"lvl1":"Answer C","lvl3":"CORRECT ANSWER","lvl2":"(T1-weighted, T2-weighted)"},"type":"lvl3","url":"/t1cc-1-c#correct-answer","position":4},{"hierarchy":{"lvl1":"Answer C","lvl3":"CORRECT ANSWER","lvl2":"(T1-weighted, T2-weighted)"},"content":"You got the correct answer!\n\n\n\nProton density weighted\n\nT1 weighted\n\nT2 weighted\n\nEcho Time (TE)\n\nMedium\n\nShort\n\nLong\n\nRepetition time (TR)\n\nMedium\n\nShort\n\nLong\n\nT1-weighted images are optimized for greater T1 contrast between tissues-of-interest, while T2-weighted images are optimized for greater T2 contrast between tissues-of-interest.\n\nRevisiting \n\nFigure 2.8 and \n\nFigure 3.3, can you explain out why the T1w parameters were chosen to be [TR = 1 s, TE = 15 ms] and not [TR = 5s, TE = 150 ms]? Why was T2w protocol parameters [TR = 5s, TE = 150 ms] instead of [TR = 1 s, TE = 15 ms]?\n\nA common trick is to remember that white-matter is white in T1-weighted images, and water is bright in T2-weighted images. Here are those images again:\n\n","type":"content","url":"/t1cc-1-c#correct-answer","position":5},{"hierarchy":{"lvl1":"Answer C","lvl2":"Return to Case Study"},"type":"lvl2","url":"/t1cc-1-c","position":6},{"hierarchy":{"lvl1":"Answer C","lvl2":"Return to Case Study"},"content":"The radiologist expresses concern that the standard T2-weighted image does not provide sufficient contrast to clearly identify periventricular lesions, which are a hallmark of MS. Given that these lesions are expected to consist of inflamed axon fibers with higher water content, the radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nLook at \n\nFigure¬†7.2, can you easily identify these lesions?\n\nFrom the information provided above, how do you think the T1 and T2 values will differ in a lesions vs normal white matter?\n\nA - \n\n(T1 increased, T2 decreases)\n\nB - \n\n(T1 decreases, T2 increases)\n\nC - \n\n(T1 increase, T2 barely changes)\n\nD - \n\n(T1 barely changes, T2 increases)","type":"content","url":"/t1cc-1-c","position":7},{"hierarchy":{"lvl1":"Answer D"},"type":"lvl1","url":"/t1cc-1-d","position":0},{"hierarchy":{"lvl1":"Answer D"},"content":"","type":"content","url":"/t1cc-1-d","position":1},{"hierarchy":{"lvl1":"Answer D","lvl2":"(T2-weighted, T1-weighted)"},"type":"lvl2","url":"/t1cc-1-d#id-t2-weighted-t1-weighted","position":2},{"hierarchy":{"lvl1":"Answer D","lvl2":"(T2-weighted, T1-weighted)"},"content":"","type":"content","url":"/t1cc-1-d#id-t2-weighted-t1-weighted","position":3},{"hierarchy":{"lvl1":"Answer D","lvl3":"INCORRECT ANSWER","lvl2":"(T2-weighted, T1-weighted)"},"type":"lvl3","url":"/t1cc-1-d#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer D","lvl3":"INCORRECT ANSWER","lvl2":"(T2-weighted, T1-weighted)"},"content":"The correct answer was: (T1-weighted, T2-weighted)\n\n\n\nProton density weighted\n\nT1 weighted\n\nT2 weighted\n\nEcho Time (TE)\n\nMedium\n\nShort\n\nLong\n\nRepetition time (TR)\n\nMedium\n\nShort\n\nLong\n\nT1-weighted images are optimized for greater T1 contrast between tissues-of-interest, while T2-weighted images are optimized for greater T2 contrast between tissues-of-interest.\n\nRevisiting \n\nFigure 2.8 and \n\nFigure 3.3, can you explain out why the T1w parameters were chosen to be [TR = 1 s, TE = 15 ms] and not [TR = 5s, TE = 150 ms]? Why was T2w protocol parameters [TR = 5s, TE = 150 ms] instead of [TR = 1 s, TE = 15 ms]?\n\nA common trick is to remember that white-matter is white in T1-weighted images, and water is bright in T2-weighted images. Here are those images again:\n\n","type":"content","url":"/t1cc-1-d#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer D","lvl2":"Return to Case Study"},"type":"lvl2","url":"/t1cc-1-d","position":6},{"hierarchy":{"lvl1":"Answer D","lvl2":"Return to Case Study"},"content":"The radiologist expresses concern that the standard T2-weighted image does not provide sufficient contrast to clearly identify periventricular lesions, which are a hallmark of MS. Given that these lesions are expected to consist of inflamed axon fibers with higher water content, the radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nLook at \n\nFigure¬†7.2, can you easily identify these lesions?\n\nFrom the information provided above, how do you think the T1 and T2 values will differ in a lesions vs normal white matter?\n\nA - \n\n(T1 increased, T2 decreases)\n\nB - \n\n(T1 decreases, T2 increases)\n\nC - \n\n(T1 increase, T2 barely changes)\n\nD - \n\n(T1 barely changes, T2 increases)","type":"content","url":"/t1cc-1-d","position":7},{"hierarchy":{"lvl1":"Question 2 - Question"},"type":"lvl1","url":"/t1cc-2-question","position":0},{"hierarchy":{"lvl1":"Question 2 - Question"},"content":"","type":"content","url":"/t1cc-2-question","position":1},{"hierarchy":{"lvl1":"Question 2 - Question","lvl2":"Return to Case Study"},"type":"lvl2","url":"/t1cc-2-question#return-to-case-study","position":2},{"hierarchy":{"lvl1":"Question 2 - Question","lvl2":"Return to Case Study"},"content":"The radiologist expresses concern that the standard T2-weighted image does not provide sufficient contrast to clearly identify periventricular lesions, which are a hallmark of MS. Given that these lesions are expected to consist of inflamed axon fibers with higher water content, the radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nLook at \n\nFigure¬†7.2, can you easily identify these lesions?\n\nFrom the information provided above, how do you think the T1 and T2 values will differ in a lesions vs normal white matter?\n\nA - \n\n(T1 increased, T2 decreases)\n\nB - \n\n(T1 decreases, T2 increases)\n\nC - \n\n(T1 increase, T2 barely changes)\n\nD - \n\n(T1 barely changes, T2 increases)","type":"content","url":"/t1cc-2-question#return-to-case-study","position":3},{"hierarchy":{"lvl1":"Answer A"},"type":"lvl1","url":"/t1cc-2-a","position":0},{"hierarchy":{"lvl1":"Answer A"},"content":"","type":"content","url":"/t1cc-2-a","position":1},{"hierarchy":{"lvl1":"Answer A","lvl2":"(T1 increased, T2 decreases)"},"type":"lvl2","url":"/t1cc-2-a#id-t1-increased-t2-decreases","position":2},{"hierarchy":{"lvl1":"Answer A","lvl2":"(T1 increased, T2 decreases)"},"content":"","type":"content","url":"/t1cc-2-a#id-t1-increased-t2-decreases","position":3},{"hierarchy":{"lvl1":"Answer A","lvl3":"INCORRECT ANSWER","lvl2":"(T1 increased, T2 decreases)"},"type":"lvl3","url":"/t1cc-2-a#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer A","lvl3":"INCORRECT ANSWER","lvl2":"(T1 increased, T2 decreases)"},"content":"The periventricular lesions are expected to be due to inflammation that leads to odeoma, which results in an increase in water content (increasing T2) but too early for permanent dammage of the underlying structures (T1 will change, but not dramatically).\n\nLet‚Äôs assume that the periventricular lesions have T2 is close to the ventricular T2, but that lesion T1 values remain close to their healthy values. Given what the radiologist requested from you,\n\nthe radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nwe want to design a pulse sequence that will provide better contrast between the periventricular lesions and the ventricles. Here‚Äôs a summary table of some expected parameters:\n\n\n\nHealthy WM\n\nVentricles\n\nPeriventricular lesion\n\nT1\n\nShort\n\nLong\n\nShort\n\nT2\n\nShort\n\nLong\n\nLong\n\nAfter some reflection, it should become clear why periventricular lesions are difficult to be observed with simple T1w and T2w images. In T1w images, the lesions have similar signal values to the nearby WM, and in T2w images they have similar signal values to the nearby ventricles. As lesions predominently exhibit an increase in water content, we‚Äôll want to design a sequence that has some T2-weighting, but with increase contrast between the lesion and ventricles.\n\nExamine \n\nFigure 2.2, \n\nFigure 2.8, \n\nFigure 3.3, and \n\nTable¬†1. Reflect and discuss on possible strategies for designing a sequence with improved contrast between the periventricular lesions and the ventricles. Once you‚Äôre done, click next.\n\nNext","type":"content","url":"/t1cc-2-a#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Question 2 - Answer"},"type":"lvl1","url":"/t1cc-2-answer","position":0},{"hierarchy":{"lvl1":"Question 2 - Answer"},"content":"The periventricular lesions are expected to be due to inflammation that leads to odeoma, which results in an increase in water content (increasing T2) but too early for permanent dammage of the underlying structures (T1 will change, but not dramatically).\n\nLet‚Äôs assume that the periventricular lesions have T2 is close to the ventricular T2, but that lesion T1 values remain close to their healthy values. Given what the radiologist requested from you,\n\nthe radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nwe want to design a pulse sequence that will provide better contrast between the periventricular lesions and the ventricles. Here‚Äôs a summary table of some expected parameters:\n\n\n\nHealthy WM\n\nVentricles\n\nPeriventricular lesion\n\nT1\n\nShort\n\nLong\n\nShort\n\nT2\n\nShort\n\nLong\n\nLong\n\nAfter some reflection, it should become clear why periventricular lesions are difficult to be observed with simple T1w and T2w images. In T1w images, the lesions have similar signal values to the nearby WM, and in T2w images they have similar signal values to the nearby ventricles. As lesions predominently exhibit an increase in water content, we‚Äôll want to design a sequence that has some T2-weighting, but with increase contrast between the lesion and ventricles.","type":"content","url":"/t1cc-2-answer","position":1},{"hierarchy":{"lvl1":"Answer B"},"type":"lvl1","url":"/t1cc-2-b","position":0},{"hierarchy":{"lvl1":"Answer B"},"content":"","type":"content","url":"/t1cc-2-b","position":1},{"hierarchy":{"lvl1":"Answer B","lvl2":"(T1 decreases, T2 increases)"},"type":"lvl2","url":"/t1cc-2-b#id-t1-decreases-t2-increases","position":2},{"hierarchy":{"lvl1":"Answer B","lvl2":"(T1 decreases, T2 increases)"},"content":"","type":"content","url":"/t1cc-2-b#id-t1-decreases-t2-increases","position":3},{"hierarchy":{"lvl1":"Answer B","lvl3":"INCORRECT ANSWER","lvl2":"(T1 decreases, T2 increases)"},"type":"lvl3","url":"/t1cc-2-b#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer B","lvl3":"INCORRECT ANSWER","lvl2":"(T1 decreases, T2 increases)"},"content":"The periventricular lesions are expected to be due to inflammation that leads to odeoma, which results in an increase in water content (increasing T2) but too early for permanent dammage of the underlying structures (T1 will change, but not dramatically).\n\nLet‚Äôs assume that the periventricular lesions have T2 is close to the ventricular T2, but that lesion T1 values remain close to their healthy values. Given what the radiologist requested from you,\n\nthe radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nwe want to design a pulse sequence that will provide better contrast between the periventricular lesions and the ventricles. Here‚Äôs a summary table of some expected parameters:\n\n\n\nHealthy WM\n\nVentricles\n\nPeriventricular lesion\n\nT1\n\nShort\n\nLong\n\nShort\n\nT2\n\nShort\n\nLong\n\nLong\n\nAfter some reflection, it should become clear why periventricular lesions are difficult to be observed with simple T1w and T2w images. In T1w images, the lesions have similar signal values to the nearby WM, and in T2w images they have similar signal values to the nearby ventricles. As lesions predominently exhibit an increase in water content, we‚Äôll want to design a sequence that has some T2-weighting, but with increase contrast between the lesion and ventricles.\n\nExamine \n\nFigure 2.2, \n\nFigure 2.8, \n\nFigure 3.3, and \n\nTable¬†1. Reflect and discuss on possible strategies for designing a sequence with improved contrast between the periventricular lesions and the ventricles. Once you‚Äôre done, click next.\n\nNext","type":"content","url":"/t1cc-2-b#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer C"},"type":"lvl1","url":"/t1cc-2-c","position":0},{"hierarchy":{"lvl1":"Answer C"},"content":"","type":"content","url":"/t1cc-2-c","position":1},{"hierarchy":{"lvl1":"Answer C","lvl2":"(T1 increase, T2 barely changes)"},"type":"lvl2","url":"/t1cc-2-c#id-t1-increase-t2-barely-changes","position":2},{"hierarchy":{"lvl1":"Answer C","lvl2":"(T1 increase, T2 barely changes)"},"content":"","type":"content","url":"/t1cc-2-c#id-t1-increase-t2-barely-changes","position":3},{"hierarchy":{"lvl1":"Answer C","lvl3":"INCORRECT ANSWER","lvl2":"(T1 increase, T2 barely changes)"},"type":"lvl3","url":"/t1cc-2-c#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer C","lvl3":"INCORRECT ANSWER","lvl2":"(T1 increase, T2 barely changes)"},"content":"The periventricular lesions are expected to be due to inflammation that leads to odeoma, which results in an increase in water content (increasing T2) but too early for permanent dammage of the underlying structures (T1 will change, but not dramatically).\n\nLet‚Äôs assume that the periventricular lesions have T2 is close to the ventricular T2, but that lesion T1 values remain close to their healthy values. Given what the radiologist requested from you,\n\nthe radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nwe want to design a pulse sequence that will provide better contrast between the periventricular lesions and the ventricles. Here‚Äôs a summary table of some expected parameters:\n\n\n\nHealthy WM\n\nVentricles\n\nPeriventricular lesion\n\nT1\n\nShort\n\nLong\n\nShort\n\nT2\n\nShort\n\nLong\n\nLong\n\nAfter some reflection, it should become clear why periventricular lesions are difficult to be observed with simple T1w and T2w images. In T1w images, the lesions have similar signal values to the nearby WM, and in T2w images they have similar signal values to the nearby ventricles. As lesions predominently exhibit an increase in water content, we‚Äôll want to design a sequence that has some T2-weighting, but with increase contrast between the lesion and ventricles.\n\nExamine \n\nFigure 2.2, \n\nFigure 2.8, \n\nFigure 3.3, and \n\nTable¬†1. Reflect and discuss on possible strategies for designing a sequence with improved contrast between the periventricular lesions and the ventricles. Once you‚Äôre done, click next.\n\nNext","type":"content","url":"/t1cc-2-c#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer D"},"type":"lvl1","url":"/t1cc-2-d","position":0},{"hierarchy":{"lvl1":"Answer D"},"content":"","type":"content","url":"/t1cc-2-d","position":1},{"hierarchy":{"lvl1":"Answer D","lvl2":"(T1 barely changes, T2 increases)"},"type":"lvl2","url":"/t1cc-2-d#id-t1-barely-changes-t2-increases","position":2},{"hierarchy":{"lvl1":"Answer D","lvl2":"(T1 barely changes, T2 increases)"},"content":"","type":"content","url":"/t1cc-2-d#id-t1-barely-changes-t2-increases","position":3},{"hierarchy":{"lvl1":"Answer D","lvl3":"CORRECT ANSWER","lvl2":"(T1 barely changes, T2 increases)"},"type":"lvl3","url":"/t1cc-2-d#correct-answer","position":4},{"hierarchy":{"lvl1":"Answer D","lvl3":"CORRECT ANSWER","lvl2":"(T1 barely changes, T2 increases)"},"content":"You got the correct answer!\n\nThe periventricular lesions are expected to be due to inflammation that leads to odeoma, which results in an increase in water content (increasing T2) but too early for permanent dammage of the underlying structures (T1 will change, but not dramatically).\n\nLet‚Äôs assume that the periventricular lesions have T2 is close to the ventricular T2, but that lesion T1 values remain close to their healthy values. Given what the radiologist requested from you,\n\nthe radiologist asks for your help in designing an imaging protocol that can better differentiate between the hyperintense CSF in the ventricles and the hyperintense periventricular lesions.\n\nwe want to design a pulse sequence that will provide better contrast between the periventricular lesions and the ventricles. Here‚Äôs a summary table of some expected parameters:\n\n\n\nHealthy WM\n\nVentricles\n\nPeriventricular lesion\n\nT1\n\nShort\n\nLong\n\nShort\n\nT2\n\nShort\n\nLong\n\nLong\n\nAfter some reflection, it should become clear why periventricular lesions are difficult to be observed with simple T1w and T2w images. In T1w images, the lesions have similar signal values to the nearby WM, and in T2w images they have similar signal values to the nearby ventricles. As lesions predominently exhibit an increase in water content, we‚Äôll want to design a sequence that has some T2-weighting, but with increase contrast between the lesion and ventricles.\n\nExamine \n\nFigure 2.2, \n\nFigure 2.8, \n\nFigure 3.3, and \n\nTable¬†1. Reflect and discuss on possible strategies for designing a sequence with improved contrast between the periventricular lesions and the ventricles. Once you‚Äôre done, click next.\n\nNext","type":"content","url":"/t1cc-2-d#correct-answer","position":5},{"hierarchy":{"lvl1":"Question 3"},"type":"lvl1","url":"/t1cc-3-question","position":0},{"hierarchy":{"lvl1":"Question 3"},"content":"Examine \n\nFigure 2.2, \n\nFigure 2.8, \n\nFigure 3.3, and \n\nTable¬†1. Reflect and discuss on possible strategies for designing a sequence with improved contrast between the periventricular lesions and the ventricles. Once you‚Äôre done, click next.\n\nNext","type":"content","url":"/t1cc-3-question","position":1},{"hierarchy":{"lvl1":"Answer"},"type":"lvl1","url":"/t1cc-3","position":0},{"hierarchy":{"lvl1":"Answer"},"content":"If you landed on using an inversion recovery sequence with an inversion time that nulls the ventricular signal, congratulation, you just discovered FLAIR (FLuid Attenuation Inversion Recovery)! This is a widely used technique, particular in suspected MS cases. It provides good T2 weighting with nearly no signal in purely ventricular regions.\n\nLet‚Äôs design a FLAIR protocol!\n\nUsing \n\nFigure 2.5 and \n\nFigure 2.2, approximately what inversion time should your sequence have?\n\nA - \n\n(TI = 50 ms)\n\nB - \n\n(TI = 500 ms)\n\nC - \n\n(TI = 1 s)\n\nD - \n\n(TI = 3 s)","type":"content","url":"/t1cc-3","position":1},{"hierarchy":{"lvl1":"Answer A"},"type":"lvl1","url":"/t1cc-4-a","position":0},{"hierarchy":{"lvl1":"Answer A"},"content":"","type":"content","url":"/t1cc-4-a","position":1},{"hierarchy":{"lvl1":"Answer A","lvl2":"(TI = 50 ms)"},"type":"lvl2","url":"/t1cc-4-a#id-ti-50-ms","position":2},{"hierarchy":{"lvl1":"Answer A","lvl2":"(TI = 50 ms)"},"content":"","type":"content","url":"/t1cc-4-a#id-ti-50-ms","position":3},{"hierarchy":{"lvl1":"Answer A","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 50 ms)"},"type":"lvl3","url":"/t1cc-4-a#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer A","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 50 ms)"},"content":"You selected a very short TI of 50 ms. Here is what an inversion recovery image with this TI would look like:\n\n\n\nFigure¬†7.3:Inversion recovery image with TI = 50 ms, TR = 5 s, TE = 15 ms, FA = 90 degrees\n\nAs you can see, there is little contrast at all accross tissues for a very short TI, as can be deduced via \n\nFigure 2.3. No tissue signal is nulled. Here are the simulated images for the three other answers: \n\nFigure¬†7.4, \n\nFigure¬†7.5, and \n\nFigure¬†7.6.\n\nThe correct answer was D (TI = 3s). Here‚Äôs what that looks like,\n\nAs you can see, ventricles are quite dark, meaning this TI nulls the ventricular signal. This is clearly deduced from \n\nFigure 2.3 by hovering the cursor over the white matter signal where it crosses 0.\n\nNow, despite knowing the correct inversion time, we still can‚Äôt see the lesions from \n\nFigure¬†7.6. We need to add T2 weighting to this inversion recovery image. What protocol should we use?\n\nA - \n\n(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)\n\nB - \n\n(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)\n\nC - \n\n(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)\n\nD - \n\n(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)","type":"content","url":"/t1cc-4-a#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Question 4 - Answer"},"type":"lvl1","url":"/t1cc-4-answer","position":0},{"hierarchy":{"lvl1":"Question 4 - Answer"},"content":"The correct answer was D (TI = 3s). Here‚Äôs what that looks like,\n\n\n\nFigure¬†7.6:Inversion recovery image with TI = 3 s, TR = 5 s, TE = 15 ms, FA = 90 degrees\n\nAs you can see, ventricles are quite dark, meaning this TI nulls the ventricular signal. This is clearly deduced from \n\nFigure 2.3 by hovering the cursor over the white matter signal where it crosses 0.","type":"content","url":"/t1cc-4-answer","position":1},{"hierarchy":{"lvl1":"Answer B"},"type":"lvl1","url":"/t1cc-4-b","position":0},{"hierarchy":{"lvl1":"Answer B"},"content":"","type":"content","url":"/t1cc-4-b","position":1},{"hierarchy":{"lvl1":"Answer B","lvl2":"(TI = 500 ms)"},"type":"lvl2","url":"/t1cc-4-b#id-ti-500-ms","position":2},{"hierarchy":{"lvl1":"Answer B","lvl2":"(TI = 500 ms)"},"content":"","type":"content","url":"/t1cc-4-b#id-ti-500-ms","position":3},{"hierarchy":{"lvl1":"Answer B","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 500 ms)"},"type":"lvl3","url":"/t1cc-4-b#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer B","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 500 ms)"},"content":"You selected a TI of 500 ms. Here is what an inversion recovery image with this TI would look like:\n\n\n\nFigure¬†7.4:Inversion recovery image with TI = 500 ms, TR = 5 s, TE = 15 ms, FA = 90 degrees\n\nAs you can see, white matter is quite dark, meaning this TI nulls the white matter signal. This could have been deduced from \n\nFigure 2.3 by hovering the cursor over the white matter signal where it crosses 0. Here are the simulated images for the three other answers: \n\nFigure¬†7.3, \n\nFigure¬†7.5, and \n\nFigure¬†7.6.\n\nThe correct answer was D (TI = 3s). Here‚Äôs what that looks like,\n\nAs you can see, ventricles are quite dark, meaning this TI nulls the ventricular signal. This is clearly deduced from \n\nFigure 2.3 by hovering the cursor over the white matter signal where it crosses 0.\n\nNow, despite knowing the correct inversion time, we still can‚Äôt see the lesions from \n\nFigure¬†7.6. We need to add T2 weighting to this inversion recovery image. What protocol should we use?\n\nA - \n\n(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)\n\nB - \n\n(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)\n\nC - \n\n(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)\n\nD - \n\n(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)","type":"content","url":"/t1cc-4-b#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer C"},"type":"lvl1","url":"/t1cc-4-c","position":0},{"hierarchy":{"lvl1":"Answer C"},"content":"","type":"content","url":"/t1cc-4-c","position":1},{"hierarchy":{"lvl1":"Answer C","lvl2":"(TI = 1 s)"},"type":"lvl2","url":"/t1cc-4-c#id-ti-1-s","position":2},{"hierarchy":{"lvl1":"Answer C","lvl2":"(TI = 1 s)"},"content":"","type":"content","url":"/t1cc-4-c#id-ti-1-s","position":3},{"hierarchy":{"lvl1":"Answer C","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 1 s)"},"type":"lvl3","url":"/t1cc-4-c#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer C","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 1 s)"},"content":"You selected a TI of 1 s. Here is what an inversion recovery image with this TI would look like:\n\n\n\nFigure¬†7.5:Inversion recovery image with TI = 1 s, TR = 5 s, TE = 15 ms, FA = 90 degrees\n\nAs you can see, grey matter is quite dark, meaning this TI nulls the grey matter signal. This could have been deduced from \n\nFigure 2.3 by hovering the cursor over the grey matter signal where it crosses 0. Here are the simulated images for the three other answers: \n\nFigure¬†7.3, \n\nFigure¬†7.4, and \n\nFigure¬†7.6.\n\nThe correct answer was D (TI = 3s). Here‚Äôs what that looks like,\n\nAs you can see, ventricles are quite dark, meaning this TI nulls the ventricular signal. This is clearly deduced from \n\nFigure 2.3 by hovering the cursor over the white matter signal where it crosses 0.\n\nNow, despite knowing the correct inversion time, we still can‚Äôt see the lesions from \n\nFigure¬†7.6. We need to add T2 weighting to this inversion recovery image. What protocol should we use?\n\nA - \n\n(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)\n\nB - \n\n(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)\n\nC - \n\n(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)\n\nD - \n\n(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)","type":"content","url":"/t1cc-4-c#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer D"},"type":"lvl1","url":"/t1cc-4-d","position":0},{"hierarchy":{"lvl1":"Answer D"},"content":"","type":"content","url":"/t1cc-4-d","position":1},{"hierarchy":{"lvl1":"Answer D","lvl2":"(TI = 3 s)"},"type":"lvl2","url":"/t1cc-4-d#id-ti-3-s","position":2},{"hierarchy":{"lvl1":"Answer D","lvl2":"(TI = 3 s)"},"content":"","type":"content","url":"/t1cc-4-d#id-ti-3-s","position":3},{"hierarchy":{"lvl1":"Answer D","lvl3":"CORRECT ANSWER","lvl2":"(TI = 3 s)"},"type":"lvl3","url":"/t1cc-4-d#correct-answer","position":4},{"hierarchy":{"lvl1":"Answer D","lvl3":"CORRECT ANSWER","lvl2":"(TI = 3 s)"},"content":"You got the correct answer!\n\nYou selected a TI of 3 s. Here is what an inversion recovery image with this TI would look like:\n\n\n\nFigure¬†7.6:Inversion recovery image with TI = 3 s, TR = 5 s, TE = 15 ms, FA = 90 degrees\n\nAs you can see, ventricles are quite dark, meaning this TI nulls the ventricular signal. This is clearly deduced from \n\nFigure 2.3 by hovering the cursor over the white matter signal where it crosses 0. Here are the simulated images for the three other answers: \n\nFigure¬†7.3, \n\nFigure¬†7.4, and \n\nFigure¬†7.5.\n\nNow, despite knowing the correct inversion time, we still can‚Äôt see the lesions from \n\nFigure¬†7.6. We need to add T2 weighting to this inversion recovery image. What protocol should we use?\n\nA - \n\n(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)\n\nB - \n\n(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)\n\nC - \n\n(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)\n\nD - \n\n(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)","type":"content","url":"/t1cc-4-d#correct-answer","position":5},{"hierarchy":{"lvl1":"Question 5 - Question"},"type":"lvl1","url":"/t1cc-5-question","position":0},{"hierarchy":{"lvl1":"Question 5 - Question"},"content":"Now, despite knowing the correct inversion time, we still can‚Äôt see the lesions from \n\nFigure¬†7.6. We need to add T2 weighting to this inversion recovery image. What protocol should we use?\n\nA - \n\n(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)\n\nB - \n\n(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)\n\nC - \n\n(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)\n\nD - \n\n(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)","type":"content","url":"/t1cc-5-question","position":1},{"hierarchy":{"lvl1":"Answer A"},"type":"lvl1","url":"/t1cc-5-a","position":0},{"hierarchy":{"lvl1":"Answer A"},"content":"","type":"content","url":"/t1cc-5-a","position":1},{"hierarchy":{"lvl1":"Answer A","lvl2":"(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)"},"type":"lvl2","url":"/t1cc-5-a#id-ti-3-s-tr-10-s-te-150-ms-fa-90-deg","position":2},{"hierarchy":{"lvl1":"Answer A","lvl2":"(TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg)"},"content":"Here is what an inversion recovery image with this protocol would look like:\n\n\n\nFigure¬†7.7:Inversion recovery image with TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg\n\nDo you think this is the correct answer? Can you see lesions?\n\nGo back\n\nView answer","type":"content","url":"/t1cc-5-a#id-ti-3-s-tr-10-s-te-150-ms-fa-90-deg","position":3},{"hierarchy":{"lvl1":"Question 5 - Answer"},"type":"lvl1","url":"/t1cc-5-answer","position":0},{"hierarchy":{"lvl1":"Question 5 - Answer"},"content":"The correct answer was A - (TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg). Here‚Äôs what this FLAIR image looks like:\n\n\n\nFigure¬†7.7:Inversion recovery image with TI = 3 s, TR = 10 s, TE = 150 ms, FA = 90 deg\n\nTwo periventricular lesions are clearly identifiable using this imaging protocol, which were hard to see on a regular T2w image \n\nFigure¬†7.2. The properly timed TI nulled the ventricular signal, whereas that long TR and TE provided sufficient T2 weighting to contrast against the nearby white matter, resulting in bright lesions, which are typically called hyperintese lesions.","type":"content","url":"/t1cc-5-answer","position":1},{"hierarchy":{"lvl1":"Answer B"},"type":"lvl1","url":"/t1cc-5-b","position":0},{"hierarchy":{"lvl1":"Answer B"},"content":"","type":"content","url":"/t1cc-5-b","position":1},{"hierarchy":{"lvl1":"Answer B","lvl2":"(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)"},"type":"lvl2","url":"/t1cc-5-b#id-ti-3-s-tr-5-s-te-15-ms-fa-20-deg","position":2},{"hierarchy":{"lvl1":"Answer B","lvl2":"(TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 deg)"},"content":"Here is what an inversion recovery image with this protocol would look like:\n\n\n\nFigure¬†7.8:Inversion recovery image with TI = 3 s, TR = 5 s, TE = 15 ms, FA = 20 degrees\n\nDo you think this is the correct answer? Can you see lesions?\n\nGo back\n\nView answer","type":"content","url":"/t1cc-5-b#id-ti-3-s-tr-5-s-te-15-ms-fa-20-deg","position":3},{"hierarchy":{"lvl1":"Answer C"},"type":"lvl1","url":"/t1cc-5-c","position":0},{"hierarchy":{"lvl1":"Answer C"},"content":"","type":"content","url":"/t1cc-5-c","position":1},{"hierarchy":{"lvl1":"Answer C","lvl2":"(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)"},"type":"lvl2","url":"/t1cc-5-c#id-ti-3-s-tr-1-s-te-150-ms-fa-45-deg","position":2},{"hierarchy":{"lvl1":"Answer C","lvl2":"(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)"},"content":"","type":"content","url":"/t1cc-5-c#id-ti-3-s-tr-1-s-te-150-ms-fa-45-deg","position":3},{"hierarchy":{"lvl1":"Answer C","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)"},"type":"lvl3","url":"/t1cc-5-c#incorrect-answer","position":4},{"hierarchy":{"lvl1":"Answer C","lvl3":"INCORRECT ANSWER","lvl2":"(TI = 3 s, TR = 1 s, TE = 150 ms, FA = 45 deg)"},"content":"You selected a TR that‚Äôs shorter than TI, which is not possible. Go back and try again.\n\nGo back","type":"content","url":"/t1cc-5-c#incorrect-answer","position":5},{"hierarchy":{"lvl1":"Answer D"},"type":"lvl1","url":"/t1cc-5-d","position":0},{"hierarchy":{"lvl1":"Answer D"},"content":"","type":"content","url":"/t1cc-5-d","position":1},{"hierarchy":{"lvl1":"Answer D","lvl2":"(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)"},"type":"lvl2","url":"/t1cc-5-d#id-ti-3-s-tr-3-1-s-te-1-s-fa-90-deg","position":2},{"hierarchy":{"lvl1":"Answer D","lvl2":"(TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg)"},"content":"Here is what an inversion recovery image with this protocol would look like:\n\n\n\nFigure¬†7.9:Inversion recovery image with TI = 3 s, TR = 3.1 s, TE = 1 s, FA = 90 deg\n\nDo you think this is the correct answer? Can you see lesions?\n\nGo back\n\nView answer","type":"content","url":"/t1cc-5-d#id-ti-3-s-tr-3-1-s-te-1-s-fa-90-deg","position":3},{"hierarchy":{"lvl1":"T1 Chapter Case Study"},"type":"lvl1","url":"/t1-chapter-case-study","position":0},{"hierarchy":{"lvl1":"T1 Chapter Case Study"},"content":"","type":"content","url":"/t1-chapter-case-study","position":1},{"hierarchy":{"lvl1":"T1 Chapter Case Study","lvl2":"Fictitious Case Study: Patient with Neurological Symptoms Consistent with MS"},"type":"lvl2","url":"/t1-chapter-case-study#fictitious-case-study-patient-with-neurological-symptoms-consistent-with-ms","position":2},{"hierarchy":{"lvl1":"T1 Chapter Case Study","lvl2":"Fictitious Case Study: Patient with Neurological Symptoms Consistent with MS"},"content":"","type":"content","url":"/t1-chapter-case-study#fictitious-case-study-patient-with-neurological-symptoms-consistent-with-ms","position":3},{"hierarchy":{"lvl1":"T1 Chapter Case Study","lvl3":"Patient Presentation","lvl2":"Fictitious Case Study: Patient with Neurological Symptoms Consistent with MS"},"type":"lvl3","url":"/t1-chapter-case-study#patient-presentation","position":4},{"hierarchy":{"lvl1":"T1 Chapter Case Study","lvl3":"Patient Presentation","lvl2":"Fictitious Case Study: Patient with Neurological Symptoms Consistent with MS"},"content":"A 32-year-old female presents to the neurology clinic with a 3-month history of intermittent numbness and weakness in her left leg, accompanied by episodes of blurred vision in her right eye. She reports that these symptoms last for several days and then partially resolve. She has no significant past medical history but mentions a family history of autoimmune diseases.","type":"content","url":"/t1-chapter-case-study#patient-presentation","position":5},{"hierarchy":{"lvl1":"T1 Chapter Case Study","lvl3":"Clinical Suspicion","lvl2":"Fictitious Case Study: Patient with Neurological Symptoms Consistent with MS"},"type":"lvl3","url":"/t1-chapter-case-study#clinical-suspicion","position":6},{"hierarchy":{"lvl1":"T1 Chapter Case Study","lvl3":"Clinical Suspicion","lvl2":"Fictitious Case Study: Patient with Neurological Symptoms Consistent with MS"},"content":"The patient‚Äôs symptoms are consistent with a demyelinating disorder, such as multiple sclerosis (MS). To confirm the diagnosis, the neurologist orders an MRI of the brain and spinal cord.\n\nMcDonald Criteria (2017) for MS Diagnosis\n\nClinical Attacks: At least two clinical attacks with evidence of two or more lesions OR two clinical attacks with evidence of one lesion (dissemination in space, DIS) and historical evidence of a prior attack.\n\nMRI Evidence:\n\nDissemination in space (DIS): ‚â•1 T2 lesion in at least 2 of 4 MS-typical regions (periventricular, cortical/juxtacortical, infratentorial, or spinal cord).\n\nDissemination in time (DIT): Simultaneous presence of gadolinium-enhancing and non-enhancing lesions OR new T2 or gadolinium-enhancing lesions on follow-up MRI.\n\nCSF Analysis: Oligoclonal bands in cerebrospinal fluid (CSF) can support the diagnosis if MRI criteria are not fully met.\n\nExclusion of Other Diagnoses: Symptoms must not be better explained by another condition.\n\nThe practicing radiologist provides you with two images and their acquisition protocols. Based on the parameters, you need to determine what types of images these are. Here are the protocols again for reference:\n\n\n\nFigure¬†7.1:Spoiled gradient echo, 2 mm^2 in-plane resolution, 5 mm slice, TR = 1 s, TE = 15 ms, FA = 70 degrees\n\n\n\nFigure¬†7.2:Spoiled gradient echo, 2 mm^2 in-plane resolution, 5 mm slice, TR = 5 s, TE = 150 ms, FA = 90 degrees\n\nWhat types of MRI images are (\n\nFigure¬†7.1, \n\nFigure¬†7.2)?\n\nA - \n\n(PD-weighted, T1-weighted)\n\nB - \n\n(PD-weighted, T2-weighted)\n\nC - \n\n(T1-weighted, T2-weighted)\n\nD - \n\n(T2-weighted, T1-weighted)","type":"content","url":"/t1-chapter-case-study#clinical-suspicion","position":7},{"hierarchy":{"lvl1":"MT"},"type":"lvl1","url":"/magnetization-transfer-imaging-1","position":0},{"hierarchy":{"lvl1":"MT"},"content":"","type":"content","url":"/magnetization-transfer-imaging-1","position":1},{"hierarchy":{"lvl1":"qMRI mOOC"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"qMRI mOOC"},"content":"\n\nContributions\n\nAuthors: Mathieu Boudreau, Alexandre D‚ÄôAstous, Agah Karakuzu, Katy Keenan, Nikola Stikov, Samuelle St-Onge, Juan Vel√°zquez-Reyes\n\nEditors: Mathieu Boudreau, Julien Cohen-Adad, Benjamin De Leener, Eva-Alonso Ortiz, Nikola Stikov","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"qMRI mOOC","lvl2":"About"},"type":"lvl2","url":"/#about","position":2},{"hierarchy":{"lvl1":"qMRI mOOC","lvl2":"About"},"content":"","type":"content","url":"/#about","position":3},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"What is a mOOC?","lvl2":"About"},"type":"lvl3","url":"/#what-is-a-mooc","position":4},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"What is a mOOC?","lvl2":"About"},"content":"A mini Open Online Course (mOOC) is course material developped to be open source. It provides free and afforadble access to technical material to a global audience.","type":"content","url":"/#what-is-a-mooc","position":5},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"Why a book on qMRI?","lvl2":"About"},"type":"lvl3","url":"/#why-a-book-on-qmri","position":6},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"Why a book on qMRI?","lvl2":"About"},"content":"Quantitative MRI (qMRI) aims to promise precise and reproducible measurements of tissue properties using MRI. This book is aimed to be be an accessible entry point into the world of qMRI for people with an already fundamental understanding of MRI, while also serving as a reference for advanced users, covering everything from fundamental concepts to state-of-the-art developments.","type":"content","url":"/#why-a-book-on-qmri","position":7},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"What sets apart this book?","lvl2":"About"},"type":"lvl3","url":"/#what-sets-apart-this-book","position":8},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"What sets apart this book?","lvl2":"About"},"content":"What distinguishes this book is its unique integration with hands-on, interactive resources such as MyST and Plotly. Leveraging the NeuroLibre platform, readers can fully reproduce the material in this book and allows them to engage with real qMRI data through their web browser. This approach bridges the gap between theoretical knowledge and practical application, providing a more engaging learning experience.","type":"content","url":"/#what-sets-apart-this-book","position":9},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"Can you contribute?","lvl2":"About"},"type":"lvl3","url":"/#can-you-contribute","position":10},{"hierarchy":{"lvl1":"qMRI mOOC","lvl3":"Can you contribute?","lvl2":"About"},"content":"Yes! This book is designed to be a living resource that evolves with the field of qMRI. We welcome contributions from researchers, educators, and practitioners in the field to share their knowledge and experience. Whether through proposing new topics, offering feedback on the current content, or submitting additional interactive resources, your input will help ensure that this book remains a relevant and dynamic tool for the qMRI community. Simply open an issue, pull request, or discussion on this book‚Äôs \n\nGitHub repository.","type":"content","url":"/#can-you-contribute","position":11}]}